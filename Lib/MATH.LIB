/* START LIBRARY DESCRIPTION ***************************************************
math.lib
	Copyright (c) 1999, Z-World.

DESCRIPTION: Math functions for Rabbit

SUPPORT LIBRARIES: several
END DESCRIPTION ***************************************************************/

/*
******** Math Library Discussion *******

Functions included in math libaries

Basic floating point functions - these are computed from first principles

 F_sub, F_add, F_mul, F_div, F_neg - add, subtrace, multiply, divide, negate (in multifp.lib)
 sqrt(x) - square root
 sin(x) - sine
 atan(x) - arc tangent
 pow2(x) - 2 to the power x
 log2(x) - logrithm of x base 2
 fmod(x,&n) - integer and fractional parts
 fabs(x) - absolute value x
 deg(x) - degrees in x radians
 rad(x) - radians in x degrees
 floor(x) - largest integer less than or equal to x
 ceil(x) - smallest integer greater than or equal to x

Derrivitive floating point functions (derrived from combinations of basic functions)

 pow10(x)- 10 to the x power
 exp(x) - e to the x power
 log10(x) - logrithm of x base 10
 log(x) - logrithm of x base e
 asin(x) - arc sine of x
 acos(x) - arc cosine of x
 acsc(x) - arc cosecant of x
 asec(x) - arc secant of x
 atan2(y,x) - arctan of y/x
 cos(x) - cosine of x
 cosh(x) - hyperbolic cosine of x
 sinh(x) - hyperbolic sine of x
 tan(x)- tangent of x
 tanh(x) - hyperbolic tangent of x
 pow(x,y) - x to y power

Discussion of Accuracy

 Generally the basic functions are accurate within 1-3 counts of the floating mantissa. However, in
 certain ranges of certain functions the relative accuracy is much less do to the intrinsic properties of
 floating point math. Accuracy expressed in counts of the floating mantissa is relative acccuracy -
 i.e. relative to the size of the number. Absolute accuracy is the absolute size of the error - e.g.
 .00001. The derrivitve functions, computed as combinations of the basic functions, typically
 have larger error because the errors of 2 or more basic functions are added together in some fashion.

 If the value of the function depends on the value of the difference of 2 floating point numbers that are
 close to each other in value, the reltive error generally becomes large, although the absolute error
 may remain well bounded. Examples are the logs of numbers near 1 and the sine of numbers near pi.
 For example, if the argument of the sine function is a floating point number is close to pi, say
 5 counts of the mantissa away from pi and it is subtracted from pi the result will be a number with
 only 3 significent bits. The relative error in the sine result will be very large, but the absolute
 error will still be very small. Functions with steep slopes, such as the exponent of larger numbers
 will show a large relative error, since the relative error in the argument is magnified by the slope.

Discussion of execution speed

 Floating add, subtract and multiply require approximately 350 clocks worst case on the Rabbit 2000
 microprocessor. Divide and square root require approximately 900 clocks. Sine and pow2, pow10 or exp
 require about 3200 clocks. Log, log2, log (base e), and atan need about 4000 clocks. Functions
 derrived from these functions often require 5000 or more clocks.

Exceptions - range errors

 Certain values will result in an exception. If debugging is in process this will result in an error message.
 If the exception takes place in a program in the field the response is entry into the error log
 (planned) and a watchdog timeout. Exceptions occur for:

 1) Square root of a negative number
 2) argument of exponent type function too large (x>129.9).
 3) Log of a negative number.



*/

/*** BeginHeader pow */

float pow(float x, float y);

/*** EndHeader   pow */

/*
 *      Raise X to the Yth Power
 *
 *  Range and Domain Error Generated by pow2() and log2()
 *                                               y
 *      Method :   y * log2(x)     log2(x )     y
 *                2          =    2         = x
 */

/* START FUNCTION DESCRIPTION ********************************************
pow                          <MATH.LIB>

SYNTAX:        float pow(float x, float y);

PARAMETER1:    Floating point number to be raised to the y power.

PARAMETER2:    Floating point power to which x is to be raised.

KEYWORDS:      math

DESCRIPTION:   Raises x to the yth power.

RETURN VALUE:	See description.

END DESCRIPTION **********************************************************/
nodebug float pow(float x, float y)
{
	//handle base of 0
	if (x==0.0 || x==  -0.0 )
	{
		if(y == 0.0 || y == -0.0)
		{
			return 1.0;
		}
		else if(y < 0.0)
		{
#asm
			EXCEPTION(-ERR_DOMAIN)
#endasm
			return ZERO;
		}
		else
		{
			return 0.0;
		}
	}
	if ( (x==0.0 || x==-0.0 ) && y == 1. )
		return 0.0;

	// if y is an integer, it's ok for x to be less than zero; but
	// log2 will choke on it...  so let's avoid that.
	if ((x < 0) && (y == (int)y)) {
		if ((int)(y)%2 == 0)
			return(pow2(y * log2(-x)));
		else
			return(-pow2(y * log2(-x)));
	}

	return(pow2(y * log2(x)));
}


/*** BeginHeader fx2 */

root float fx2(float);

/*** EndHeader */

#asm

fx2::

	ld		a,b					; 4  save the sign
	or		a						; 2  clear carry

	rl		c						; 4  roll the exponent into b
	rl		b						; 4
	inc	b						; 2  2 * exponent

	or		a						; 2  clear carry
	rr		b						; 4  restore exponent
	rr		c						; 4  restore mantissa

	bit	7,a					; 4
	jr		Z,.fx2Pos				; 5
	set	7,b					; 4

.fx2Pos:

	ret

#endasm


/*** BeginHeader f2bd */

root unsigned long f2bd(float);

/*** EndHeader */

#asm nodebug

f2bd::

	; Get the sign

	ld		a,b					; 2
	ex		af,af'				; 2  (8)

	; Get the exponent

	or		a						; 2  Clear carry
	rl		b						; 4
	bit	7,c					; 4
	jr		Z,.f2bd_Shift		; 5
	set	0,b					; 4  (19)

.f2bd_Shift:

	set	7,c					; 4  Set the implied 1

	; Shift the mantissa appropriately

	ld		a,127					; 4  Exponent bias = 0
	sub	a,b					; 2
	cp		a,8					; 4
	jr		C,.f2bd_rl			; 5  a < 8
	jp		Z,.f2bd_NoShift		; 5  (24)

	cp		a,24					; 4  Is the number too small to represent?
	jr		C,.f2bd_rr			; 5
	ld		bc,0					; 6
	ld		de,0					; 6
	jr		.f2bd_Exit			; 5  Make the number 0

.f2bd_rr:
	sub	a,8					; 4  Get the number of bits to shift right
	cp		a,8					; 4  Is this a byte shift? a >= 8
	jr		NC,.f2bd_rr8			; 5

	ld		b,0					; 4
.f2bd_rrN:						;    Perform an N bit shift
	ld		h,b					; 2
	ld		l,c					; 2
	bit	2,a					; 4
	jr		Z,.f2bd_rr2			; 5
	rr		hl						; 2  Perform a 4 bit shift
	rr		de						; 2
	rr		hl						; 2
	rr		de						; 2
	rr		hl						; 2
	rr		de						; 2
	rr		hl						; 2
	rr		de						; 2
.f2bd_rr2:
	bit	1,a					; 4
	jr		Z,.f2bd_rr1			; 5
	rr		hl						; 2  Perform a 2 bit shift
	rr		de						; 2
	rr		hl						; 2
	rr		de						; 2
.f2bd_rr1:
	bit	0,a					; 4
	jr		Z,.f2bd_rrdone		; 5
	rr		hl						; 2  Perform a 1 bit shift
	rr		de						; 2
.f2bd_rrdone:
	ld		b,0					; 4
	ld		c,l					; 2

	jp		.f2bd_NoShift		; 7  (45 for 1 bit, 69 for 7 bits, 104 for 15 bits, 97 for 23 bits)
									;    (27+4n for this method versus 15n for a simple loop.)
.f2bd_rr8:
	cp		a,16					; 4  Is this a two byte shift?
	jr		NC,.f2bd_rr16		; 5  a >= 16
	sub	a,8					; 4
	ld		e,d					; 2  Perform a one byte shift to the right
	ld		d,c					; 2
	ld		bc,0					; 6
	jr		Z,.f2bd_Sign			; 5  if a = 8, set sign and exit
	jr		.f2bd_rrN				; 5  (35)

.f2bd_rr16:
	sub	a,16					; 4
	ld		e,c					; 2  Perform a two byte shift to the right
	ld		bc,0					; 6
	ld		d,0					; 4
	jr		Z,.f2bd_Sign			; 5  if a = 16, set sign and exit
	jr		.f2bd_rrN				; 5  (28)

.f2bd_rl:
	neg							; 2  Roll the number left by 8-a bits
	add	a,8					; 4
	ld		b,0					; 4
	or		a						; 2  Clear carry

.f2bd_rlN:
	rl		de						; 2
	rl		c						; 4
	rl		b						; 4
	dec	a						; 2
	jr		NZ,.f2bd_rlN			; 5  (29 min, 131 max)
	jr		.f2bd_Sign			; 5

.f2bd_NoShift:

	ld		b,0					; 4

.f2bd_Sign:

	; Replace the sign bit

	ex		af,af'				; 2
	bit	7,a					; 4
	jr		Z,.f2bd_Exit			; 5  (11)

	; Calculate the twos complement if the number is negative

	or		a						; 2 Clear the carry flag
	ld		hl,0					; 6
	sbc	hl,de					; 4 Subtract 0 from low word
	ld		d,h					; 2
	ld		e,l					; 2
	ld		hl,0					; 6
	sbc	hl,bc					; 4 Subtract 0 from high word with carry
	ld		c,l					; 2
	ld		b,h					; 2  (30)

.f2bd_Exit:

	ret							; 8  (31)

#endasm


/*** BeginHeader bdSeries */

useix unsigned long bdSeries(char, unsigned long *, unsigned long);

/*** EndHeader */
//; total execution time 76+ (N-1)*201 clocks
nodebug
useix unsigned long bdSeries(char N, unsigned long *A, unsigned long X)

{
#asm xmemok
	ld		hl,(sp+N) 			; 9
	ld 	a,l       			; 2
	dec 	a  					;2 N-1 steps
	ex 	af,af'    			; 2 count in a'
	ld 	ix,(sp+A) 			; 11 pointer to coeficients
	ld 	iy,(sp+X) 			; 11 least of X
	ld 	hl,(sp+X+2) 		; 9 most of X
	ex 	de',hl    			;2 most of X in de'
	ld 	hl,iy 				; 4 -- 51
	ld 	b,h 					; 2
	ld 	c,l  					; 2 Xl in bc
	ld 	hl,(ix+2) 			; 8 Au
	ex 	de,hl     			; 2 Au to de
	ld 	hl,(ix)  			; 9 Al to hl
	ex 	de,hl  				;2
	ld 	bc',de 				;4
	ex 	de,hl   				;2
; total to here  74 clocks (1-time)
;
; setup at top of loop
; - Au Xl   iy=Xl
; - Xu Al   ix=*a
; result
;
.fr_psloop:
	ld 	a,b 					; 2 sign of Xl
	exx  							; 2
	xor 	b 						; 2 compare to sign of Al
	jp 	p,.fr_signsame  	; 7 if different/same signs

; signs are different here
; 13 to here
; signs different, see which neg
	xor 	b         			; 2 reverse previous xor to reveal sign of Xl
	jp 	p,.fr_Xlpos 			; 7 if alt regs have neg in bc

; - Xu Al   ix=*a
; - Au Xl   iy=Xl
;
; 22 to here Xl is negative, Al is positive
.fr_Xlneg:
	mul 							; 12
	exx 							; 2
	mul 							; 12
	add 	hl,de 				; 2 adjust
	ex 	de,hl' 				; 4
	or 	a 						; 2
	adc 	hl,de 				; 4 partial sum - possible overflow
	jr 	.frmul_2 				; 5 43+22=65 to _2

; 22 to here  Xl pos, Al neg
.fr_Xlpos:
	mul 							; 12
	add 	hl,de 				;2 adjust for neg
	exx 							;2
	mul 							; 12
	ex 	de,hl' 				; 4
	or 	a 						; clc
	adc 	hl,de  				; Yu*Xl+Yl*Xu -  possible overflow
	jr 	.frmul_2 				; 61 to _2

; - Xu Al   ix=*a
; - Au Xl   iy=Xl
;
; 13 to here
.fr_signsame:
	xor 	b  					; reverse xor find out what sign of Al is
	jp 	m,.fr_Alneg
; both positive 22 to here
	mul
	exx
	mul
	ex 	de,hl'
	adc 	hl,de 				; C clear   Yu*Xl+Yl*Xu -  possible overflow
	jr 	.frmul_2 				; 37+22=59 to _2


.fr_Alneg:
	mul
	add 	hl,de
	exx
	mul
	add 	hl,de
	ex 	de,hl'
	or 	a ; clc
	adc 	hl,de 				; 22+34=56   Yu*Xl+Yl*Xu - possible overflow
; continue

; 65 to here worst
;
; result entering here
; (Au*Xl)u + (Xu*Al)u    --       --   ix=*a
;  Au                     Xu      --   iy=Xl
;
	.frmul_2: 					; 65 to here from fr_psloop
	exx
	ld 	b,h   				; move Au to BC
	ld 	c,l
	mul 							; 65+18=83 create Xu*Au most product
; (Au*Xu)u               Xu     (Au*Xu)l
; (Au*Xl)u + (Xu*Al)u    --      --
; hl:bc has number, need to add hl'
	ld 	de',bc 				; 4
	exx
; 83+6=89
; (Au*Xl)u + (Xu*Al)u   (Au*Xu)l      --
;  (Au*Xu)u               Xu     (Au*Xu)l(deletable)
	jp 	ovf,.fr_ovfpath 	; 31+65=96 overflow still set from 4 mul paths (adc hl,de) above
; non overflow path
; L1  L2  --
; U2  Xu  --  					; must compute sign extension of L1
	ld 	a,h 					; sign of L1
	exx
	ld 	b,h
	ld 	c,l 					; save U2 in BC
	rla 							; sign to carry
	jr 	.fr_ovflpath1 		; 15+96=111 continue in overflow path
;
	.fr_ovfpath:
	ld 	a,h 					; sign of L1
	exx
	ld 	b,h
	ld 	c,l 					; save U2 in BC
	rla 							; sign to carry
	ccf 							; due to overflow sign wrong
.fr_ovflpath1: 					; 111
	sbc 	hl,hl 				; hl has sign extension
	exx
; L1  L2  --
; U1  Xu  U2
	add 	hl,de 				; leasts
	exx
	adc 	hl,bc 				; mosts
; result in hl:hl'
; Pu  Xu  --
; Pl  --  --
; now do left shift
	exx
	add 	hl,hl
	exx
	adc 	hl,hl 				; 24+111= 135 left shift complete
	ld 	bc,4 					; step pointer
	add 	ix,bc 				; by 4 in table of coef
;
; Pu  Xu  --
; Pl  --  --
;
	ld 	b,h
	ld 	c,l
	ld 	hl,(ix+2) 			; most coef
	exx
	ex 	de,hl
	ld 	hl,(ix)
	add 	hl,de  				; least sum
	exx
	adc 	hl,bc  				; most sum
; Sm  Xu  --
; Sl  --  --
; 38+125=163

;
;
	ex 	af,af' 				; check count
	dec 	a
	jr 	z,.fr_done 			; 172
	ex 	af,af'
; setup at top of loop
; - Au Xl   iy=Xl
; - Xu Al   ix=*a
	ex 	de',hl
; -- Xu --
; Al Au --
;
	exx
; Al Au --
; -- Xu --
	ld 	b,h
	ld 	c,l
	ld 	bc',bc
; -- Au --
; -- Xu Al
	ld 	hl,iy
	ld 	b,h
	ld 	c,l
; -- Au Xl
; -- Xu Al
	jr 	.fr_psloop 			; loop again 38+163=201 loop time
;
.fr_done:  						; -29 one time
; return result in bc:de
	ex 	de,hl
	ld 	bc',de 				; most
	exx
	ex 	de,hl
; now return, restoring ix
	ld 	ix,0
	add 	ix,sp 				; restore ix -9  ;Grand total 74 + N*201
#endasm
}



/*** BeginHeader bd2f */

float bd2f(unsigned long);

/*** EndHeader */

nodebug float bd2f(unsigned long x){

#asm xmemok
   ; make positive
   ld 	a,b 					; get sign
   ex 	af,af' 				; save it
   ld 	a,b
   or 	a
   jp 	p,.noneg
   ; negate here
   ld 	hl,0
   sbc 	hl,de 				; least
   ex 	de,hl
   ld 	hl,0
   sbc 	hl,bc
   ld 	b,h
   ld 	c,l
.noneg:
	xor 	a 						; clear a
	or 	b  					; check for which byte has bit
	jr 	nz,.bbit
	or 	c
	jr 	nz,.cbit
	or 	d
	jr 	nz,.dbit
	or 	e
	jp 	nz,.ebit
	; here number is zero
	jp .bdexit ; done, number zero returned as floating zero
; each test sets c with count, a with least part to shift
.bbit: jp novf,.bbit4 		; if upper 4 bits are zero
   ; here upper 4 bits has bit, shift right 8 and left 1-3
   ld 	a,e ; very least
   ld 	e,d
   ld 	d,c
   ld 	l,b
   ld 	h,0
   ld 	c,127 				; exponent
   jr 	.shiftleft 			; go shift left 1-3 and dec exp
.bbit4:
   ; shift right 1 to 4
   ld 	h,b
   ld 	l,c
   ld 	c,120 				; exponent
   xor 	a
   jr 	.shiftright 			; shift hl:de right 1 to 3
.cbit:
   jp 	novf,.cbit4 			; if upper 4 bits zero
   ; shift 0 right and left 0-3
   ld 	h,b
   ld 	l,c
   xor 	a
   ld 	c,119
   jr 	.shiftleft
.cbit4:
   ; shift left 8 and  right 1-4
   ld	 	h,c
   ld 	l,d
   ld 	d,e
   ld 	e,0
   ld 	c,112
   xor 	a
   jr .shiftright
.dbit:
   jp 	novf,.dbit4 			; if upper 4 bits zero
   ; shift left 8 and left 1-3
   ld 	l,d
   ld 	d,e
   ld 	h,0
   ld 	e,0
   xor 	a
   ld 	c,111
   jr 	.shiftleft
.dbit4:
   ; shift left 16 and right 1-4
   ex 	de,hl
   ld 	de,0
   xor 	a
   ld 	c,104
   jr 	.shiftright
.ebit:
   jp 	novf,.ebit4
   ; shift left 16 and left 1-3
   ex 	de,hl
   ld 	de,0
   xor 	a
   ld 	c,103
   jr 	.shiftleft
.ebit4:
   ; shift left 24 and right 104
   ld 	h,e
   ld 	l,0
   ld 	de,0
   ld 	c,96
   xor 	a
   jr 	.shiftright

   ; shift left up to 3 until 7,L is a 1 register is hl:de:a  count c
.shiftleft:
   bit 	7,l
   jr 	nz,.shiftleft3
   rla
   rl 	de
   adc 	hl,hl 				; one shift guaranteed
   dec 	c
   bit 	7,l
   jr 	nz,.shiftleft3
   rla
   rl 	de
   adc 	hl,hl
   dec 	c
   bit 	7,l
   jr 	nz,.shiftleft3
   rla
   rl 	de
   adc 	hl,hl
   dec 	c
   jr 	.spack
.shiftleft3:
   or 	a
   jr 	z,.shiftleft4
   set 	0,e 					; or in lost bit
.shiftleft4:
   jr 	.spack 				; go pack it up
   ;
.shiftright:
   ; shift right 1-4 hl:de till h is zero
   or 	a
   rr 	hl
   rr 	de
   rra  							; save shifted off
   inc 	h
   dec 	h 						; test h
   jr 	z,.shiftr3
   or 	a
   rr 	hl
   rr 	de
   rra
   inc 	c
   inc 	h
   dec 	h 						; test h
   jr 	z,.shiftr3
   or 	a
   rr 	hl
   rr 	de
   rra
   inc 	c
   inc 	h
   dec 	h ; test h
   jr 	z,.shiftr3
   or 	a
   rr 	hl
   rr 	de
   rra
   inc 	c
.shiftr3:

; pack number hl:de has mantissa, c has exp, af' has sign, a has bits shifted off
.spack:
	or 	a
	jr 	z,.spack1
	set 	0,e 					; or in least
.spack1:
	rl 	l  					; lose hidden bit
	ex 	af,af'
	rla 							; sign to c to c
	rr 	c
	rr 	l
	ld 	b,c 					; exp and sign
	ld 	c,l
; result in bc:de
.bdexit:
#endasm
}






/*** BeginHeader pow2 */

float pow2(float x);

/*** EndHeader   pow2 */



/* START FUNCTION DESCRIPTION ********************************************
pow2                        <MATH.LIB>

SYNTAX:       float pow2(float x);

PARAMETER1:   Floating point power to which 2 is to be raised. Error if
              x>128.9. Zero returned if x<-127.

KEYWORDS:     math

DESCRIPTION:  2 to the power of "x"
              Timing positive numbers  2400 clocks or 80 us at 30 MHz
              Timing negative numbers  3600 clocks or 120 us at 30 MHz

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/

/*
 * POW2
 *
 * Purpose:
 *              Generate 2 to the x.
 *
 */
/*
   Method: divide number into an integer and a binary fraction x=n+f
   This is done by unpacking the floating point number. The fraction must be in the
   range 0<=f<1. Pow2 of f is computed using formula 1043 from Hart & Cheney, a power
   series in x. The final result is 2^(n+f)=(2^n)*(2^f). n is the exponent of the floating
   result, 2^f is the mantissa and has a value between 1 and 2. An exception occurs if
   x is greater than 128.9.

*/

nodebug float pow2(float x) {

	auto float temp;
	auto long  int t1;
	auto int   ti,sgn;
// table contains coeficients divided by 4
	const static unsigned long int coefs[]={ 116513L, 667851L, 5196288L, 29787392L, 128972411L, 372130453L, 536870913L};

#asm xmemok
 ; if positive make error if out of range >128.9
   bit 	7,b
   jr 	nz,.perr2
   ld 	hl,4300h 			; 128.9
   or 	a
   sbc 	hl,bc 				;see if larger than 128.9
   jr 	nc,.perr2
	EXCEPTION(-ERR_RANGE)		; //note: if small negative will exception on divide by zero
   jr 	.perr3
.perr2:
 ; here is negative
   ld 	hl,0c2fdh
   or 	a
   sbc 	hl,bc
   jr 	nc,.perr3
 ; here return zero
   jp 	__DC_powretzero 			; go return a zero
.perr3:
   ld 	a,b
   rla 							; get sign to carry
   sbc 	hl,hl 				; -1 if negative, else zero
   ld 	(sp+@sp+sgn),hl 	; save sign
   res 	7,b 					; clear sign
   ld 	h,b
   ld 	l,c 					; hl is most, least in de
   adc 	hl,hl 				; rl hl
   ld 	a,h 					; exp
   scf
   rr 	l 						; set hidden bit
   ld 	h,0 					; clear h
; A has exponent 0-255

   cp 	a,135 				; if a> 134 overflow
   jp 	nc,__DC_pwrovr 			; !c if >= if too big
   cp 	a,126
   jr 	nc,.pow126 			; .ge. 126 jump - x>=.5
   ld 	h,l
   ld 	l,d
   ld 	d,e
   ld 	e,0 					; left by 8
 ; a is 125 or less
   cp 	a,103 				;
   jr 	nc,.pows0 			; if 24 or less shifts
 ; here 25 or more
   bool 	hl
   rr 	hl
   ld 	d,h
   ld 	e,h  					; zero hl
   jr 	.pows6 				; and continue
.pows0:
   sub 	a,127
   dec 	a  					; complement of number of right shifts, minimum 2
   rra 							; shift 1
   jr 	c,.pows2
   rr 	hl
   rr 	de
.pows2:
	rra
   jr 	c,.pows3
   rr 	hl
   rr 	de
   rr 	hl
   rr 	de
.pows3:
	rra
   jr 	c,.pows4
   rr 	hl
   rr 	de
   rr 	hl
   rr 	de
   rr 	hl
   rr 	de
   rr 	hl
   rr 	de
.pows4:
   rra
   jr 	c,.pows5 				; if not shift by 8
   ld 	e,d
   ld 	d,l
   ld 	l,h 					; shift by 8
   ld 	h,0
.pows5:
	rra 							; checkshift by 16
   jr 	c,.pows6
   ld 	e,l
   ld 	d,h
   ld 	hl,0
.pows6:
   ld 	a,0
   jr 	.pow2_2a 				; continue with calc
;
; here for x>=.5
.pow126:
 	sub 	a,126 				; if a>126 shift left to get integer part in h
   jr 	z,.pow2_2 			; jp if .5<=x<1.
 ; here to shift left up to 8
   ld 	b,a 					;count
   or 	a
.pow2_1:
   rl 	de
   adc 	hl,hl
   djnz 	.pow2_1 				;
; now have integer in h and fraction in l:d:e
   ld 	a,h 					; integer part in A
.pow2_2:
   ld 	h,l
   ld 	l,d
   ld 	d,e
   ld 	e,0 					; make into fraction in range .5-1.
   or 	a
   rr 	hl
   rr 	de 					; fraction in range .5 to 1. ready
.pow2_2a:
   push 	af 					; save exp
 ; bdSeries(7,coefs,x);
   ld 	b,h
   ld 	c,l
   ld 	(sp+@sp+t1+2),hl 	; most
   ex 	de,hl
   ld 	(sp+@sp+t1),hl 	; least
 c t1=bdSeries(7,coefs,t1)	; // call bdseries
 ; result in bc:de is .25* 2^x in range of .35 to .5
 c bd2f(t1); 				// ; compute
   pop 	af 					; get exp back
   add 	a,2 					; adjustment because coefs are /4
 ; exp 	in a, bc:de has floating w/o exponent
   or 	a
;	jr 	z,.pow2exit 			; if exponent zero
   ld 	h,b
   ld 	l,c
   add 	hl,hl
   rr 	b 						; save carry (sign)
   add 	a,h 					; f carry overflow
;	jr 	c,powovr 			; impossible?
   rl 	b 						; get sign
   rra
   rr 	l
   ld 	b,a
   ld 	c,l
;
.pow2exit:
   ex 	de,hl
   ld 	(sp+@sp+temp),hl 	; least
   ld 	l,c
   ld 	h,b
   ld 	(sp+@sp+temp+2),hl ; most
#endasm

	if(!sgn)return temp; else return 1./temp;
__DC_pwrovr:
	if(!sgn)
		return INF;
	else
__DC_powretzero:
		return 0.;
__DC_powretone:
	return 1.;
}


/*** BeginHeader pow10 */

float pow10(float x);

/*** EndHeader   pow10 */



/* START FUNCTION DESCRIPTION ********************************************
pow10                        <MATH.LIB>

SYNTAX:       float pow10(float x);

PARAMETER1:   Floating point power to which 10 is to be raised.

KEYWORDS:     math

DESCRIPTION:  10 to the power of "x"
              Timing positive numbers  3000 clocks or 100 us at 30 MHz
              Timing negative numbers  3900 clocks or 130 us at 30 MHz

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/

/*
   Method: 10^x  = 2^(log2(10)*x)
*/

nodebug float pow10(float x){

 return pow2(3.321928094887*x);
}



/*** BeginHeader exp */

float exp(float x);

/*** EndHeader   exp */



/* START FUNCTION DESCRIPTION ********************************************
exp                        <MATH.LIB>

SYNTAX:       float exp(float x);

PARAMETER1:   Floating point power to which e is to be raised.

KEYWORDS:     math

DESCRIPTION:  e to the power of "x"
              Timing positive numbers  3000 clocks or 100 us at 30 MHz
              Timing negative numbers  3900 clocks or 130 us at 30 MHz

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/

/*
   Method: e^x  = 2^(log2(e)*x)
*/
nodebug float exp(float x){

 return pow2(1.442695040889*x);

}





/*** BeginHeader  frMul */

unsigned long int frMul(long int X, long int A);

/*** EndHeader frMul */

// utility routine to aid in integer math
// multiplies 2 32-bit fractions and returns result
// bit 30 has value 1/2 - close to 200 clocks

nodebug unsigned long int frMul(long int X, long int A) {

#asm xmemok
	ld 	hl,(sp+@sp+X+2) 	; Xu
	ex 	de',hl
	ld 	hl,(sp+@sp+A) 		; Al
	ex 	de,hl
	ld 	bc',de 				; Al
	ld 	hl,(sp+@sp+A+2) 	; Au
	ex 	de,hl
	ld 	hl,(sp+@sp+X) 		; Xl
	ld 	b,h
	ld 	c,l
; 14+36= 50 clocks to here

; setup at top of loop
; - Au Xl
; - Xu Al
; result
;
.fr_psloop:
	ld 	a,b 					; 2 sign of Xl
	exx  							; 2
	xor 	b 						; 2 compare to sign of Al
	jp 	p,.fr_signsame  	; 7 if different/same signs

; signs are different here
; 63 to here
; signs different, see which neg
	xor 	b         			; (clear carry) 2 reverse previous xor to reveal sign of Xl
	jp 	p,.fr_Xlpos 			; 7 if alt regs have neg in bc


; - Xu Al   (hl  de  bc}
; - Au Xl   (hl' de' bc')
;
; 72 to here Xl is negative, Al is positive
.fr_Xlneg:
	mul
	exx
	mul
	add 	hl,de 				; adjust
	ex 	de,hl'
	or 	a 						; clear carry
	adc 	hl,de 				; partial sum
	jr 	.frmul_2 				; 43+72=115

; 72 to here  Xl pos, Al neg
.fr_Xlpos:
	mul 							; 12
	add 	hl,de 				;2 adjust for neg
	exx 							;2
	mul 							; 12
	ex 	de,hl' 				; 4
	or 	a 						; clear C
	adc 	hl,de  				;(C is clear) Yu*Xl+Yl*Xu
	jr 	.frmul_2 				; 43+72=115 to _2

; - Xu Al   ix=*a
; - Au Xl   iy=Xl
;
; 63 to here
.fr_signsame:
	xor 	b  					; (clear C) reverse xor find out what sign of Al is
	jp 	m,.fr_Alneg
; both positive 72 to here
	mul
	exx
	mul
	ex 	de,hl'
	adc 	hl,de 				; C is clear
	jr 	.frmul_2 				; 41+72=113

; 72 to here
.fr_Alneg:
	mul
	add 	hl,de
	exx
	mul
	add 	hl,de
	ex 	de,hl'
	or 	a 						; clear C
	adc 	hl,de 				; 40+72=112 overflow possible here
; continue

; 115 to here worst
; - Xu Al
; - Au Xl
; becomes
;
; result entering here
; (Au*Xl)u + (Xu*Al)u    --       --   ix=*a
;  Au                     Xu      --   iy=Xl
;
; 115 to here
.frmul_2:
	exx
	ld 	b,h
	ld 	c,l
	mul ; 111+18=129
; (Au*Xu)u               Xu     (Au*Xu)l
; (Au*Xl)u + (Xu*Al)u    --      --
; hl:bc has number, need to add hl'
	ld 	de',bc 			; 4
	exx
; (Au*Xl)u + (Xu*Al)u  (Au*Xu)l  --
;     (Au*Xu)u          Xu       --
; 24+115=139
	jp 	ovf,.fr_ovfpath
; no overflow path
; L1 L2 -
; U2 Xu -  need to get sign extension of L1
	ld 	a,h 					; sign in bit 7
	exx
	ex 	de,hl
	rla
	jr 	.fr_ovrpath1  		; continue

.fr_ovfpath: 					; must correct overflow
; L1 L2 -
; U2 Xu -  						; neet to get sign extension of L1
	ld 	a,h 					; sign in bit 7
	exx
	ex 	de,hl
	rla
	ccf  							; invert sign due to overflow
;
.fr_ovrpath1:
	sbc 	hl,hl 				; sign extension in hl
; U1 U2 -
; L1 L2
;
	exx
	add 	hl,de 				; lower sum
	exx
	adc 	hl,de 				; upper sum
	ex 	de,hl' 				; lower sum to de
; result in hl:de
; scale by shift
	rl 	de
	adc 	hl,hl
	ld 	b,h
	ld 	c,l 					; return in bc
;
; 187 to here worst case
#endasm

}



/*** BeginHeader log2 */

float log2(float x);

/*** EndHeader   log2 */

/* Algorithm
 From Cheney & Hart
 log(x)= z*P(z^2), z=(x-1)/(x+1)
 using table 2662 and adjusting coeficients by factor of (1./log(2)) to
 get log2.

 log2(x)= (z*4)*( (A[0]/4.) + (A[1]/4.)*z + (A[2]/4.)*z*z + (A[3]/4.)*z*z*z )
 Permitted range of x is .707<x<1.41

*/
 nodebug float log2(float fX) {

// coeficients are: 2.885390073,0.961800759,0.576584541,0.434255941
// in array A[] they are divided by 4 (2^31==1) and reverse order
	const static unsigned long int A[]=
		{233139383,309551469,516362851,1549082000};

	auto int iexp;
	auto unsigned long int z,z4;

#asm xmemok
	ld    de,0
	ld    a,0
	ld 	hl,(sp+@sp+fX) 	; least signif of fX
	scf
	ccf							; clear carry flag
	adc   hl,de
	jr    nz,.log2_LSnot_zero
	ld    a,1					; use A to indicate LSBs 0
.log2_LSnot_zero:
	ld 	hl,(sp+@sp+fX+2) 	; most signif of fX
	adc   hl,de
	jr    nz,.log2_MSnot_zero
	and   0x01
	jr    nz,.log2_dom_err	; if all zeros, dom. error
.log2_MSnot_zero:
	add	hl,hl 				; left
	jr 	nc,.domok
; here attempt to take log of negative
.log2_dom_err:
	EXCEPTION(-ERR_DOMAIN)
.domok:
	rr 	a 						; sign to a
	ld 	e,h 					; exponent to de
	ld 	d,0 					; in de
	ld 	h,d 					; zero h
	or 	a 						; clc
	rr 	l 						; mantissa hidden bit clr
	ex 	af,af'
	ld 	a,53
	cp 	l 						; if 53>=L then in range of x<1.4
	ld 	a,127 				; trial exp
	jr 	nc,.log2_1
	inc 	de 					; exponent larger
	dec 	a 						; 127->126
.log2_1:
	ld 	hl,(sp+@sp+fX+2)
	rl 	l
	rl 	h
	ld 	h,a 					; new exp
	rr		h
	rr 	l
	ld 	(sp+@sp+fX+2),hl 	; put back with new exp
	ex 	de,hl
	ld 	(sp+@sp+iexp),hl 	; put away integer exponent
#endasm
// now fX is in range .707 to 1.41 and remainder is in iexp which is 127 high
	z=f2bd((fX-1.)/(fX+1.))	; //f2bd takes 35 us at 14.7 mhz or 500 clocks
// computing entire above expression requires 126 clocks
#asm xmemok
	ld 	hl,(sp+@sp+z+2) 	; most
	ex 	de,hl
	ld 	hl,(sp+@sp+z) 		; least
	add 	hl,hl
	rl 	de
	add 	hl,hl
	rl 	de  					; x4
	ld 	(sp+@sp+z4),hl 	; least
	ex 	de,hl
	ld 	(sp+@sp+z4+2),hl 	; most
#endasm

//z=
	frMul(z4, bdSeries( 4,A,frMul(z,z) )  ); // 111 us at 14.7 mhz- 1630 clocks
// add the result of above operation to (iexp-1)
#asm xmemok
	ld 	l,c 					; move result to hl:de
	ld 	h,b
;
	ld 	a,e  					; shift fraction
	ex 	af,af' 				; least part of fraction in a'
	ld 	e,d
	ld 	d,l
	ld 	l,h
	rl 	h
	sbc 	a,a 					; set bits of A to match sign of fraction
	ld 	h,a 					; sign extension - now have hl:de as signed fraction shifted 8 right
	ex 	af,af' 				; sign extension in a'
	exx
	ld 	hl,(sp+@sp+iexp) 	; exponent
	rr 	hl
	ld 	h,l
	ld 	l,0
	rr 	l  					; put iexp in top 9 bits
	ld 	de,03f80h 			; 127 in top 9 bits
	or 	a
	sbc 	hl,de 				; iexp-127 -can be 0x80 which must be treated as +128
	or 	a
	ex 	de,hl
	ld 	bc',de
	exx
	add 	hl,bc 				; add integer part
	ld 	b,h 					; now set up bc:de
	ld 	c,l
	call 	bd2f 					; convert, return result in bc:de, add 7 to exponent
	ld 	hl,0400h 			; 8
	add 	hl,bc
	ld 	b,h
	ld 	c,l
#endasm



//return (iexp-127)+bd2f(z); //result (z is between -.5 and +.5 approx)
// return 75 us at 14.7 MHz or 1100 clocks
// bd2f is 56 us at 14.7 MHz or 800 clocks
}


/*** BeginHeader log */

float log(float x);

/*** EndHeader   log */



/* START FUNCTION DESCRIPTION ********************************************
log                        <MATH.LIB>

SYNTAX:       float log(float x);

PARAMETER1:   Floating number to take natural log of

KEYWORDS:     math

DESCRIPTION:  exp(log(x))==x
              Timing positive numbers  4500 clocks or 135 us at 30 MHz


RETURN VALUE: See description.
END DESCRIPTION **********************************************************/

// computes log base e from log base 2 of x

nodebug float log(float x){

  return log2(x)*0.693147180560;

}


/*** BeginHeader log10 */

float log10(float x);

/*** EndHeader   log10 */



/* START FUNCTION DESCRIPTION ********************************************
log10                       <MATH.LIB>

SYNTAX:       float log10(float x);

PARAMETER1:   Number to take log base 10 of

KEYWORDS:     math

DESCRIPTION:  10^log10(x) == x
              Timing positive numbers  4500 clocks or 135 us at 30 MHz


RETURN VALUE: See description.
END DESCRIPTION **********************************************************/

// computes log base 10 from log base 2

nodebug float log10(float x) {

	return log2(x)*0.301029995664;
}




/*** BeginHeader sin */

xmem float sin(float x);

/*** EndHeader   sin */


/* START FUNCTION DESCRIPTION ********************************************
sin                          <MATH.LIB>

SYNTAX:       float sin( float fX)

DESCRIPTION:  The sine function in fixed-point math using the floating
              point parameter 'fX'. 'fX' is not restricted. However, best
              performance is obtained by restricting 'fX' to [0,2pi], or
              [0,pi/2]. Timing: Approx 3600 clocks or 120 us on 30 MHz
              system.

RETURN VALUE: The floating point result.
END DESCRIPTION **********************************************************/

nodebug xmem float sin( float fX)
{
const static unsigned long bd_sine0coefP2[] = {
   0x0B8F, 0xfffcbfcd, 0x00888888, 0xf5555550, 0x40000000};

const static unsigned long bd_sine2coefP2[] = {
	0xFFFFFED8,0x00006806, 0xffe93e94, 0x02aaaaac, 0xe0000000, 0x40000000};
	auto int n, sign;
	auto unsigned long bdsine,bdsine2;
	auto float sine,sine2;
	auto union {float x; int nx[2]; } un;

//	if(fX<0) {
//		sign=1;
//		fX=-fX;
//	} else {
//		sign=0;
//	}



#asm
	ld 	hl,(sp+@sp+fX+2) 		; most
	ex 	de,hl
	rl 	de
	sbc 	hl,hl 					; -1 if carry on
	bool 	hl
	ld 	(sp+@sp+sign),hl 		; set sign
	rr 	de
	ex 	de,hl
	ld 	(sp+@sp+fX+2),hl 		; restore with sign zero
#endasm

	un.x=fX; // place arg in union for access to parts

__DC_beginswitch:

	if(un.nx[1]> 0x404A)
	{  // if greater than 3.16

		un.x=fX=fX-3.14159265; sign=!sign;
 	}

	if(un.nx[1]<0x3F49)
	{   // less than pi/4=.78
  		if(un.nx[1] < 0x3c80) {
  			sine=(fX-.1666666666*fX*fX*fX);
  			goto __DC_sexit;
  		}  // for small angles

   // 0 to .4 .707 radian
__DC_c2a:
  	   bdsine=f2bd(fX);
	   bdsine2=frMul(bdSeries(5,bd_sine0coefP2, frMul(bdsine,bdsine) ),bdsine);
	   sine=fx2(bd2f(bdsine2));
      goto __DC_sexit;
	}

	else if(un.nx[1]<0x4016)
	{																						// less than (3/4) pi (2.35) greater then pi/4

		fX=fX-1.570796325;  															// fx-pi/2
  		bdsine = f2bd( fX );															// Convert "frac" from float to binary decimal
		bdsine = bdSeries( 6, bd_sine2coefP2,frMul(bdsine, bdsine));	// Evaluate the sine
		sine = fx2( bd2f( bdsine ) );												// Convert from binary decimal to float
      goto __DC_sexit;
   }

	else if(un.nx[1]<0x4055)
	{  																					// less than 3.14159+0.2

      fX=3.14159265-fX; goto __DC_c2a;
  	}

	else
	{

		fX = fX * 0.1591549430919;													//  * 1/(2*pi) Scale to 0 < fX < 2pi (~900 clocks)
		fX = modf( fX, &n );
		un.x=fX = 6.2831853071796 * fX; 											// *2*pi
		goto __DC_beginswitch;

  }


__DC_sexit:																					// 50 < clocks < 1400
	if( sign )
	{
		return -sine;
	}
	else
	{
		return sine;
	}
}



/*** BeginHeader atan */

float atan(float x);

/*** EndHeader   atan */



/* START FUNCTION DESCRIPTION ********************************************
atan                         <MATH.LIB>

SYNTAX:       float atan(float x);

PARAMETER1:   Floating point input for arctangent computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arctangent of real FLOAT value x. x is assumed
              between -INF and +INF.
              Timing: for |x| < 1. 3800 clocks 125 us at 30 MHz
                      for |x| > 1. 5200 clocks 175 us at 30 MHz

RETURN VALUE: The arctangent of the argument.
END DESCRIPTION **********************************************************/

  // compute arc tangent of x
// Hart and Cheney formula 4992 for arctan over the interval [0,1]
// arctan(x)= xP(x*x)
// range reduction for x>1 by using: arctan(x) = pi/2 - arctan (1/x)
// and arctan(-x)=-arctan(x)

nodebug float atan(float x) {

// coeficients for power series are stored as 1/2 actual values as integer fractions

/* coefs a0.. a8
  0.999999985
 -0.333330733
  0.199926194
 -0.142036445
  0.10640934
 -0.075042945
  0.042691519
 -0.0160686289604
  0.00284989
*/

const static unsigned long int coef[]={3060046,-17253559,45839670,-80576749,114256159,-152510471,214669116,-357911150,1073741808};

auto sgn,adj; //logical variables
auto float temp;
auto unsigned long ti;

//sgn=adj=0;
#asm xmemok
	bool 	hl
	rr 	hl 					; hl==0
	ld 	(sp+@sp+sgn),hl 	; zero
	ld 	(sp+@sp+adj),hl 	; zero
#endasm

//if(x<0.) {x=-x; sgn=1;}
//if(x>1.) {x=1./x; adj=1;}
//if(x==1.) return 0.785398163; // pi/4

// if(x<.02) if(sgn) return -x*(1-.33333333*x*x); else return x*(1-.33333333*x*x);

#asm xmemok
	ld 	hl,(sp+@sp+x+2) 	; most of x
	add 	hl,hl
	jr 	nc,.atan_2
	ccf
	ex 	de,hl
	ld 	hl,8000h
	ld 	(sp+@sp+sgn),hl   ; sgn=8000
	ex 	de,hl
.atan_2:
	rr 	hl                ; restore hl w/o sign
	ld 	b,h
	ld 	c,l               ; most to bc
	ld 	(sp+@sp+x+2),hl   ; most, with positive sign
; check for very small
	ld 	de',bc            ; most
	exx
	ld 	hl,03d00h         ; 1/32
	or 	a
	sbc 	hl,de             ; 1/32-value
	jp 	nc,__DC_atansmall      ; on very small exit
	exx
; 1. in floating is 3f800000
	ld 	de,03f80h
	or 	a
	sbc 	hl,de             ; nc means >=
	jr 	z,.__atan_ueq
	jr 	c,.atan_Lt1        ; if x < 1.
	jr 	.__atan_recip        ; if x > 1.
.__atan_ueq:
; upper parts equal, if lower 0 is exactly 1.
	ld 	hl,(sp+@sp+x)     ; least part
	bool 	hl
	jr   nz,.__atan_notpiovr4
   ld   hl,(sp+@sp+sgn)
   bool hl
   rr   hl
   jp   nc,__DC_atan_retpiovr4
   jp   __DC_atan_negpiovr4
.__atan_notpiovr4:
; here take 1/x
.__atan_recip:
c x=1./x;
	ld 	hl,1
	ld 	(sp+@sp+adj),hl 	; set adj=1;
;
	.atan_Lt1: 					; here x is less than 1
#endasm
	ti=f2bd(x); 																	// get integer representation

	temp = fx2( bd2f(frMul(ti, bdSeries(9,coef,frMul(ti,ti)))));  	// 2*x*P(x*x)

	if(adj)
	{
		temp = 1.570796327 - temp; 											// pi/2-arctan(1/x)
	}

// if(sgn) temp=-temp;
__DC_atanexit:
#asm xmemok
	ld 	iy,@sp
	add 	iy,sp
	ld 	a,(iy+sgn+1) 		; 80 or 00
	xor 	a,(iy+temp+3) 		; sign of floating number
	ld 	(iy+temp+3),a
#endasm


	return temp;
__DC_atan_retpiovr4:
	return 0.785398163;
__DC_atan_negpiovr4:
	return -0.785398163;
__DC_atansmall:
	temp=x*(1.-.33333333333*x*x);
	goto __DC_atanexit;
}





/*** BeginHeader asin */

float asin(float x);

/*** EndHeader   asin */

/* START FUNCTION DESCRIPTION ********************************************
asin                         <MATH.LIB>

SYNTAX:       float asin(float x);

PARAMETER1:   Floating point input for arcsine computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arcsine of real FLOAT value x. x is assumed
              between -1 and +1.

RETURN VALUE: The arcsine of the argument.
END DESCRIPTION **********************************************************/
nodebug float asin(float x)
{
	auto float y;
   static float sqrt(), atan();

	if ((y = x * x) > ONE)
	{
#asm
		EXCEPTION(-ERR_DOMAIN)
#endasm
		return ZERO;
	}

	if (x == - ONE)
	{
		return - PIbyTWO;
	}

	if (y == ONE)
	{
		return PIbyTWO;
	}

	return (atan(x / sqrt(ONE - y)));
}


/*** BeginHeader */

#ifndef __MATH_LIB
#define __MATH_LIB

/*** EndHeader */

/*** BeginHeader abs */

root int abs(int val);

/*** EndHeader   abs */

/*
 * ABS
 *
 * Purpose:
 *              Compute the absolute value of an integer arg
 * Returns:
 *              arg     if arg >= 0
 *             -arg     if arg < 0
 * Notes:
 *              o This may be in the main library, but it is
 *                repeated here so that the math package gets
 *                a completely tested version that is not a
 *                a macro. This function must be recursive and
 *                ROMABLE.
 *              o Portable code below. Library uses optimized
 *                assembler (provided below).
 *
 *
 *    int abs(x)
 *    int x;
 *    {
 *            return ( (x >= 0) ? x : -x);
 *    }
 */

/* START FUNCTION DESCRIPTION ********************************************
abs                          <MATH.LIB>

SYNTAX:       int abs(int x);

PARAMETER1:   Integer for which the absolute value is to be returned.

KEYWORDS:     math

DESCRIPTION:  Computes the absolute value of an integer arg.

RETURN VALUE: Absolute value of the argument.
END DESCRIPTION **********************************************************/

#asm  nodebug fast

abs::
   ld 	a,h
   or 	a
   ret 	p                   ; if already positive
   ex 	de,hl
   ld 	hl,0
   sbc 	hl,de
   ret

#endasm

/*** BeginHeader acos */

float acos(float x);

/*** EndHeader   acos */

/*
 * ACOS
 *
 * Purpose:
 *              Compute the arccosine of real FLOAT value x
 *              The value x is assumed between -1 and 1
 * Returns:
 *              0       Range error, set errno = EDOM
 *              angle   No error, answer in radians 0..PI
 * Method:
 *              acos(x) = PI/2 - asin(x)
 */

/* START FUNCTION DESCRIPTION ********************************************
acos                         <MATH.LIB>

SYNTAX:       float acos(float x);

PARAMETER1:   Floating point input for arccosine computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arccosine of real FLOAT value x.  x is assumed
              between -1 and 1.

RETURN VALUE: Arccosine of the argument.
END DESCRIPTION **********************************************************/

nodebug float acos(float x)
{
	auto float y;
	static float sqrt(), atan();

	if ((y = x * x) > ONE)
	{
#asm
		EXCEPTION(-ERR_DOMAIN)
#endasm
		return ZERO;
	}
	if (x == - ONE)
		return PI;
	if (y == ONE)
		return ZERO;
	return (PIbyTWO - atan(x / sqrt(ONE - y)));
}

/*** BeginHeader acot */

float acot(float x);

/*** EndHeader   acot */

/*
 * ACOT
 *
 * Purpose:
 *              Compute the arccotangent of real FLOAT value x
 *              The value x is assumed between -INF and +INF
 * Returns:
 *              angle   answer in radians 0 .. PI approx
 * Method:
 *              acot(x) = PI/2 + atan(-x)
 */

/* START FUNCTION DESCRIPTION ********************************************
acot                         <MATH.LIB>

SYNTAX:       float acot(float x);

PARAMETER1:   Floating point input for arccotangent computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arccotangent of real FLOAT value x.  x is
              assumed between -INF and +INF.

RETURN VALUE: Arccotangent of the argument.
END DESCRIPTION **********************************************************/
nodebug float acot(float x)
{
	float atan();

	return (PIbyTWO + atan(- x));
}

/*** BeginHeader acsc */

float acsc(float x);

/*** EndHeader   acsc */

/*
 * ACSC
 *
 * Purpose:
 *              Compute the arccosecant of real FLOAT value x
 *              The value x is assumed between -INF and +INF
 * Returns:
 *              angle   answer in radians -PI/2 .. PI/2 approx
 * Method:
 *              acsc(x) = asec(x/sqrt(x*x-1));
 */

/* START FUNCTION DESCRIPTION ********************************************
acsc                         <MATH.LIB>

SYNTAX:       float acsc(float x);

PARAMETER1:   Floating point input for arccosecant computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arccosecant of real FLOAT value x. x is assumed
              between -INF and +INF.

RETURN VALUE: The Arccosecant of the argument.
END DESCRIPTION **********************************************************/
nodebug float acsc(float x)
{
	auto float y;
	static float sqrt(), asec();

	if ((y = x * x) < ONE)
	{
#asm
		EXCEPTION(-ERR_DOMAIN)
#endasm
		return ZERO;
	}
	if (y == ONE)
	{
		return ((x >= ZERO) ? PIbyTWO : - PIbyTWO);
	}
	return (asin(1.0 / x));
}

/*** BeginHeader asec */

float asec(float x);

/*** EndHeader   asec */

/*
 * ASEC
 *
 * Purpose:
 *              Compute the arcsecant of real FLOAT value x
 *              The value x is assumed between -INF and +INF
 * Returns:
 *              angle   answer in radians 0 .. PI approx
 *              0.0     errno = ERR_DOMAIN, on range error
 * Method:
 *              asec(x) = atan(sqrt(x*x - 1)) - (x >= 0 ? 0 : PI);
 */

/* START FUNCTION DESCRIPTION ********************************************
asec                         <MATH.LIB>

SYNTAX:       float asec(float x);

PARAMETER1:   Floating point input for arcsecant computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arcsecant of real FLOAT value x. x is assumed
              between -INF and +INF.

RETURN VALUE: The Arcsecant of the argument.
END DESCRIPTION **********************************************************/
nodebug float asec(float x)
{
	auto float y;
	static float atan(), sqrt();

	if ((y = x * x) < ONE)
	{
#asm
		EXCEPTION(-ERR_DOMAIN)
#endasm
		return ZERO;
	}
	return (PIbyTWO - asin(1.0 / x));
}




/*** BeginHeader atan2 */

float atan2(float y, float x);

/*** EndHeader   atan2 */

/*
 * ATAN2
 *
 * Purpose:
 *              Compute the arctangent of real float value y/x
 *              to find the angle in radians between the x-axis
 *              and the ray through (0,0) and (x,y).
 * Returns:
 *              0       Error x=y=0, errno = ERR_DOMAIN
 *              angle   answer in radians -PI .. PI approx
 *              PI/2    x=0, y>0
 *             -PI/2    x=0, y<0
 *              0       x>0, y=0
 *              PI      x<0, y=0
 *
 *  Recoded 10-Sept-88 after math test failure.
 *  There were problems! The results in Q-II and Q-III were wrong.
 */
/* START FUNCTION DESCRIPTION ********************************************
atan2                        <MATH.LIB>

SYNTAX:       float atan2(float y, float x);

PARAMETER1:   y coordinate of point (x,y).

PARAMETER2:   x coordinate of point (x,y).

KEYWORDS:     math

DESCRIPTION:  Computes the arctangent of real FLOAT value y/x to find the
              angle in radians between the x-axis and the ray through (0,0)
              and (x,y).

RETURN VALUE: Arctangent of y/x.
END DESCRIPTION **********************************************************/
nodebug float atan2(y, x)
float y, x;
{
	auto FLOAT z;
	static FLOAT atan();

	if (x == ZERO)
	{
		if (y == ZERO)
		{
#asm
		EXCEPTION(-ERR_DOMAIN)
#endasm
			return ZERO;
		}
		return ((y > ZERO) ? PIbyTWO : - PIbyTWO);
	}
	if (y == ZERO)
		return ((x > ZERO) ? ZERO : - PI);
	z = atan(y / x);
	if (x > ZERO)
		return z;
	return (z + ((y > ZERO) ? PI : - PI));
}

/*** BeginHeader ceil */

float ceil(float x);

/*** EndHeader   ceil */

/*
 * CEIL
 *
 * Purpose:
 *              Compute FLOAT ceiling, the smallest integer greater
 *              than or equal to the given number.
 * Argument:
 *              ceil(f)
 *              f               FLOAT number
 * Returns:
 *              g               Where g is a whole number, signed,
 *                              with f <= g and g-1 < f.
 * Notes:
 *              o No overflow check.
 *              o No auto conversion to FLOAT.
 */
/* START FUNCTION DESCRIPTION ********************************************
ceil                         <MATH.LIB>

SYNTAX:       float ceil(float x);

PARAMETER1:   Floating point input for ceiling computation.

KEYWORDS:     math

DESCRIPTION:  Computes the smallest integer greater than or equal to the
              given number.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug FLOAT ceil(f)
FLOAT f;
{
	auto long i;

	i = (long) f;
	if ((FLOAT) i < f)
		++i;
	return ((FLOAT) i);
}

/*** BeginHeader cos */

float cos(float x);

/*** EndHeader   cos */

/*
 * COS
 *
 * Purpose:
 *              Compute the cosine of real float value x
 *              The value x is assumed in radians (not degrees)
 *              Use deg() and rad() for conversions.
 * Returns:
 *              number          answer between -1 and 1
 *                              No error checking for large x
 * Method:
 *              cos(x) = sin(x + PI/2)
 */
/* START FUNCTION DESCRIPTION ********************************************
cos                          <MATH.LIB>

SYNTAX:       float cos(float x);

PARAMETER1:   Floating point input for cosine computation.

KEYWORDS:     math

DESCRIPTION:  Computes the cosine of real float value x (radians).

RETURN VALUE: Cosine of the argument.
END DESCRIPTION **********************************************************/
nodebug float cos(float x)
{
	static float sin();

	return (sin(x + PIbyTWO));
}

/*** BeginHeader cosh */

float cosh(float x);

/*** EndHeader   cosh */

/*
 * COSH
 *
 * Purpose:
 *              Compute the hyperbolic cosine of real FLOAT value x
 * Returns:
 *              number          x in range
 *              INF             x too large positive
 *             -INF             x too large negative
 *                              errno = -ERR_RANGE returned to flag error
 * Method:
 *              cosh(x) = (exp(x) + exp(-x))/2.0
 * Notes:
 *              o The value of EXPLARGE was found by solving the
 *                equation exp(x) = 1.0e39.
 */

/* START FUNCTION DESCRIPTION ********************************************
cosh                         <MATH.LIB>

SYNTAX:       float cosh(float x);

PARAMETER1:   Floating point input for hyperbolic cosine computation.

KEYWORDS:     math

DESCRIPTION:  Computes the hyperbolic cosine of real FLOAT value x.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug FLOAT cosh(float x)
{
	FLOAT exp(), fabs();

	if (fabs(x) > EXPLARGE)
	{
#asm
		EXCEPTION(-ERR_RANGE)
#endasm
		return INF;
	}
	return (exp(x) + exp(- x)) / 2.0;
}

/*** BeginHeader deg */

float deg(float x);

/*** EndHeader   deg */

/*
 * DEG
 *
 * Purpose:
 *              Changes FLOAT radians x to degrees
 * Returns:
 *              angle in degrees ( a FLOAT)
 * Method:
 *              angle = (180.0/PI)*x;
 */

/* START FUNCTION DESCRIPTION ********************************************
deg                          <MATH.LIB>

SYNTAX:       float deg(float x);

PARAMETER1:   Floating point input in radians.

KEYWORDS:     convert

DESCRIPTION:  Changes FLOAT radians x to degrees.

RETURN VALUE: Angle in degrees (a FLOAT).
END DESCRIPTION **********************************************************/
nodebug float deg(float x)
{
	return (x * (IPIby180));
}



/*** BeginHeader fabs */

root float fabs(float x);

/*** EndHeader   fabs */

/*
 * FABS
 *
 * Purpose:
 *              Compute the FLOAT absolute value of FLOAT x
 * Returns:
 *              arg     if arg >= 0
 *             -arg     if arg < 0
 */

/* START FUNCTION DESCRIPTION ********************************************
fabs                         <MATH.LIB>

SYNTAX:       float fabs(float x);

PARAMETER1:   Floating point value for which absolute value is to be returned.

KEYWORDS:     math

DESCRIPTION:  Computes the FLOAT absolute value of FLOAT x.

RETURN VALUE:  x, if x >= 0; else -x.
END DESCRIPTION **********************************************************/
#asm  nodebug fast

fabs::
	   res      7,b                  ; clear sign bit
	   ret

#endasm

/*** BeginHeader floor */

float floor(float x);

/*** EndHeader   floor */

/*
 * FLOOR
 *
 * Purpose:
 *              Compute FLOAT floor, the largest integer less
 *              than or equal to the given number.
 * Argument:
 *              floor(f)
 *              f               FLOAT number
 * Returns:
 *              g               Where g is a whole number, signed,
 *                              with g <= f and f < g+1.
 * Notes:
 *              o No overflow check.
 *              o No auto conversion to FLOAT.
 */

/* START FUNCTION DESCRIPTION ********************************************
floor                        <MATH.LIB>

SYNTAX:       float floor(float x);

PARAMETER1:   Floating point input for floor computation.

KEYWORDS:     math

DESCRIPTION:  Computes the largest integer less than or equal to the given
              number.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug
FLOAT floor(float f)
{
	auto long i;

	i = (long) f;
	if (f < 0.0)
	{
		if (f != (float)i)
		{
			i--;
		}
	}
	return ( (FLOAT)i );
}

/*** BeginHeader fmod */

float fmod(float x, float y);

/*** EndHeader   fmod */

/*
 * FMOD
 *
 * Purpose:
 *              Solves for FLOAT f in the equation x = k*y + f
 *              such that x*f >= 0, fabs(f) < fabs(y), for some
 *              long integer k.
 * Returns:
 *              f       as computed above, a remainder (not a modulus)
 * Notes:
 *              o This works because the float library converts
 *                to integer by truncation. If it didn't, then
 *                it would be much more difficult to write.
 */

/* START FUNCTION DESCRIPTION ********************************************
fmod                         <MATH.LIB>

SYNTAX:       float fmod(float x, float y);

PARAMETER1:   Floating point numerator of ratio for modulo computation.

PARAMETER2:   Floating point denominator of ratio for modulo computation.

KEYWORDS:     math

DESCRIPTION:  Floating point modulo math.

RETURN VALUE: Returns the remainder of x/y.
END DESCRIPTION **********************************************************/
nodebug FLOAT fmod(float x, float y)
{
	auto long k;
   auto float d;

	if (y == ZERO)
	{
#asm
		EXCEPTION(-ERR_RANGE)
#endasm
		return ZERO;
	}
	k = (long)(x / y); //< Note: In some cases this may be zero.
   d = x - (FLOAT)k * y;
   return d >= y ? d - y : d;
}

/*** BeginHeader frexp */

float frexp(float x, int *n);

union FC4
{
	float f;
	char c[4];
};

/*** EndHeader   frexp */

/*
 * FREXP
 *
 * Purpose:
 *              Splits x into x = f*(radix**n) where n is an integer
 *              and 0.5 <= f < 1.0. The value of radix is 2 for this
 *              library.
 * Returns:
 *              f               the fraction, a FLOAT
 *              n               via *nptr = n;
 * Notes:
 *              o The float library is radix 2.
 *              o There is always a better way to do this calculation
 *                based on knowledge of the float representation.
 *              o The exponent in this float library is given by
 *                r = ((int)255 & (int)x.c[3]) - (int)128.
 */

/* START FUNCTION DESCRIPTION ********************************************
frexp                        <MATH.LIB>

SYNTAX:       float frexp(float x, int *n);

PARAMETER1:   Floating point input for return as mantissa and exponent.

PARAMETER2:   Address of an integer where returned exponent will be placed.

KEYWORDS:     math

DESCRIPTION:  Splits x into x = f*(radix**n), where n is an integer and
              0.5 <= f < 1.0.  Radix = 2 for this library.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug FLOAT frexp(float f, int *nptr)
{
	auto union FC4 *x;

	x = (union FC4 *) &f;
	if (x->f == 0.0)
	{
		*nptr = 0;
		return (0.0);
	}
	*nptr = ((0x7f & (int) x->c[3]) << 1) +
	((0x80 & (int) x->c[2]) >> 7) - 126;// exponent

	x->c[3] &= 0xbf;
	x->c[3] |= 0x3f;
	x->c[2] |= 0x80;

	return (x->f * 0.5);
}

/*** BeginHeader labs */

long labs(long x);

/*** EndHeader   labs */

/*
 * LABS
 *
 * Purpose:
 *              Compute the long integer absolute value of long integer x
 * Returns:
 *              arg     if arg >= 0
 *             -arg     if arg < 0
 */

/* START FUNCTION DESCRIPTION ********************************************
labs                         <MATH.LIB>

SYNTAX:       long labs(long x);

PARAMETER1:   Long integer for which the absolute value is to be returned.

KEYWORDS:     math

DESCRIPTION:  Computes the long integer absolute value of long integer x.

RETURN VALUE: x, if x >= 0; else -x.
END DESCRIPTION **********************************************************/
nodebug long labs(long x)
{
	return (x >= 0 ? x : - x);
}

/*** BeginHeader ldexp */

float ldexp(float x, int n);

/*** EndHeader   ldexp */

/*
 * LDEXP
 *
 * Purpose:
 *              computes  x*(radix**n) where n is an integer
 *              and typically 0.5 <= x < 1.0
 * Returns:
 *              product         a FLOAT
 * Notes:
 *              o The float exponent in this library is
 *                r = ((int)255 & (int)x.c[3]) - (int)128.
 *              o A portable version of ldexp() that can be used
 *                to check an implementation appears below.
 *
 *      FLOAT ldexp(x,n)
 *      FLOAT x;
 *      int n;
 *      {
 *      int i;
 *      FLOAT f;
 *              i = n; f = x;
 *              if(i < 0) while(i++ < 0) f = f/2.0;
 *              else      while(i-- > 0) f += f;
 *              return f;
 *      }
 */

/* START FUNCTION DESCRIPTION ********************************************
ldexp                        <MATH.LIB>

SYNTAX:       float ldexp(float x, int n);

KEYWORDS:     math

PARAMETER1:   Floating point mantissa for ldexp computation.

PARAMETER2:   Integer power of 2 exponent for ldexp computation.

DESCRIPTION:  Computes x*(radix**n), where n is an integer and
              0.5 <= x < 1.0.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug FLOAT ldexp(float f, int n)
{
	auto int r;
	auto union FC4 *x;

	x = (union FC4 *) &f;

	r = ((0x7f & (int) x->c[3]) << 1) +
	((0x80 & (int) x->c[2]) >> 7) + n;// exponent

	x->c[3] = (x->c[3] & 0x80) | (r >> 1);
	x->c[2] |= (r & 0x01 ? 0x80 : 0);

	return x->f;
}




/*** BeginHeader modf */

float modf(float x, int *n);

/*** EndHeader   modf */

/*
 * MODF
 *
 * Purpose:
 *              Splits FLOAT x = f + n, where n is an integer
 *              and FLOAT f satisfies fabs(f) < 1.0
 * Returns:
 *              f               the fraction, a FLOAT remainder
 *              n               via *nptr = n;
 */

/* START FUNCTION DESCRIPTION ********************************************
modf                         <MATH.LIB>

SYNTAX:        float modf(float x, int *n);

PARAMETER1:    Floating point input for modf computation.

PARAMETER2:    Address of an integer where integer part of return will be
               placed.

KEYWORDS:      math

DESCRIPTION:   Splits x into f + n, where n is an integer and FLOAT f
               satisfies fabs(f) < 1.0.

RETURN VALUE:	See description.
END DESCRIPTION **********************************************************/
nodebug FLOAT modf(FLOAT x, int *nptr)
{
	static register int i;
	auto FLOAT f;
	static FLOAT fabs();

	i = (int)x;
	f = x - (FLOAT)i;
	if (fabs(f) < ONE)
	{
		*nptr = i;
		return f;
	}
#asm
		EXCEPTION(-ERR_RANGE)
#endasm
	return ZERO;
}

/*** BeginHeader poly */

float poly(float x, int n, float c[]);

/*** EndHeader   poly */

/*
 * POLY
 *
 * Purpose:
 *              Compute polynomial value by Horner's method.
 *
 *      Horner's method for polynomial evaluation
 *
 * Example: Given p[2] = 3, p[1] = 4, p[0] = 6,
 *          then 3*(x**2) + 4*x + 6 = x( x(3) + 4) + 6 =
 *               x( x(p[2]) + p[1]) + p[0]
 *
 */

/* START FUNCTION DESCRIPTION ********************************************
poly                         <MATH.LIB>

SYNTAX:       float poly(float x, int n, float c[]);

PARAMETER1:   Floating point variable for polynomial evaluation.

PARAMETER2:   Degree of polynomial (P(x) = 7.7*x^4 + 5*x^2 + 3.3, n = 4)

PARAMETER3:   Ascending array of coefficients ({3.3, 0, 5, 0, 7.7} for P(x))

KEYWORDS:     math

DESCRIPTION:  Computes polynomial value by Horner's method.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug float poly(float x, int n, float p[])
{
	auto float value;

	value = p[n];
	while (n)
		value = x * value + p[ --n];
	return (value);
}



/*** BeginHeader rad */

float rad(float x);

/*** EndHeader   rad */

/*
 * RAD
 *
 * Purpose:
 *              Changes FLOAT x degrees to radians
 * Returns:
 *              angle in radians (a FLOAT)
 * Method:
 *              angle = (PI/180.0)*x;
 */

/* START FUNCTION DESCRIPTION ********************************************
rad                          <MATH.LIB>

SYNTAX:       float rad(float x);

PARAMETER1:   Floating point input in degrees.

KEYWORDS:     convert

DESCRIPTION:  Convert degrees (360 for one rotation) to radians (2pi
              for a rotation).

RETURN VALUE: The radians equivalent to the passed in degree.
END DESCRIPTION **********************************************************/
nodebug FLOAT rad(FLOAT x)
{
	return (x * (PIby180));
}




/*** BeginHeader sinh */

float sinh(float x);

/*** EndHeader   sinh */

/*
 * SINH
 *
 * Purpose:
 *              Compute the hyperbolic sine of real FLOAT value x
 * Returns:
 *              number          x in range
 *              INF             x too large positive
 *             -INF             x too large negative
 *                              errno = -ERR_RANGE returned to flag error
 * Method:
 *              sinh(x) = (exp(x) - exp(-x))/2.0
 * Notes:
 *              o The value of EXPLARGE was found by solving the
 *                equation exp(x) = 1.0e39.
 */

/* START FUNCTION DESCRIPTION ********************************************
sinh                         <MATH.LIB>

SYNTAX:       float sinh(float x);

PARAMETER1:   Floating point input for hyperbolic sin computation.

KEYWORDS:     math

DESCRIPTION:  Hyperbolic sine of x.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug FLOAT sinh(float x)
{
	FLOAT exp();

	if (x > EXPLARGE)
	{
#asm
		EXCEPTION(-ERR_RANGE)
#endasm
		return INF;
	}
	if (x < - EXPLARGE)
	{
#asm
		EXCEPTION(-ERR_RANGE)
#endasm
		return - INF;
	}
	return (exp(x) - exp(- x)) / 2.0;
}

/*** BeginHeader sqrt */

root float sqrt(float x);

/*** EndHeader   sqrt */

/* START FUNCTION DESCRIPTION ********************************************
sqrt                         <MATH.LIB>

SYNTAX:       float sqrt(float x);

PARAMETER1:   Floating point input for square root computation.

KEYWORDS:     math

DESCRIPTION:  Square root of x.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
// useix nodebug float sqrt(float y);

const char sqrt_table[] = {
   127 , 125 ,	123 ,	122 ,	120 ,	118 ,	117 ,	115,
   114 , 112 ,	111 ,	110 ,	109 ,	107 ,	106 ,	105,
   104 , 103 ,	102 ,	101 ,	100 ,	99	 ,	98	 ,	97,
   96  , 95  ,	95  ,	94	 ,	93	 ,	92	 ,	92	 ,	91,
   90  , 88  ,	87  ,	86	 ,	85	 ,	84	 ,	83	 ,	81,
   80  , 79  ,	79  ,	78	 ,	77	 ,	76	 ,	75	 ,	74,
   74  , 73  ,	72  ,	71	 ,	71	 ,	70	 ,	69	 ,	69,
   68  , 68  ,	67  ,	66	 ,	66	 ,	65	 ,	65	 ,	64 };

#asm nodebug

;	0x7f, 0x7d, 0x7b, 0x79, 0x77, 0x76, 0x74, 0x73 ; about 1/sqrt(x)
;	0x71, 0x70, 0x6f, 0x6d, 0x6c, 0x6b, 0x6a, 0x69
;	0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x62, 0x61
;	0x60, 0x5f, 0x5e, 0x5d, 0x5d, 0x5c, 0x5b, 0x5a
;	0x59, 0x58, 0x57, 0x55, 0x54, 0x53, 0x52, 0x51
;	0x50, 0x4f, 0x4e, 0x4d, 0x4c, 0x4b, 0x4b, 0x4a
;	0x49, 0x48, 0x48, 0x47, 0x46, 0x45, 0x45, 0x44
;	0x44, 0x43, 0x42, 0x42, 0x41, 0x41, 0x40, 0x40

;
; sqrt
;
;	sqrt(x) can be iteratively estimated by newton iterations
;  based on the following:
;
;	estimate 1/sqrt(x) by:
;	w[i+1]=w[i]*1/2*(3-w[i]*w[i]*x) where w[0] approx 1/sqrt(x)
;
;  sqrt(x) = 1/sqrt(x) * x
;
;  w[0] is found by looking in a table that uses the lsb of the
;	exponent and the 5 msbs of the mantissa (excluding implicit bit).
;
; worst case = 880 clocks
;

.__fsqzero:					;    zero
	xor	a					; 2
	ld		b,a				; 2
	ld		c,a				; 2
	ld		d,a				; 2
	ld		e,a				; 2
	pop	ix
	ret						; 8

.__fsdivneg:					;    negative number return NAN
	pop	ix
	ld		a,h				;    negative number
	or		a
	jr		nz,.__fsdivneg2

	ld		bc,0x8000		; 	  return -0.0 if sqrt(-0.0)
	bool	hl
	ld		l,h
	ret

.__fsdivneg2:
	EXCEPTION(-ERR_DOMAIN)
	ret

sqrt::
	push	ix
	ld		h,b				; 2
	ld		l,c				; 2
	add	hl,hl				; 2, check the sign and unpack exponent
	jr		c,.__fsdivneg	; 5
; wc=11
	scf						; 2
	rr		l					; 4, restore implicit bit

	ld		a,h				; 2

	or		a					; 2, is number == 0 (yes: return 0)
	jr		z,.__fsqzero		; 5
; wc=11+15=26
	push	hl					; 10, save exponent/mantissa
	push	de					; 10

	ld		h,l				; 2, store the number into hl:de
	ld		l,d				; 2
	ld		d,e				; 2
	ld		e,0				; 4

	ld		a,c				; 2, make the initial guess by looking at lsb
								;    of exponent and the 5 msb of mantissa
; wc=26+32=58
	;
	; x       = x.mantissa/0x800000 * 2^(x.exp-0x7f)
	; sqrt(x) = sqrt(x.mantissa/0x800000) * 2^(0.5 * (x.exp-0x7f))
	;
	; When the exponent is even, subtracting 0x7f then dividing by 2
	; leaves a remainder.  This remainder is expressed as a sqrt(2)
	; multiple on the final result.
	;
	; During the calculation numbers with an even exponent are left
	; aligned on bit 23.  This alignment has the effect of multiplying
	; the result by sqrt(2).  Numbers with an odd exponent are shifed
	; right once in the beginning of the calculation and left once at
	; the end of the calculation so they will be free of the sqrt(2).
	;

	rra						; 2, shift off bits not needed for table lookup
	xor	0x40				; 4, reverse lsb of exponent and clear carry flag
	rra						; 2

	cp		a,0x20			; 4, check if exponent is odd
	jr		nc,.__fs0			; 5
	or		a					; 2, clear carry flag
	rr		hl					; 2
	rr		de					; 2

.__fs0:
; wc=58+23=81
	exx						; 2

	bool	hl					; 2, lookup estimate in the table
	ld		l,a				; 2
	ld		de,sqrt_table	; 6
	add	hl,de				; 2

	ld		a,(hl)			; 5, w[0] about 1/sqrt(x)

	;
	; first iteration w[0]->w[1] = 5 bits accuracy -> 8 bits
	;
	; w[0]*w[0]  =  8x8  -> 16 multiply
	; w[0]^2 * x = 16x16 -> 16 multiply
	;

	ld		b,a				; 2, bc=de=w[0]
	ld		d,a				; 2
	ld		c,0				; 4
	ld		e,c				; 2
; wc=81+28=109
	mul						; 12
	add	hl,hl				; 2, hl = w[0]^2

	ex		de,hl'			; 4
	ex		de,hl				; 2
	ld		b,h				; 2
	ld		c,l				; 2

	ld		bc',bc			; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs1			; 5
	add	hl,de				; 2

.__fs1:
; wc=109+51=160
	add	hl,hl				; 2, w[0]^2*x

	ex		de,hl				; 2
	ld		hl,0xc000		; 6
	sbc	hl,de			 	; 4, 3 - w[0]^2*x

	ld		b,h				; 2
	ld		c,l				; 2

	ld		d,a				; 2
	ld		e,0				; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs1a			; 5
	add	hl,de				; 2

.__fs1a:
; wc=160+47=207
	add	hl,hl				; 2, w[1] 8 bits of accuracy

	ex		de,hl				; 2
	ld		b,d				; 2
	ld		c,e				; 2

	mul						; 12
	rr		b					; 4
	add	hl,hl				; 2, w[1]^2

	ex		de,hl'			; 4
	exx						; 2
	ld		bc',bc			; 4
	exx						; 2

	ex		de,hl				; 2

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs2			; 5
	add	hl,de				; 2

.__fs2:
; wc=207+63=270
	rl		b					; 4
	adc	hl,hl				; 4, w[1]^2*x

	ex		de,hl				; 2
	ld		hl,0xc000		; 6
	sbc	hl,de				; 4
	ld		b,h				; 2
	ld		c,l				; 2
	ex		de,hl'			; 4

	mul						; 12
	add	hl,de				; 2
	rr		b					; 4
	adc	hl,hl				; 4, w[2] 14 bits of accuracy

; wc=270+50=320

;	ex		de,hl				; 2  *********bug repaired 12/4/98
	ld		b,d				; 2
	ld		c,e				; 2
	mul						; 12
	rl		c					; 4
	rl		b					; 4
	adc	hl,hl				; 4, w[2]^2 hl:bc

	push	de					; 10, save w[2]

	ex		de',hl			; 2
	exx						; 2
	ld		de',bc			; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs3			; 5
	add	hl,de				; 2

.__fs3:
; wc=320+71=391
	xor	a					; 2, clear a to store carry
	ld		iy,0				; 8, use iy it accumulate the sum of products
	add	iy,bc				; 4
	exx						; 2

	ex		de,hl				; 2
	ld		bc',de			; 4
	ex		de,hl				; 2

	ld		ix,0
	bit	7,d				; 4
	jr		z,.__fs4			; 5
	add	ix,bc				; 4, correction for signed -> unsigned multiply

.__fs4:
; wc=391+37=428
	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs5			; 4
	add	hl,de				; 4, correction for signed -> unsigned multiply

.__fs5:
; wc=428+24=452
	ex		de,hl				; 2
	add	ix,de
	ex		de,hl
	ld		hl,ix
	ex		de,hl

	add	iy,de
	adc	a,0

	exx						; 2
	ex		de',hl			; 2

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs6			; 5
	add	hl,de				; 2, correction for signed -> unsigned multiply

.__fs6:
; wc=452+35=487
	ex		de,hl				; 2
	ld		hl,iy				; 4, accumulate sum of products
	add	hl,de				; 2
	adc	a,0

	exx						; 2

	add	a,e				; 2
	ld		e,a				; 2
	jr		nc,.__fs8			; 5
	inc	d					; 4

;.__fs7:
; wc=487+17=504
;	or		a					; 2
;	jr		z,.__fs8			; 5
;	inc	de					; 2

.__fs8:
; wc=504+9=513
	exx						; 2
	add	hl,hl				; 2
	exx						; 2

	rl		de					; 2
	exx						; 2
	ex		de,hl				; 2
	bool	hl					; 2
	ld		l,h				; 2
	sbc	hl,de				; 4
	exx						; 2
	ld		hl,0xc000		; 6
	sbc	hl,de				; 4, 3-w[2]^2*x hl:hl'

	ld		b,h				; 2
	ld		c,l				; 2
	pop	de					; 7
	ld		de',de			; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs9			; 5
	add	hl,de				; 2

.__fs9:
; wc=513+70=583
	exx						; 2
	ld		b,h				; 2
	ld		c,l				; 2

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs10			; 5
	add	hl,de				; 2

.__fs10:
; wc=583+29=612
	ex		de',hl			; 2
	exx						; 2
	ex		de,hl				; 2
	add	hl,bc				; 2
	jr		nc,.__fs11		; 5
	inc	de					; 2

.__fs11:
; wc=612+15=627
	add	hl,hl				; 2
	rl		de					; 2, w[3] 28 bits accuracy

	exx						; 2

	pop	de					; 7, retrieve x
	pop	bc					; 7

	ld		a',b				; 4, save exponent
	ld		b,c				; 2
	ld		c,d				; 2
	ld		a,e				; 2

	ld		bc',bc			; 4
	exx						; 2
	ex		de',hl			; 2

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs12			; 5
	add	hl,de				; 2

.__fs12:
; wc=627+61=688
	exx						; 2
	ld		iy,0x0000		; 8
	bit	7,d				; 4
	jr		z,.__fs13			; 5
	add	iy,bc				; 4

.__fs13:
; wc=688+23=711
	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs14			; 5
	add	hl,de				; 2

.__fs14:
; wc=711+23=734
	ex		de,hl				; 2
	ld		hl,iy				; 4
	add	hl,de				; 2

	ex		de,hl'			; 4

	exx						; 2

	ld		bc',bc			; 4
	ld		b,a				; 2
	ld		c,0				; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs15			; 5
	add	hl,de				; 2

.__fs15:
; wc=734+47=781
	ex		de,hl'			; 4
	add	hl,de				; 2
	ex		de,hl				; 2
	exx						; 2
	jr		nc,.__fs16		; 5
	inc	de					; 2

.__fs16:
; wc=781+17=798
	ex		de',hl			; 2
	add	hl,bc				; 2
	jr		nc,.__fs17		; 5
	inc	de					; 2

.__fs17:
; wc=798+11=809
	add	hl,hl				; 2
	rl		de					; 2

	ex		af,af'			; 2
	sub	a,0x7f			; 4
	sra	a					; 4
	jr		nc,.__fs18		; 5
	add	hl,hl				; 2
	rl		de					; 2

.__fs18:
; wc=809+23=832
	ld		bc,0x003f		; 6
	add	hl,bc				; 2
	jr		nc,.__fs19		; 5
	inc	de					; 2

.__fs19:
; wc=832+15=847
	ld		c,d				; 2
	ld		d,e				; 2
	ld		e,h				; 2

	add	a,0x7f			; 4
	or		a					; 2, clear carry flag
	rra						; 2
	ld		b,a				; 2
	jr		c,.__fs20			; 5
	res	7,c				; 4

.__fs20:
; wc=847+25=872
	pop	ix
	ret						; 8
; wc=880...

#endasm

/*** BeginHeader tan */

float tan(float x);

/*** EndHeader   tan */

/*
 * TAN
 *
 * Purpose:
 *              Compute the tangent of real FLOAT value x
 *              The value x is assumed in radians (not degrees)
 *              Use deg() and rad() for conversions.
 * Returns:
 *              number          answer between -INF and +INF
 *                              errno = 0
 *              INF             x approx (2n+1)PI/2 error
 *                              errno = -ERR_RANGE
 *              ZERO            Argument too large negative or
 *                              positive ( greater than 8*PI).
 *                              errno = ERR_DOMAIN
 * Method:
 *              tan(x) = sin(x)/cos(x)  for x not within .01 of
 *                                      a multiple of PI/2
 *              tan(x) = new approx     otherwise
 *
 * Current problems:
 *
 *      First, if fabs(x) > 25.13, then we probably can't
 *      compute it at all. The number 25.13 comes from
 *
 *              8*PI = 25.13274123 (12-digits)
 *              8*3.14159 = 25.13272 (6-digits)
 *              error = -2.12288e-05
 *              So to maintain 6-digit accuracy restrains
 *              computation to -8PI < x < 8PI.
 *
 *      Let us assume 0 <= x <= pi/2. Let u = pi/2 - x. If
 *      u is too close to zero, then computation fails:
 *
 *      sin(x)/cos(x) = sin(x)/cos(pi/2-u)
 *                    = sin(x)/sin(u)
 *                    = cos(u)/sin(u)
 *                    = 1./u approximately
 *
 *      This is cured by using a different rational function
 *      near pi/2, namely a Taylor expansion:
 *
 *                         2       4           2      4
 *      tan x = (1/u)(1 - u  /2 + u /24)/(1 - u /6 + u /120)
 *
 *      At u = .009999, tan x = 100.006668, but 1/u = 100.010001.
 *      For 0 <= x < BADTAN, sin(x)/cos(x) is a good approximation.
 *      It looks like we need the above rational, but perhaps a
 *      better choice of BADTAN would allow use of 1/u.
 */

/* START FUNCTION DESCRIPTION ********************************************
tan                          <MATH.LIB>

SYNTAX:       float tan(float x);

PARAMETER1:   Floating point input for tangent computation.

KEYWORDS:     math

DESCRIPTION:  Compute the tangent of the argument.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug float tan(float x)
{
	static FLOAT sin(), cos();
	const static FLOAT p[] =
	{
		1.0, -0.5, 0.0416666666
	};
	const static FLOAT q[] =
	{
		1.0, -0.1666666667, 0.0083333333
	};
	auto FLOAT z, w;
	static register int c;
	static FLOAT poly();
	static int abs();

	c = (int)(x * TWObyPI);
	if (abs(c) >= 16)
	{
#asm
		EXCEPTION(-ERR_DOMAIN)
#endasm
		return ZERO;
	}
	z = x - c * PIbyTWO;
	if (c & 1)
		z += ((z < ZERO) ? PIbyTWO : - PIbyTWO);
	if (c = (z < ZERO))
		z = - z;
	if (z == PIbyTWO)
	{
#asm
		EXCEPTION(-ERR_RANGE)
#endasm
		return INF;
	}
	if (z > BADTAN)
	{
		z = PIbyTWO - z;
		w = z * z;
		z = (poly(w, 2, p) / poly(w, 2, q)) / z;
	}
	else
	{
		z = sin(z) / cos(z);
	}
	return (c ? - z : z);
}

/*** BeginHeader tanh */

float tanh(float x);

/*** EndHeader   tanh */

/*
 * TANH
 *
 * Purpose:
 *              Compute the hyperbolic tangent of real FLOAT value x
 * Returns:
 *              number          x in range
 *              INF             x too large positive
 *             -INF             x too large negative
 *                              errno = -ERR_RANGE returned to flag error
 * Method:
 *              tanh(x) = (exp(x) - exp(-x))/(exp(x) + exp(-x))
 * Notes:
 *              o Find EXPLARGE by solving exp(x)=1.0e39=INF
 */

/* START FUNCTION DESCRIPTION ********************************************
tanh                         <MATH.LIB>

SYNTAX:       float tanh(float x);

PARAMETER1:   Floating point input for hyperbolic tangent computation.

KEYWORDS:

DESCRIPTION:  Computes the hyperbolic tangent of argument.

RETURN VALUE: Returns the hyperbolic tangent of x.  If x > 49.9 (approx.),
				  the function returns INF and signals a range error.
				  If x < 49.9 (approx.), the function returns INF and signals
				  a range error.
END DESCRIPTION **********************************************************/
nodebug FLOAT tanh(float x)
{
	FLOAT exp();
	auto FLOAT y;

	y = x + x;
	if (y > EXPLARGE)
	{
#asm
		EXCEPTION(-ERR_RANGE)
#endasm
		return ONE;
	}
	if (y < - EXPLARGE)
	{
#asm
		EXCEPTION(-ERR_RANGE)
#endasm
		return - ONE;
	}
	y = exp(y);
	return ((y - ONE) / (y + ONE));
}

/*** BeginHeader _pow10 */
float _pow10(int exp);
/*** EndHeader   _pow10 */

/***************************************************************************\
	GENERAL UTILITY Convert Integer to Floating Exponent ( i.e. 10 ** i )

	   float _pow10 ( int exp )
\***************************************************************************/

const static float n10[][4] =
			 {
				 1e0, 1e-1, 1e-2, 1e-3,
				 1e0, 1e-4, 1e-8, 1e-12,
				 1e0, 1e-16, 1e-32, 0.0
			 };
const static float p10[][4] =
			 {
				 1e0, 1e1, 1e2, 1e3,
				 1e0, 1e4, 1e8, 1e12,
				 1e0, 1e16, 1e32, 0.0
			 };

/* START _FUNCTION DESCRIPTION ********************************************
_pow10                       <MATH.LIB>

SYNTAX:       float _pow10(int exp)

PARAMETER1:   integer exponent to which 10 is to be raised.

KEYWORDS:

DESCRIPTION:  Computes integral powers of 10.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
nodebug float _pow10(int exp)
{
	auto float prod;
	auto int i, sign;

	prod = 1.0;
	if (sign = (exp < 0))
		exp = - exp;
	for (i = 0; i < 3; i++)
	{
		if (sign)
			prod *= n10[i][exp & 3];
		else
			prod *= p10[i][exp & 3];
		if (! (exp >>= 2))
			break;
	}
	return (prod);
}

/*** BeginHeader getcrc */

root int getcrc(char *Data, char count, int accum);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
getcrc                       <MATH.LIB>

SYNTAX:       int getcrc(char *dataarray, char count, int accum);

PARAMETER1:   Character array for which CRC is to be computed.

PARAMETER2:   Number of bytes to be checked in dataarray

PARAMETER3:   Base CRC for the data array

DESCRIPTION:  Computes CRC of a data array.  "dataarray" points to "count"
              number of bytes.  "accum" is the base CRC for the data array.
              "count" max is 255.

RETURN VALUE: CRC value.
END DESCRIPTION **********************************************************/
#asm nodebug
getcrc::
	ld 	hl,0002   			; locate first 2 byte argument
	add 	hl,sp
	ld 	e,(hl)
	inc 	hl
	ld 	d,(hl)
	push	de    				; de has the address of the data
	inc 	hl     				; two more increment get the second 1 byte argument
	ld 	c,(hl)  				;  c has the number of counts
	inc	 hl     				; now pointing to the low byte of accum
	inc 	hl
	ld 	a,(hl)  				; a has the low byte of the accum
	inc 	hl
	ld 	h,(hl)  				; h has the high byte of the accum
	ld 	l,a     				; l has the low byte of the accum
.do_data:               		; compute crc for (de+1) bytes of data
	pop 	de     				;
	ld 	a,(de)  				; load first data
	inc 	de     				; update to next memory location
	push 	de    				; keep last memory location
	ld 	d,a     				; use d for current data
	ld 	b,8     				; rotate and xor data 8 times
.eight_times:
	ld 	a,h     				; xor data to accum
	xor 	d
	rlca
	jr 	nc,.no_poly  		; no carry, no need to xor polynomial
	add 	hl,hl
	ld 	a,0x10      		; xor 0x1021 to accum
	xor 	h
	ld 	h,a
	ld 	a,0x21
	xor 	l
	ld 	l,a
	jr 	.__rotate_data
.no_poly:                	; only need to shift accum
	add 	hl,hl
.__rotate_data:
	xor 	a
	rl 	d
	djnz 	.eight_times
	dec 	c
	jr 	nz,.do_data
	pop 	de    				; pop one last time to balance loop
	ret
#endasm

/*** BeginHeader lsqrt */

unsigned lsqrt(unsigned long x);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
lsqrt                        <MATH.LIB>

SYNTAX:       unsigned int lsqrt(unsigned long x);

PARAMETER1:   long int input for square root computation

KEYWORDS:     math

DESCRIPTION:  Computes the square root of x.  Note that the return value
              is an unsigned int.  The fractional portion of the result
              is truncated.

RETURN VALUE: Square root of x (fractional portion truncated)
END DESCRIPTION **********************************************************/

nodebug unsigned lsqrt(unsigned long x) {
	static char buffer[8];
	auto char lastBuf[8];
	static register int count;

	memcpy(lastBuf,buffer,sizeof(buffer));
	*(unsigned long *)buffer = x;
	*((unsigned long *)buffer+1) = 0;
	count = 16;
#asm xmemok
	ld		de,0
.doAgain:
	ld		hl,.jumpback
	push	hl
	jp		.shiftBy2

.jumpback:
	ex		de,hl					; shift root by one bit
	add	hl,hl
	ex		de,hl

	ld		l,e					;	bc = de * 2 + 1
	ld		h,d
	add	hl,hl
	inc	hl
	ld		c,l
	ld		b,h

	ld		hl,(buffer+4)
	xor	a						;	carry bit clear
	sbc	hl,bc					;	subtract least sig. word
	push	hl
	ld		hl,(buffer+6)
	ld		bc,0
	bit	7,d
	jr		z,.__noCarryOver
	inc	bc
.__noCarryOver:
	sbc	hl,bc					;	subtract most sig. word
	jp		c,.__noSubtract
									;	commit the subtraction
	ld		(buffer+6),hl
	pop	hl
	ld		(buffer+4),hl

	inc	de						;	increment root

	jr		.contLoop
.__noSubtract:
	pop	hl
.contLoop:
	ld		hl,count
	dec	(hl)
	jp		nz,.doAgain

	ld		l,e
	ld		h,d
	jr		.funcEnd

.shiftBy2:
	ld		hl,(buffer)			;	shift buffer by two bits
	add	hl,hl
	rl		c
	add	hl,hl
	rla
	ld		(buffer),hl
	ld		hl,(buffer+2)
	rr		c
	adc	hl,hl
	rl		c
	rra
	adc	hl,hl
	rla
	ld		(buffer+2),hl
	ld		hl,(buffer+4)
	rr		c
	adc	hl,hl
	rl		c
	rra
	adc	hl,hl
	rla
	ld		(buffer+4),hl
	ld		hl,(buffer+6)
	rr		c
	adc	hl,hl
	rl		c
	rra
	adc	hl,hl
	rla
	ld		(buffer+6),hl

	pop	hl
	jp		(hl)

.funcEnd:
#endasm
}

/*** BeginHeader srand, rand, _ran_value */
void srand(unsigned long);
float rand(void);
extern unsigned long _ran_value;
/*** EndHeader */

unsigned long _ran_value;

/* START FUNCTION DESCRIPTION ********************************************
srand                         <MATH.LIB>

SYNTAX:			void srand(unsigned long seed)

KEYWORDS:		math, random

DESCRIPTION:	Sets the seed value for the rand() function.  The seed must
					be an odd number.

SEE ALSO:		rand, randg, randb

RETURN VALUE:	none
END DESCRIPTION **********************************************************/

nodebug
void srand(unsigned long seed)
{
	_ran_value = seed;
}

/* START FUNCTION DESCRIPTION ********************************************
rand                         <MATH.LIB>

SYNTAX:			float rand(void);

KEYWORDS:		math, random

DESCRIPTION:	Returns a uniformly distributed random number in the
					range 0.0 <= v < 1.0.  Uses the algorithm

							rand = (5 * rand) modulo (2^32)

					A default seed value is set on startup, but can be changed
					with the srand() function.  This function is not task reentrant.

SEE ALSO:		randg, randb, srand

RETURN VALUE:	a uniformly distributed random number 0.0 <= v < 1.0
END DESCRIPTION **********************************************************/

nodebug
float rand()
{
	static float value;

#GLOBAL_INIT { _ran_value = 0x83654321; } // initial seed value

// algorithm - r[n+1]=r[n]*5 mod 2^32 then take bits starting at bit 28 for mantissa
#asm
	ld 	de,(_ran_value+2) ; most
	ld 	hl,(_ran_value)   ; least
	set 	0,l   				; make sure odd, in case bad seed
	add 	hl,hl
	rl 	de
	add 	hl,hl
	rl 	de
; 2 shifts left
	ld 	bc,(_ran_value) 	; least
	add 	hl,bc 				; add leasts
	ex 	de,hl
	ld 	bc,(_ran_value+2) ; most
	adc 	hl,bc  				; most
	ld 	(_ran_value+2),hl ; most
	ld 	(_ran_value),de   ; least
; shift 4 right to get mantissa
	rr 	hl
	rr 	de
	rr 	hl
	rr 	de
	rr 	hl
	rr 	de
	rr 	hl
	rr 	de
	ld 	c,l
	ld 	b,0
	call 	Bg_Bf  				; float integer in cde
; move binary point 24 right
	ld 	a,b
	sub 	0ch
	ld 	b,a
	ld 	(value),de
	ld 	(value+2),bc
#endasm
	return value;
}

/*** BeginHeader randb */
float randb(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
randb                         <MATH.LIB>

SYNTAX:			float randb(void);

KEYWORDS:		math, random

DESCRIPTION:	Returns a uniformly distributed random number in the
					range -1.0 <= v < 1.0.  See rand() for more information
					about the algorithm used  This function is not task reentrant.

SEE ALSO:		rand, randg, srand

RETURN VALUE:	a uniformly distributed random number -1.0 <= v < 1.0
END DESCRIPTION **********************************************************/

nodebug
float randb(){   // uniformly distributed -1. to +1. call rand() and add sign
auto float value;

#asm
   call 	rand  				; get random number in bcde
   ld 	hl,(_ran_value+2) ; get current number most part
   ld 	a,h
   rla
   rla
   rla
   and 	80h
   or 	b
   ld 	b,a  					; put a sign on randomly
   ex 	de,hl
   ld 	(sp+@sp+value),hl
   ld 	l,c
   ld 	h,b
   ld 	(sp+@sp+value+2),hl
#endasm
   return value;
}


/*** BeginHeader randg */
float randg(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
randg                         <MATH.LIB>

SYNTAX:			float randg(void);

KEYWORDS:		math, random

DESCRIPTION:	Returns a gaussian-distributed random number in the
					range -16.0 <= v < 16.0 with a standard deviation of
					approximately 2.6.  The distribution is made by adding
					16 random numbers (see rand()).  This function is not
					task reentrant.

SEE ALSO:		rand, randb, srand

RETURN VALUE:	a uniformly distributed random number -1.0 <= v < 1.0
END DESCRIPTION **********************************************************/

nodebug
float randg(){
// adds together 16 uniformly distributed numbers between -1 and +1
// to create an approximately gaussian distribution
static float value;

#asm
	exx
	ld 	hl,0
	ld 	de,0 					; zero sum
	ld 	a,16  				; count
	exx
.loop:
	ld 	de,(_ran_value+2)	; most
	ld		hl,(_ran_value)  	; least
	set 	0,l   				; make sure odd, in case bad seed
	add 	hl,hl
	rl 	de
	add 	hl,hl
	rl 	de
; 2 shifts left
	ld 	bc,(_ran_value) 	; least
	add 	hl,bc ; add leasts
	ex 	de,hl
	ld 	bc,(_ran_value+2)	; most
	adc 	hl,bc  				; most
	ld 	(_ran_value+2),hl	; most
	ld 	(_ran_value),de  	; least
; shift 4 right to get mantissa
	rr 	hl
	rr 	de
	rr 	hl
	rr 	de
	rr 	hl
	rr 	de
	rr 	hl
	rr 	de
	rr 	h  					; get bit to use for sign
	ld 	h,0
	ld 	b,h
	ld 	c,l  					; move to bc
	jr 	nc,.mpos 				; check for negate mantissa
; negate mantissa
	or 	a  					; clc
	ld 	hl,0
	sbc 	hl,de  				; neg least
	ex 	de,hl
	ld 	hl,0
	sbc 	hl,bc  				; most
	ld 	b,h
	ld 	c,l
.mpos:     						; now have mantissa in bcde signed number
; add to sum in alternate regs
	ld 	bc',de
	exx
	ex 	de,hl
	add 	hl,bc 				; add leasts
	ex 	de,hl
	exx
	ld 	bc',bc 				; mosts
	exx
	adc 	hl,bc 				; mosts
	exx
	dec 	a
	jr 	nz,.loop
; now have 16 added in alt hlde
	exx
	ld 	b,h
	ld 	c,l
	call 	Bl_Bf  				; float the number
	ld 	a,b
	and 	80h
	ld 	l,a
	ld 	a,b
	sub 	0ch
	and 	a,7fh
	or 	l
	ld 	b,a
	ld 	(value),de 			; least
	ld 	(value+2),bc 		; most
#endasm
	return value;
}



/*** BeginHeader */
#endif
/*** EndHeader */