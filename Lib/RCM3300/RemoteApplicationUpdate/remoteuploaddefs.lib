/*** BeginHeader */
#ifndef REMOTELOADERDEFS_LIB
#define REMOTELOADERDEFS_LIB

/* START LIBRARY DESCRIPTION *********************************************
REMOTEUPLOADDEFS.LIB
	Copyright (c) 2004, Rabbit Semiconductor

DESCRIPTION:

   This library provides functionality and configuration shared between a DLM,
   DLP, and parallel flash resident loader.  Macros that are shared bewteen
   both the DLM and DLP, such as user name, password, etc. are prefixed with
   RUPL_ (remote upload).

END DESCRIPTION **********************************************************/

#if !(_BOARD_TYPE_ == RCM3300A || _BOARD_TYPE_ == RCM3305 || \
      _BOARD_TYPE_ == RCM3309 || _BOARD_TYPE_ == RCM3310A || \
      _BOARD_TYPE_ == RCM3315 || _BOARD_TYPE_ == RCM3319)
#error "Remote upload application supports only RCM33xx types with on-board serial flash."
#endif

/*** EndHeader */

/*** BeginHeader */

// Configuration macros

// The default user name used for authentication when accessing password
// protected resources via the Web interface.
#ifndef RUPL_USER_NAME
#define RUPL_USER_NAME						"admin"
#endif

// The default password used for authentication when accessing password
// protected resources via the Web interface.
#ifndef RUPL_USER_PASSWORD
#define RUPL_USER_PASSWORD					"reboot"
#endif

// The default user group for accessing resources within the web server.
#ifndef RUPL_ADMIN_GROUP
#define RUPL_ADMIN_GROUP 					0x0002
#endif

// The default method used for authenticating users in the web interface. This
// macro can be SERVER_AUTH_DIGEST for digest authentication, SERVER_AUTH_BASIC
// for basic authentication, or SERVER_AUTH_NONE for no user authentication. If
// digest authentication is used, then USE_HTTP_DIGEST_AUTHENTICATION must be
// defined to 1 prior to including this library and HTTP.LIB.
#ifndef RUPL_HTTP_SERVER_AUTH
#define RUPL_HTTP_SERVER_AUTH				SERVER_AUTH_BASIC
#endif

// The following macro will save the current network configuration to the user
// block when switching between the DLM/DLP, only if the configuration has
// changed.  This allows the run time setting of the device's IP address from
// either the DLM or DLP and having the setting reflected in the other.
#ifndef RUPL_SAVE_RESTORE_NETWORK_PARAMS
#define RUPL_SAVE_RESTORE_NETWORK_PARAMS	0
#endif

// RUPL_USER_BLOCK_OFFSET: This will give the DLM and the DLP the location in
// the user block where various pieces of configuration information can be
// stored.  The user block will only be used for storing power-on parameters
// such as ip address, netmask, gateway, etc.
#ifndef RUPL_USER_BLOCK_OFFSET
#define RUPL_USER_BLOCK_OFFSET            		0
#endif

// By default, debug information is turned off in this file.  To enable
// debugging, undefine the following macro.
//#define DLP_DEFS_DEBUG

/*
		End configuration section
*/

// Time definitions to be used when specifying restart timeframe requirements
#define DLM_RESTART_MINUTE					60L
#define DLM_RESTART_HOUR               DLM_RESTART_MINUTE * 60L
#define DLM_RESTART_DAY                DLM_RESTART_HOUR   * 24L
#define DLM_RESTART_WEEK               DLM_RESTART_DAY    * 7L
#define DLM_RESTART_MONTH              DLM_RESTART_WEEK   * 4L
#define DLM_RESTART_YEAR					DLM_RESTART_MONTH  * 12L

// Flags to set the upper two bits of the DLM/DLP address handed off to the
// loader.  If the sflash mask bit is set, the loader will load the image out of
// serial flash.  The compressed mask is currently not used.
#define IMAGE_IN_SFLASH_MASK				0x40000000
#define IMAGE_COMPRESSED_MASK				0x80000000

// The DLM/DLP/Loader use the last 128 bytes of RAM to pass parameters to
// each other.  The last 4k of RAM is set aside for the flash transfer buffer
// and is unused when switching between the three.
#define LDR_PARM_ADDR_START 				(((RAM_START+_RAM_SIZE_)*0x1000L)-128L)
#define LDR_TYPE_BASE 						0

// The following are structure and offset definitions for RAM based parameters
#define LDR_TYPE_DLMSTARTPARMS 			LDR_TYPE_BASE + 0
#define LDR_TYPE_DLMSTARTPARMS_OFS 		LDR_PARM_ADDR_START + 0
typedef struct
{
	char type;
	char gcsr_value;
	unsigned long dlp_parallel_addr;
   unsigned long dlp_parallel_len;
	int checksum;
}ldrDLMStartParms;


#define LDR_TYPE_LDRSTARTDLP 			LDR_TYPE_BASE + 1
#define LDR_TYPE_LDRSTARTDLP_OFS 	LDR_TYPE_DLMSTARTPARMS_OFS + \
												sizeof(ldrDLMStartParms)
typedef struct
{
   char type;
   unsigned long address;
   unsigned long length;
   int checksum;
}ldrStartDLP;


#define LDR_TYPE_LDRSTARTDLM 			LDR_TYPE_BASE + 2
#define LDR_TYPE_LDRSTARTDLM_OFS 	LDR_TYPE_LDRSTARTDLP_OFS + \
												sizeof(ldrStartDLP)
typedef struct
{
   char type;
   unsigned long address;
   unsigned long length;
   int checksum;
}ldrStartDLM;

#define LDR_TYPE_DLM_IMAGE  			LDR_TYPE_BASE + 3
#define LDR_TYPE_DLP_IMAGE  			LDR_TYPE_BASE + 4
typedef struct
{
   char type;
   char compressed;
   unsigned short crc;
   unsigned short checksum;
}ldrImageInfo;

#define LDR_TYPE_RUNTIMEERROR 		LDR_TYPE_BASE + 5
#define LDR_TYPE_RUNTIMEERROR_OFS	LDR_TYPE_LDRSTARTDLM_OFS + \
												sizeof(ldrStartDLM)
typedef struct
{
	char type;
   char xpc;
   unsigned int addr;
   char error;
   int checksum;
}ldrRunTimeErrorInfo;

#define LDR_TYPE_CRCDEBUG 				LDR_TYPE_BASE + 6
#define LDR_TYPE_CRCDEBUG_OFS			LDR_TYPE_RUNTIMEERROR_OFS + \
												sizeof(ldrRunTimeErrorInfo)
typedef struct
{
   char type;
   unsigned int  calculated_crc;
	ldrImageInfo  stored_info;
   unsigned long image_ptr;
   unsigned int  leftover;
   int checksum;
}ldrCRCDebug;

// This struct is used by rupl_valid_image to pass along information about
// memory layout, where the image is to be loaded from, buffer for receiving
// image from serial flash, and the size of the buffer.
typedef struct
{
   unsigned long physdatastart;
	unsigned long physdataend;
	unsigned long imgdestination;
	char loadfromsflash;
   char* sflashbuffer;
   int sfbufsize;
}ldrRAMLoadInfo;

#ifdef DCRTCP
/*
 * Sub-structure (of a NetConfSave) which contains non-interface-specific
 * configuration info.
 */
typedef struct {
	word				len;				// Total length of this structure

	word				nrouters;		// Number of routers in following list
	struct {
		longword		ipaddr;			// IP address of router (0 if entry not used)
		longword		subnet;			// Subnet served by this router
		longword		mask;				// Mask for above subnet
	} router[ARP_ROUTER_TABLE_SIZE];

	word				nnameservers;	// Number of name (DNS) servers on following list
	longword			nameserver[MAX_NAMESERVERS];	// IP addresses of name servers (0 if entry not used)
} NISNetConf;

/*
 * Sub-structure (of a NetConfSave) which contains interface-specific
 * configuration info.  Most of the fields are the same as IFTEntry,
 * except that fields which are purely dynamic are not included.
 */

typedef struct {
	word				len;				// Total length of this structure
	byte				iface;			// Interface number
	byte				type;
#define ISNC_ETH			0x00			// Ethernet
#define ISNC_PPPOE		0x01			// PPP over ethernet
#define ISNC_PPPSER		0x02			// PPP over serial
} ISNetConfHead;

typedef struct {
	ISNetConfHead head;
	word				mtu;			// Max transmission unit (IP, transport headers plus data)
	longword			ipaddr;		// Home IP address last used (0 if entry not used)
	longword			mask;			// Our subnetting mask (normally all 1's for PPP)
	word				flags;		// Flags as per the IFF_* defines above.
#define ISNC_FLAGMASK	(IFF_DHCP|IFF_ICMP_CONFIG)		// Flags which are permanently saved
	word				 eflags;		// Broadcast ethernet-specific flags... (reserved, set zero)
} EthNetConf;

#if USING_PPPOE || USING_PPPLINK
typedef struct {
	ISNetConfHead head;
	word				mtu;			// Max transmission unit (IP, transport headers plus data)
	word				pflags;
	longword			peeraddr;
	PPPState 		ppp_state;   //holds all PPP config
} PPPNetConf;
#endif


/*
 * The following structure is used to save and restore network configuration.  Unlike
 * most structures, this one is designed to be forwards and backwards compatible, so
 * that new versions of DC (or the application program) will be able to read the
 * configuration from older versions.  It is intended that the structure is able to
 * be saved in the user block or filesystem.
 */
typedef struct {
	word				len;				// Total length of this structure (varies depending on
											// how many interfaces and other factors).
	byte				version;			// Struct version number
#define NCS_VERSION	0					// Version number incremented when incompatible change
	byte				flags;			// Flag bits (reserved, set zero)
	NISNetConf		nis;				// Non-interface-specific info
	// Number of interface-specific items following
	word				num_eth;
	word 				num_pppser;
	word				num_pppoe;
// Interface-specific info.  Note that the array dimension is
#if (USING_ETHERNET + USING_WIFI)
	EthNetConf		eth[USING_ETHERNET+USING_WIFI];
#endif
#if USING_PPPLINK
	PPPNetConf		pppser[USING_PPPLINK];
#endif
#if USING_PPPOE
	PPPNetConf		pppoe[USING_PPPOE];
#endif

} NetConfSave;
#endif	// #ifdef DCRTCP

// The ruplNetworkPowerOnParameters struct is stored at
// DLM_TYPE_USERBLOCK_NW_PARAM_OFS in the user block.
#define RUPL_TYPE_USERBLOCK_BASE					0
#define RUPL_TYPE_USERBLOCK_NW_PARAM			RUPL_TYPE_USERBLOCK_BASE + 0
#define RUPL_TYPE_USERBLOCK_NW_PARAM_OFS		RUPL_USER_BLOCK_OFFSET + 0
typedef struct
{
   char type;
#ifdef DCRTCP
   NetConfSave configuration;
#endif
   int checksum;
}ruplNetworkPowerOnParameters;

#ifdef DLP_DEFS_DEBUG
	#define _dlp_defs_nodebug
#else
	#define _dlp_defs_nodebug nodebug
#endif

/*** EndHeader */

////////////////////////////////////////////////////////////////////////////////
//		SECTION: Network configuration saving/restoring
////////////////////////////////////////////////////////////////////////////////
/*** BeginHeader ifs_restore */
#ifdef DCRTCP
int ifs_restore (NetConfSave *ncs);
#endif	// #ifdef DCRTCP
/*** EndHeader */
#ifdef DCRTCP
int ifs_restore (NetConfSave *ncs)
{
	auto int i;
   auto int ival;
   auto word* wpval;
   auto longword* lpval;

   //check for match of version, size, and interfaces
   if(ncs->version != NCS_VERSION) goto _ifc_error;
   if(ncs->len != sizeof(NetConfSave)) goto _ifc_error;
   if(ncs->num_eth != USING_ETHERNET + USING_WIFI) goto _ifc_error;
   if(ncs->num_pppser != USING_PPPLINK) goto _ifc_error;
   if(ncs->num_pppoe != USING_PPPOE) goto _ifc_error;

   if (_initialized) for (i = 0; i < IF_MAX; i++)
      ifdown(i);
//   if (iface != IF_ANY)
  //    wasup = ifpending(iface);
 #if (USING_ETHERNET + USING_WIFI)
   for (i = 0; i < USING_ETHERNET + USING_WIFI; i++) {
      ival = ncs->eth[i].head.iface;
      _if_tab[ival].mtu = ncs->eth[i].mtu;
      _if_tab[ival].ipaddr = ncs->eth[i].ipaddr;
      _if_tab[ival].mask = ncs->eth[i].mask;
      _if_tab[ival].flags = ncs->eth[i].flags & (ISNC_FLAGMASK |
                                         ((ncs->eth[i].flags&IFF_DHCP)?IFF_DHCP_OK:0) |
                                         ((ncs->eth[i].flags&IFF_ICMP_CONFIG)?IFF_ICMP_CFG_OK:0));
      _if_tab[ival].u.eth.eflags = ncs->eth[i].eflags;
   }
 #endif
 #if USING_PPPLINK
   for (i = 0; i < USING_PPPLINK; i++) {
      ival = ncs->pppser[i].head.iface;
      _if_tab[ival].mtu = ncs->pppser[i].mtu;
      _if_tab[ival].u.ppp.pflags = ncs->pppser[i].pflags;
      _if_tab[ival].u.ppp.peeraddr = ncs->pppser[i].peeraddr;
      memcpy(_if_tab[ival].state,
             &(ncs->pppser[i].ppp_state),
             sizeof(PPPState));
   }
 #endif
 #if USING_PPPOE
   for (i = 0; i < USING_PPPOE; i++) {
      ival = ncs->pppoe[i].head.iface;
      _if_tab[ival].mtu = ncs->pppoe[i].mtu;
      _if_tab[ival].u.ppp.pflags = ncs->pppoe[i].pflags;
      _if_tab[ival].u.ppp.peeraddr = ncs->pppoe[i].peeraddr;
      memcpy(_if_tab[ival].state,
             &(ncs->pppoe[i].ppp_state),
             sizeof(PPPState));
   }
 #endif
   router_del_all();
   for (i = 0; i < ncs->nis.nrouters; i++) {
      if (!ncs->nis.router[i].ipaddr)
         continue;
      ival = ip_iface(ncs->nis.router[i].ipaddr, 2);
      if (ival == IF_ANY)
         ival = IF_DEFAULT;
      router_add(ncs->nis.router[i].ipaddr, ival, ncs->nis.router[i].subnet, ncs->nis.router[i].mask, 0);
   }
 #ifndef DISABLE_DNS
   wpval = (word *)(ncs->nis.router + ncs->nis.nrouters);
   lpval = (longword *)(wpval + 1);
   servlist_delete(&_dns_server_table, 0, DNS_PREDEFINED);
   for (i = 0; i < *wpval; i++, lpval++)
      if (*lpval)
         servlist_add(&_dns_server_table, *lpval, DNS_PREDEFINED, NULL);
 #endif
	return 0;
_ifc_error:
	return -1;
}
#endif	// #ifdef DCRTCP

/*** BeginHeader rupl_loadnetworkparameters */
/* _START FUNCTION DESCRIPTION ********************************************
rupl_loadnetworkparameters                     <DOWNLOADMANAGER.LIB>

SYNTAX:			int rupl_loadnetworkparameters(
						 			ruplNetworkPowerOnParameters* params);

DESCRIPTION:	This function reads the dlmNetworkPowerOnParameters from the
					RUPL_TYPE_USERBLOCK_NW_PARAM_OFS offset in the user block in
               parallel flash.

PARAMETER:		A pointer to a valid ruplNetworkPowerOnParameters struct to
					receive data from the user block.

RETURN VALUE:	1 if the data in the user block is valid.
					0 if the data in the user block is not valid.

END DESCRIPTION **********************************************************/

#ifdef DCRTCP
int rupl_loadnetworkparameters(ruplNetworkPowerOnParameters* params);
#endif	// #ifdef DCRTCP
/*** EndHeader */

#ifdef DCRTCP
_dlp_defs_nodebug
int rupl_loadnetworkparameters(ruplNetworkPowerOnParameters* params)
{
   readUserBlock(params, RUPL_TYPE_USERBLOCK_NW_PARAM_OFS,
   				  sizeof(ruplNetworkPowerOnParameters));
   // calculate simple summation checksum over type and NetConfSave members
   return (params->checksum == rupl_dochecksum((void*)params,
   		  sizeof(ruplNetworkPowerOnParameters) - sizeof(params->checksum)));
}
#endif	// #ifdef DCRTCP

/*** BeginHeader rupl_savenetworkparameters, repl_getCurrentNetworkConfig */
/* _START FUNCTION DESCRIPTION ********************************************
rupl_savenetworkparameters                     <DOWNLOADMANAGER.LIB>

SYNTAX:			void rupl_savenetworkparameters(void);

DESCRIPTION:	Saves the current network configuration to the user block
					if the current configuration differs from the configuration
               saved in the user block.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

#ifdef DCRTCP
void rupl_savenetworkparameters(void);
void repl_getCurrentNetworkConfig (NetConfSave *ncs);
#endif	// #ifdef DCRTCP
/*** EndHeader */

#ifdef DCRTCP
void repl_getCurrentNetworkConfig (NetConfSave *ncs)
{
	auto int i,j;
	auto int ival;

	ncs->len = sizeof(NetConfSave);
	ncs->version = NCS_VERSION;
	ncs->num_eth = USING_ETHERNET + USING_WIFI;
	ncs->num_pppser = USING_PPPLINK;
	ncs->num_pppoe = USING_PPPOE;
	ncs->flags = 0;
	ncs->nis.len = sizeof(NISNetConf);
	ncs->nis.nrouters = ARP_ROUTER_TABLE_SIZE;
	for (i = 0; i < ARP_ROUTER_TABLE_SIZE; i++) {
		if (_arp_gate_data[i].ath > 0 && !_arp_gate_data[i].flags) {
			arpcache_ipaddr(_arp_gate_data[i].ath, &ncs->nis.router[i].ipaddr);
			ncs->nis.router[i].subnet = _arp_gate_data[i].u.preconfig.subnet;
			ncs->nis.router[i].mask = _arp_gate_data[i].u.preconfig.mask;
		}
		else
			ncs->nis.router[i].ipaddr = 0;
	}
	ncs->nis.nnameservers = MAX_NAMESERVERS;
	for (i = 0; i < MAX_NAMESERVERS; i++) {
 #ifndef DISABLE_DNS
		if (!i)
			ncs->nis.nameserver[i] = servlist_first(&_dns_server_table, DNS_PREDEFINED, NULL);
      else
			ncs->nis.nameserver[i] = servlist_next(&_dns_server_table,
               ncs->nis.nameserver[i-1], DNS_PREDEFINED, NULL);
 #else
		ncs->nis.nameserver[i] = 0;
 #endif
	}
 #if (USING_ETHERNET + USING_WIFI)
	for (i = 0; i < USING_ETHERNET + USING_WIFI; i++) {
  #if USING_ETHERNET
		ival = IF_ETH0 + i;
  #else
		ival = IF_WIFI0 + i;
  #endif
		ncs->eth[i].head.iface = ival;
		ncs->eth[i].mtu = _if_tab[ival].mtu;
		ncs->eth[i].ipaddr = _if_tab[ival].ipaddr;
		ncs->eth[i].mask = _if_tab[ival].mask;
		ncs->eth[i].flags = _if_tab[ival].flags;
		ncs->eth[i].eflags = _if_tab[ival].u.eth.eflags;
	}
 #endif
 #if USING_PPPLINK
	j = 0;
	for (i = 0; i < MAX_PPP_SERIAL; i++) {
		if(USE_PPP_SERIAL & (1 << i))
		{
  #ifdef MULTI_IF
			ival = IF_PPP0 + i;
  #else
			ival = 0;  //only one PPP interface, nothing else
  #endif
			ncs->pppser[j].head.iface = ival;
			ncs->pppser[j].mtu = _if_tab[ival].mtu;
			ncs->pppser[j].pflags = _if_tab[ival].u.ppp.pflags;
			ncs->pppser[j].peeraddr = _if_tab[ival].u.ppp.peeraddr;
			memcpy(&(ncs->pppser[j].ppp_state),
					 _if_tab[ival].state,
					 sizeof(PPPState));
			j++; //next index in save array
		}
	}
 #endif
 #if USING_PPPOE
	for (i = 0; i < USING_PPPOE; i++) {
		ival = IF_PPPOE0 + i;
		ncs->pppoe[j].head.iface = ival;
		ncs->pppoe[i].mtu = _if_tab[ival].mtu;
		ncs->pppoe[i].pflags = _if_tab[ival].u.ppp.pflags;
			ncs->pppoe[j].peeraddr = _if_tab[ival].u.ppp.peeraddr;
		memcpy(&(ncs->pppoe[i].ppp_state),
				 _if_tab[ival].state,
				 sizeof(PPPState));
	}
 #endif
} //repl_getCurrentNetworkConfig()

_dlp_defs_nodebug
void rupl_savenetworkparameters(void)
{
   auto int rc;
   auto ruplNetworkPowerOnParameters params;
   auto ruplNetworkPowerOnParameters savedparams;

	// clear out structures
   memset((void*)&params, 0, sizeof(params));
   memset((void*)&savedparams, 0, sizeof(savedparams));

   // load NetConfSave structure
	repl_getCurrentNetworkConfig(&params.configuration);
   rc = rupl_loadnetworkparameters(&savedparams);

	// If dlm_loadnetworkparameters failed (stored checksum of savedparams
   // structure did not match the calculated checksum) or if the saved
   // configuration does not match the current configuration, save the current
   // configuration.
	if(!rc || memcmp(&savedparams.configuration,
   					  &params.configuration,
                    sizeof(params.configuration)) != 0)
   {
      // set type field for structure
      params.type     = RUPL_TYPE_USERBLOCK_NW_PARAM;
	   params.checksum = rupl_dochecksum((void*)&params,
   								sizeof(ruplNetworkPowerOnParameters) -
                           sizeof(params.checksum));

		writeUserBlock(RUPL_TYPE_USERBLOCK_NW_PARAM_OFS, &params, sizeof(params));
   }
}
#endif	// #ifdef DCRTCP

/*** BeginHeader rupl_serial_flash_write */
/* _START FUNCTION DESCRIPTION ********************************************
rupl_serial_flash_write                     <REMOTEUPLOADDEFS.LIB>

SYNTAX: 			int rupl_serial_flash_write(unsigned long dest, void* source,
                                    		 unsigned int len);

DESCRIPTION:   This function writes len bytes from the root buffer source to
               the address specified by dest on the serial flash.  This function
               determines the page and the offset within the page that
               corresponds to the destination address.

PARAMETER1:    Linear destination address on the serial flash.

PARAMETER2:    Root buffer containing data to write to the serial flash.

PARAMETER3:    Length of the root buffer to write to the serial flash.

RETURN VALUE:  0    Write to serial flash successful.
					< 0  Error returned from serial flash driver.
                    See sf_pageToRAM, sf_writeRAM, and sf_RAMToPage for
                    details.

END DESCRIPTION **********************************************************/

int rupl_serial_flash_write(unsigned long dest, void* source, unsigned int len);
/*** EndHeader */

_dlp_defs_nodebug
int rupl_serial_flash_write(unsigned long dest, void* source, unsigned int len)
{
   auto unsigned long offset;
	auto unsigned int  pagenum;
   auto unsigned int  pageofs;
   auto unsigned int  writelen;
   auto int			    rc;
   auto char* 		    sptr;

	sptr   = (char *)source;
   offset = dest;
   rc     = 0;

   while(len)
   {
		// convert address into page address
      pagenum = (int)(offset / sf_blocksize);
      pageofs = (int)(offset % sf_blocksize);
      if((len + pageofs) <= sf_blocksize)
      {
         writelen = len;
      }
      else
      {
			writelen = sf_blocksize - pageofs;
      }
		// Bring in the serial flash page
      if(rc = sf_pageToRAM(pagenum) < 0)
      	return rc;
      // Write data to the page
      if(rc = sf_writeRAM(sptr, pageofs, writelen) < 0)
      	return rc;
      // Write the page back to serial flash
      if(rc = sf_RAMToPage(pagenum) < 0)
      	return rc;

      len    -= writelen;
      sptr   += writelen;
      offset += writelen;
   }
   return rc;
}

/*** BeginHeader rupl_serial_flash_read */
/* _START FUNCTION DESCRIPTION ********************************************
rupl_serial_flash_read                       <REMOTEUPLOADDEFS.LIB>

SYNTAX: 			void rupl_serial_flash_read(void* source, unsigned long dest,
														 unsigned int len);

DESCRIPTION:   This function reads len bytes from the address specified by dest
					on the serial flash to the root buffer specified in source.  This
               function determines the page and the offset within the page that
               corresponds to the destination address.

PARAMETER1:		Root buffer to receive data from the serial flash.

PARAMETER2:		Linear destination address on the serial flash to read from.

PARAMETER3:    Length of the root buffer to.

RETURN VALUE:  None.

END DESCRIPTION **********************************************************/

void rupl_serial_flash_read(void* source, unsigned long dest, unsigned int len);
/*** EndHeader */

_dlp_defs_nodebug
void rupl_serial_flash_read(void* source, unsigned long dest, unsigned int len)
{
   auto unsigned long offset;
	auto unsigned int  pagenum;
   auto unsigned int  pageofs;
   auto unsigned int  readlen;
   auto char* 		    sptr;

	sptr   = (char *)source;
   offset = dest;

   while(len)
   {
		// convert address into page address
      pagenum = (int)(offset / sf_blocksize);
      pageofs = (int)(offset % sf_blocksize);
      if((len + pageofs) <= sf_blocksize)
      {
         readlen = len;
      }
      else
      {
			readlen = sf_blocksize - pageofs;
      }
      // Bring in the serial flash page
      sf_pageToRAM(pagenum);
      // Read the page into the root buffer
      sf_readRAM(sptr, pageofs, readlen);

      len    -= readlen;
      sptr   += readlen;
      offset += readlen;
   }
}

/*** BeginHeader rupl_serial_flash_align_page */
/* _START FUNCTION DESCRIPTION ********************************************
rupl_serial_flash_align_page                  <REMOTEUPLOADDEFS.LIB>

SYNTAX:        int rupl_serial_flash_align_page(unsigned long offset);

DESCRIPTION:   This function takes a linear offset into serial flash
					and returns the number of bytes left in the page corresponding
               to the given address

PARAMETER:     Linear offset in serial flash

RETURN VALUE:  Number of bytes left in the page for the given offset.

END DESCRIPTION **********************************************************/

int rupl_serial_flash_align_page(unsigned long offset);
/*** EndHeader */

_dlp_defs_nodebug
int rupl_serial_flash_align_page(unsigned long offset)
{
	return sf_blocksize - (int)(offset % sf_blocksize);
}

/*** BeginHeader rupl_valid_image */
/* _START FUNCTION DESCRIPTION ********************************************
rupl_valid_image                              <REMOTEUPLOADDEFS.LIB>

SYNTAX:        int rupl_valid_image(unsigned long address, unsigned long length,
												char loadtoram, ldrRAMLoadInfo loadinfo,
                                    unsigned int* calccrc);

DESCRIPTION:   This function expects address to be the address of the first byte
					of the image in flash, and length to be the length of the image
               (not including the crc information stored at the end of the
               binary image).

               If loadtoram is nonzero, this function will also load the image
               to serial flash as it is being verified.  If verification fails,
               the image should not be run. If verification succeeds, the image
               is ready to execute.

PARAMETER1:		Starting address of image to check - address can be in either
					parallel or serial flash.

PARAMETER2:		Length of the image to check

PARAMETER3:		If this parameter is non-zero, then the image will be loaded into
 					fast ram as it is verified.  If this parameter is non-zero and
               this function returns false, the image should NOT be executed.

PARAMETER4:		This structure gives this function information about memory
					layout, whether the image is stored in parallel flash or serial
               flash, etc.  See the structure definition for more details.

PARAMETER5:    The address of an integer in which the calculated crc is stored
 					and returned.

RETURN VALUE: 	True if calculated crc of binary image is equal to the
               crc stored at the end of the image, false otherwise.

END DESCRIPTION **********************************************************/

int rupl_valid_image(unsigned long address, unsigned long length,
               char loadtoram, ldrRAMLoadInfo loadinfo, unsigned int* calccrc);
/*** EndHeader */

_dlp_defs_nodebug
int rupl_valid_image(unsigned long address, unsigned long length,
               char loadtoram, ldrRAMLoadInfo loadinfo, unsigned int* calccrc)
{
   auto ldrImageInfo  imgInfo;
   auto unsigned long imgInfoAddr;
   auto unsigned long imgPtr;
   auto unsigned int  imgCrc;
   auto unsigned int  imgCrcBlocks;
   auto unsigned int  i, j, kdbg;
   auto unsigned int  imgLeftOver;
   auto char*			 sfbptr;
	auto int			    numCrcBlocks;
   auto int			    crcLeftOver;
   auto int 			 firstpage;
   auto int			    sfbufsize;
   auto int			    fpglength;

	firstpage = 1;

   // Clear out the imgInfo struct and calculate the address where it resides
   // (the struct comes immediately after the executable portion of the image).
	memset((void*)&imgInfo, 0, sizeof(imgInfo));
	imgInfoAddr = address + length;

	// Grab the struct from either serial or parallel flash
	if(loadinfo.loadfromsflash)
     	rupl_serial_flash_read((void*)&imgInfo, imgInfoAddr, sizeof(imgInfo));
   else
	   xmem2root((void*)&imgInfo, imgInfoAddr, sizeof(imgInfo));

   // calculate crc for image
	imgCrcBlocks = (int)(length / (long)loadinfo.sfbufsize);
	imgCrc     	 = 0;
   imgPtr       = address;
	if(loadinfo.loadfromsflash)
   {
   	// If loading from serial flash, determine the number of bytes which
      // reside on the first page of serial flash where the image is stored.
      // This will allow all following reads from the serial flash to be single
      // full page accesses.
	   fpglength = rupl_serial_flash_align_page(imgPtr);
	   if(fpglength > loadinfo.sfbufsize)
   		fpglength = loadinfo.sfbufsize;
   }
   else
   {
   	fpglength = loadinfo.sfbufsize;
   }

   // We've determined how many loadinfo.sfbufsize blocks need to be read in
   // order to run a crc on the entire image.  This loop takes care of reading
   // all of the blocks of size loadinfo.sfbufsize.  If there is any remaining
   // portion of the image, it will be accounted for after this loop is done.
	for(i = 0; i < imgCrcBlocks; i++)
   {
      sfbufsize = firstpage ? fpglength : loadinfo.sfbufsize;

		// if bit 30 is set in address, the image is stored in serial flash
		if(loadinfo.loadfromsflash)
      {
   		rupl_serial_flash_read(loadinfo.sflashbuffer, imgPtr, sfbufsize);
      }
      else
      {
	   	xmem2root(loadinfo.sflashbuffer, imgPtr, sfbufsize);
      }

		// If loading image to ram, and the current destination address does not
      // fall within the root data area, copy image contents to ram.
      if(loadtoram && loadinfo.imgdestination < loadinfo.physdatastart)
      {
      	// Current destination address is before root data area, ok to write
			if((loadinfo.physdatastart - loadinfo.imgdestination) < sfbufsize)
         {
				root2xmem(loadinfo.imgdestination, loadinfo.sflashbuffer,
                      (int)(loadinfo.physdatastart - loadinfo.imgdestination));
         }
         else
         {
	        	root2xmem(loadinfo.imgdestination, loadinfo.sflashbuffer,
                      sfbufsize);
         }
      }
      else if(loadtoram)
      {
			if(loadinfo.imgdestination >= loadinfo.physdatastart)
         {
      		if(loadinfo.imgdestination > loadinfo.physdataend)
            {
               // Current destination address is after root data area, ok to write
               root2xmem(loadinfo.imgdestination, loadinfo.sflashbuffer, sfbufsize);
            }
            // Need to determine if current buffer straddles the end of data
            // and the start of code, and write the code portion if necessary
            else if((loadinfo.imgdestination + sfbufsize) >
                     loadinfo.physdataend)
            {
               root2xmem(loadinfo.physdataend + 1,
                         loadinfo.sflashbuffer +
                            (int)((loadinfo.physdataend + 1) -
                            loadinfo.imgdestination),
                         (int)((loadinfo.imgdestination + sfbufsize) -
                            (loadinfo.physdataend + 1)));
            }
         }
      }
		// crc check the contents of loadinfo.sflashbuffer
      sfbptr = loadinfo.sflashbuffer;
      // We've read a buffer of size loadinfo.sflashbuffer and have possibly
      // written it to RAM, now do the CRC for this block.  The ldrgetcrc
      // function can only take 255 bytes at a time, so the block is broken up
      // into 255 byte chunks for passing to ldrgetcrc.  If there are any bytes
      // leftover, i.e. 255 does not evenly divide loadinfo.sflashbuffer, then
      // the remaining bytes will be accounted for after this loop.
      numCrcBlocks = sfbufsize / 255;
      for(j = 0; j < numCrcBlocks; j++)
      {
	      imgCrc = ldrgetcrc(sfbptr, 255, imgCrc);
       	sfbptr += 255;
      }
      crcLeftOver = sfbufsize % 255;
      if(crcLeftOver)
	      imgCrc = ldrgetcrc(sfbptr, crcLeftOver, imgCrc);
		loadinfo.imgdestination += sfbufsize;
      imgPtr                  += sfbufsize;
      firstpage                = 0;
   }
   imgLeftOver = (int)((length + (loadinfo.sfbufsize - fpglength)) %
                 (long)loadinfo.sfbufsize);

	// If there is a non-full page of data left, read it into the flash buffer
	if(imgLeftOver)
   {
      if(loadinfo.loadfromsflash)
         rupl_serial_flash_read(loadinfo.sflashbuffer, imgPtr, imgLeftOver);
      else
         xmem2root(loadinfo.sflashbuffer, imgPtr, imgLeftOver);
   }

   if(loadtoram)
   {
	   // Load last bytes into fast ram
   	if(loadinfo.loadfromsflash)
			root2xmem(loadinfo.imgdestination, loadinfo.sflashbuffer, imgLeftOver);
      else
      	xmem2xmem(loadinfo.imgdestination, imgPtr, imgLeftOver);
   }

   // Crc check last bytes
   sfbptr = loadinfo.sflashbuffer;
   numCrcBlocks = imgLeftOver / 255;
   for(j = 0; j < numCrcBlocks; j++)
   {
      imgCrc = ldrgetcrc(sfbptr, 255, imgCrc);
      sfbptr += 255;
   }
   crcLeftOver = imgLeftOver % 255;
   if(crcLeftOver)
      imgCrc = ldrgetcrc(sfbptr, crcLeftOver, imgCrc);

	if(calccrc)
   	*calccrc = imgCrc;
   return (imgCrc == imgInfo.crc);
}

/*** BeginHeader ldrgetcrc */
/* _START FUNCTION DESCRIPTION ********************************************
ldrgetcrc                                     <REMOTEUPLOADDEFS.LIB>

SYNTAX:			root int ldrgetcrc(char *Data, char count, int accum);

DESCRIPTION:   This function is copied directly from getcrc in math.lib.  See
					description in math.lib for full information.

END DESCRIPTION **********************************************************/

root int ldrgetcrc(char *Data, char count, int accum);
/*** EndHeader */

#asm root _dlp_defs_nodebug
ldrgetcrc::
	ld 	hl,0002   			; locate first 2 byte argument
	add 	hl,sp
	ld 	e,(hl)
	inc 	hl
	ld 	d,(hl)
	push	de    				; de has the address of the data
	inc 	hl     				; two more increment get the second 1 byte argument
	ld 	c,(hl)  				;  c has the number of counts
	inc	 hl     				; now pointing to the low byte of accum
	inc 	hl
	ld 	a,(hl)  				; a has the low byte of the accum
	inc 	hl
	ld 	h,(hl)  				; h has the high byte of the accum
	ld 	l,a     				; l has the low byte of the accum
.do_data:               		; compute crc for (de+1) bytes of data
	pop 	de     				;
	ld 	a,(de)  				; load first data
	inc 	de     				; update to next memory location
	push 	de    				; keep last memory location
	ld 	d,a     				; use d for current data
	ld 	b,8     				; rotate and xor data 8 times
.eight_times:
	ld 	a,h     				; xor data to accum
	xor 	d
	rlca
	jr 	nc,.no_poly  		; no carry, no need to xor polynomial
	add 	hl,hl
	ld 	a,0x10      		; xor 0x1021 to accum
	xor 	h
	ld 	h,a
	ld 	a,0x21
	xor 	l
	ld 	l,a
	jr 	.__rotate_data
.no_poly:                	; only need to shift accum
	add 	hl,hl
.__rotate_data:
	xor 	a
	rl 	d
	djnz 	.eight_times
	dec 	c
	jr 	nz,.do_data
	pop 	de    				; pop one last time to balance loop
	ret
#endasm

/*** BeginHeader rupl_dochecksum */
/* _START FUNCTION DESCRIPTION ********************************************
rupl_dochecksum                               <REMOTEUPLOADDEFS.LIB>

SYNTAX:			xmem unsigned int rupl_dochecksum(void* data, int length);

DESCRIPTION:	Calculates a simple byte by byte checksum over the length of
					data.

PARAMETER1:		Pointer to a data buffer to checksum.

PARAMETER2:		The length of the data buffer.

RETURN VALUE:	The sum of all bytes in the buffer.

END DESCRIPTION **********************************************************/

xmem unsigned int rupl_dochecksum(void* data, int length);
/*** EndHeader */

_dlp_defs_nodebug
xmem unsigned int rupl_dochecksum(void* data, int length)
{
	auto int i;
   auto int checksum;
   auto char* sptr;

   checksum = 0;
   sptr = (char*)data;
   for(i = 0; i < length; i++)
   {
		checksum += *(sptr + i);
   }
	return checksum;
}


/*** BeginHeader rupl_switch_to_loader */
/* _START FUNCTION DESCRIPTION ********************************************
rupl_switch_to_loader                         <REMOTEUPLOADDEFS.LIB>

SYNTAX:			root void rupl_switch_to_loader();

DESCRIPTION:	This function copies bank switching code to the top of ram
					and then jumps to the copied code.  The end result is that
               the flash resident loader will begin executing.

RETURN VALUE:	None.  This function does not return.

END DESCRIPTION **********************************************************/

root void rupl_switch_to_loader();
/*** EndHeader */

#asm _dlp_defs_nodebug
rupl_RunLoaderInFlash::
;; This code is copied to the FAST_RAM_COMPILE mode flash write buffer at the
;;  top of the MB2CR quadrant, and is run from there.
;;
;; Set up the rest of the FAST_RAM_COMPILE physical memory mapping.
;; This must be done before the BIOS is restarted by the "jp 0"
;;  instruction below, since we now want to run the program in RAM and
;;  not in flash.

		;; map bank 0 to the Flash on /CS0
		ld		a, FLASH_WSTATES | CS_FLASH
ioi	ld		(MB0CR), a

		;; Jump to address 0 to restart loader in flash
		jp		0

rupl_EndRunLoaderInFlash::
#endasm

nodebug
root void rupl_switch_to_loader()
{
	// copy switch function to fast RAM mode's flash write buffer.
#asm _dlp_defs_nodebug
		;;  Copy the SwitchToLoader function into the fast RAM mode's flash
		;;  write buffer.
		;; (This assumes we're running in fast RAM in the MB0CR quadrant!)

		ld		b, rupl_EndRunLoaderInFlash - rupl_RunLoaderInFlash + 1	; get function's size
		srl	b										; LDP moves two bytes at a time
		ld		a, 0x07								; init destination address bits 16-19
		ex		af, af'								; swap destination bits 16-19 into A'
		ld		ix, 0xF000							; init destination address bits 00-15
		xor	a										; init source address bits 16-19
		ld		iy, rupl_RunLoaderInFlash		; init destination address bits 00-15

.smallloop::
		ldp	hl, (iy)								; get word from memory at A:IY into HL
		inc	iy										; increment IY to next byte address
		inc	iy										; increment IY to next word address
		ex		af, af'								; swap destination bits 16-19 into A
		ldp	(ix), hl								; put word from HL into memory at A:IX
		ex		af, af'								; swap source bits 16-19 back into A
		inc	ix										; increment IX to next byte address
		inc	ix										; increment IX to next word address
		djnz	.smallloop							; decrement count, loop if nonzero

		ljp	0x71E000								; run switch routine at 0x7F000
#endasm
}

/*** BeginHeader */
#endif
/*** EndHeader */