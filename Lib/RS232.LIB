/*** Beginheader */
#ifndef __RS232_LIB
#define __RS232_LIB
#define RS232_FAIL -1
#define RS232_CR   13
#define RS232_LF   10
#define RS232_BASEFREQ 614400.0
#define PARAM_7BIT		 0x0001
#define PARAM_8BIT  		 0x0000
#define PARAM_EPARITY    0x0001
#define PARAM_OPARITY    0x0002
#define PARAM_2STOP		 0x0003
#define PARAM_NOPARITY   0x0000
#define SER_PARITY_ERROR 	0x01
#define SER_OVERRUN_ERROR 	0x02
#define SER_OVERFLOW_ERROR 0x04

#define RS232_RXC "RX-%c : %02x                    \t- %c\n"
#define RS232_TXC "TX-%c : %02x                    \t- %c\n"

/*** endheader */

/* START LIBRARY DESCRIPTION *********************************************
RS232.LIB

OVERVIEW
	The interface is designed to to provide the users with a set of functions
	that send and receive entire blocks of data without yielding to other
	tasks, and a set of single user cofunctions that send and receive data,
	but yield to other tasks.

NAMING CONVENTION
	The naming convention is serXfn:
	ser - serial
	X   - the port being used: A,B,C, or D
	fn  - the function being implemented
	Example: serBgetc() is the serial port B function getc(), which returns a
	 character.

DEFINING BUFFER SIZES
	xINBUFSIZE      - read buffer size where x is A,B,C or D
	xOUTBUFSIZE  - write buffer size where x is A,B,C or D
	The user must define the buffer sizes for each port being used to be
	a power of 2 minus 1 with a macro, e.g. #define DINBUFSIZE 31.
	The size of 2^n - 1 enables masking for fast roll over calculations.
	The value affects how frequently control yields to other tasks in
	cofunctions. If no value of 2^n - 1 is defined, a default of 31 is used,
	and a compiler warning is given.

DESCRIPTION:
	This library contains serial interface functions for the Rabbit.
   It contains 2 types of interface functions:
     1) Blocking
       a) Complete their entire serial tasks before returning.
       b) Do not require the use of costatements or cofunctions.
       c) Simple to use but can hog the processor.

       int serXgetc();
       int serXread(void *data, int length, unsigned long tmout);
       int serXputc(int c);
       int serXputs(char *s);
       int serXwrite(void *data, int length);

     2) Single User CoFunction
       a) Yield to other tasks whenever circular buffer is full or empty.
       b) Must be called within costatements.
       c) Require more learning to use properly but share processing better.

       scofunc int  cof_serXgetc();
       scofunc int  cof_serXgets(char *s, int length, unsigned long tmout);
       scofunc int  cof_serXread(void *data, int length, unsigned long tmout);
       scofunc void cof_serXputc(int c);
       scofunc void cof_serXputs(char *str);
       scofunc void cof_serXwrite(void *data, int length);

     3) Buffer functions
       These functions  act upon or report status of the circular
       transmit/receive buffers.

       int  serXpeek();
       void serXrdFlush();
       void serXwrFlush();
       int  serXrdFree();
       int  serXwrFree();
       int  serXrdUsed();

SUPPORT LIB'S:
   COFUNC.LIB
   VDRIVER.LIB
END DESCRIPTION **********************************************************/

/*** Beginheader _RS232_echo */
void _RS232_echo(char *, int, char *);
/*** endheader */

nodebug void _RS232_echo(char *data, int length, char *hdr)
{
	char ch, k;
	int i, j;
   const static char fmt[11] = " \t  \t  \t- ";

   for (i = j = 0; i < length; ) {
	   printf("%s : ", hdr);
      do {
	      printf("%02x ", *data++);
      } while ((++i < length) && (i & 7));
      k = (i & 7 ? i & 7 : 8);
      data -= k;
      puts(fmt + (k - 1));
      do {
      	ch = *data++;
         if (ch < ' ' || ch > '~') ch = '.';
	      putchar(ch);
      } while ((++j < length) && (j & 7));
      putchar(10);
   }
}

//************************************************************************
//****************************** PORT A **********************************
//************************************************************************

/*** Beginheader serAgetc */
int  serAgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAgetc                     <RS232.LIB>

SYNTAX:	      int serAgetc();

DESCRIPTION:   Get next available character from serial port A read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	success: the next character in the low byte, 0 in the high byte
               failure: the integer -1

END DESCRIPTION **********************************************************/

nodebug int serAgetc()
{
   static int n;

   if (cbuf_rdlock(spa_icbuf))
   {
      n = cbuf_getch(spa_icbuf);
      if (artscts && cbuf_used(spa_icbuf) <= serArtsLo)
      {
      	(*a_rtson)();
      }
      cbuf_rdunlock(spa_icbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_RXC, 'A', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_A
	   if (n >= 0) printf(RS232_RXC, 'A', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = -1;
   }
   return n;
}

/*** Beginheader serAread */
int  serAread(void *data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAread                   <RS232.LIB>

SYNTAX:		   int serAread(void *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from serial port A or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port A
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port A

END DESCRIPTION **********************************************************/

nodebug int serAread(void *data, int length, unsigned long tmout)
{
   static int  n, nread, timedOut;
   static char *p;
   static unsigned long chtm;

   p = (char *)data;
   nread = timedOut = 0;

   if (cbuf_rdlock(spa_icbuf))
   {
      chtm = MS_TIMER;
      while (nread < length && !timedOut)
      {
      	// once in, finish or timeout
         if ((n = cbuf_get(spa_icbuf, p + nread, length - nread)) > 0)
         {
      		if (artscts && cbuf_used(spa_icbuf) <= serArtsLo)
      		{
      			(*a_rtson)();
      		}
            chtm = MS_TIMER;
            nread += n;
         }
         else
         {
            if (nread)
            {
               if (MS_TIMER - chtm >= tmout)
               {
                  timedOut = 1;
               }
            }
            else
            {
               break;   // just break out of while if
               			// we have not yet begun to read data
            }
         }
      }
	   cbuf_rdunlock(spa_icbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "TX-A");
#else
#ifdef RS232_MONITOR_A
	_RS232_echo(p, nread, "TX-A");
#endif
#endif
   return nread;
}

/*** Beginheader serApeek */
int serApeek();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serApeek                   <RS232.LIB>

SYNTAX:		   int serApeek();

DESCRIPTION:   returns the 1st character of the data in the A input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not
END DESCRIPTION **********************************************************/

nodebug int serApeek()
{
  return (int)cbuf_peek(spa_icbuf);
}

/*** Beginheader serAputc */
int serAputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAputc                     <RS232.LIB>

SYNTAX:	      int serAputc(char c);

DESCRIPTION:   Write a character to serial port A write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port A write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

END DESCRIPTION **********************************************************/

nodebug int serAputc(int c)
{
   static int n;

   if (cbuf_wrlock(spa_ocbuf))
   {
      n = cbuf_putch(spa_ocbuf, c);
      if (n)
      {
      	spa_starttx();
		}
      cbuf_wrunlock(spa_ocbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_TXC, 'A', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_A
	   if (n >= 0) printf(RS232_TXC, 'A', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = 0;
   }
   return n;
}

/*** Beginheader serAputs */
int serAputs(char *s);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAputs                     <RS232.LIB>

SYNTAX:     	int serAputs(char* s);

DESCRIPTION:   Calls serAwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port A.

END DESCRIPTION **********************************************************/

nodebug int serAputs(char *s)
{
   return serAwrite(s, strlen(s));
}

/*** Beginheader serAwrite */
int serAwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAwrite                   <RS232.LIB>

SYNTAX:		   int serAwrite(void *data, int length);

DESCRIPTION:   Transmits length bytes to serial port A.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port A
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port A.

END DESCRIPTION **********************************************************/

nodebug int serAwrite(void *data, int length)
{
   static int bytesleft;
   static char *p;

   p = (char *)data;
   bytesleft = length;
   if (cbuf_wrlock(spa_ocbuf))
   {
      while (bytesleft)
      {
         bytesleft -= cbuf_put(spa_ocbuf, p+(length-bytesleft), bytesleft);
         spa_starttx();
      }
      cbuf_wrunlock(spa_ocbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, length - bytesleft, "TX-A");
#else
#ifdef RS232_MONITOR_A
	_RS232_echo(p, length - bytesleft, "TX-A");
#endif
#endif
   return length - bytesleft;
}

/*** Beginheader cof_serAgetc */
scofunc int cof_serAgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serAgetc                   <RS232.LIB>

SYNTAX:		   int cof_serAgetc();

DESCRIPTION:   Yields to other tasks until a character is read from port A.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port A

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serAgetc()
{
	static int c;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spa_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spa_icbuf));
	havelock=1;

	waitfor((c=cbuf_getch(spa_icbuf)) != -1);

   if (artscts && cbuf_used(spa_icbuf) <= serArtsLo)
   {
   	(*a_rtson)();
   }

	cbuf_rdunlock(spa_icbuf);
#ifdef RS232_MONITOR
   if (c >= 0) printf(RS232_RXC, 'A', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_A
   if (c >= 0) printf(RS232_RXC, 'A', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
	return c;
}

/*** Beginheader cof_serAgets */
scofunc int cof_serAgets(char *s, int max, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serAgets                   <RS232.LIB>

SYNTAX:		   int cof_serAgets(char *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port A until a null terminator, carriage
					return or linefeed is read, max characters are read, or until
					tmout milliseconds transpires between characters after the
					first one is read. It yields to other tasks for as long as
					the input buffer is locked or whenever the buffer becomes
					empty as characters are read. s will always be null terminated
					upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serAgets(char *s, int max, unsigned long tmout)
{
   static int  c, started, timedOut;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spa_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spa_icbuf));
   havelock=1;

   p = s;
   c = started = timedOut = 0;

   while (c != RS232_CR && p-s < max && !timedOut)
   {
      if ((c = cbuf_getch(spa_icbuf)) != -1)
      {
         switch (c)
         {
            case  8: if (p > s) --p; break;
            case  0:
            case RS232_LF: c = RS232_CR;
            case RS232_CR: break;
            default: *p++ = c; break;
         }

   		if (artscts && cbuf_used(spa_icbuf) <= serArtsLo)
   		{
   			(*a_rtson)();
   		}

         if (!started) started = 1;
         chtm = MS_TIMER;  // timeout starts anew
      }
      else
      {
         if (started && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   *p=0;  // null terminate whether timed out, max length, or normal
	cbuf_rdunlock(spa_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(s, p - s, "RX-A");
#else
#ifdef RS232_MONITOR_A
	_RS232_echo(s, p - s, "RX-A");
#endif
#endif
   return !timedOut; //
}

/*** Beginheader cof_serAread */
scofunc int cof_serAread(void* data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serAread                   <RS232.LIB>

SYNTAX:		   int cof_serAread(void* data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port A or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serAread(void* data, int length, unsigned long tmout)
{
   static int nread, timedOut;
   static int n;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spa_icbuf);
	}

   p = (char *)data;
	havelock=0;
	waitfor(cbuf_rdlock(spa_icbuf));
   havelock=1;

   n = nread = timedOut = 0;
   chtm = MS_TIMER;
   while(nread < length && !timedOut)
   {
      if ((n = cbuf_get(spa_icbuf, p + nread, length - nread)) > 0)
      {
         nread += n;
   		if (artscts && cbuf_used(spa_icbuf) <= serArtsLo)
   		{
   			(*a_rtson)();
   		}
         if(nread < length)
         {
            yield;
            chtm = MS_TIMER;      // timeout starts anew
         }
      }
      else
      {
         if (nread && (MS_TIMER - chtm) >= tmout)
         {
         	timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   cbuf_rdunlock(spa_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-A");
#else
#ifdef RS232_MONITOR_A
	_RS232_echo(p, nread, "RX-A");
#endif
#endif
   return nread;
}

/*** Beginheader cof_serAputc */
scofunc void cof_serAputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serAputc                   <RS232.LIB>

SYNTAX:		   void cof_serAputc(int c);

DESCRIPTION:   Writes a character to the A port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serAputc(int c)
{
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spa_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spa_ocbuf));
   havelock=1;

	waitfor(cbuf_putch(spa_ocbuf,c));

	spa_starttx();
	cbuf_wrunlock(spa_ocbuf);
#ifdef RS232_MONITOR
	if (c >= 0) printf(RS232_TXC, 'A', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_A
	if (c >= 0) printf(RS232_TXC, 'A', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
}

/*** Beginheader cof_serAputs */
scofunc void cof_serAputs(char *str);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serAputs                   <RS232.LIB>

SYNTAX:		   void cof_serAputs(char *str);

DESCRIPTION:   Writes a null terminated string to the A port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serAputs(char *str)
{
	static int bytesleft,length;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spa_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spa_ocbuf));
   havelock=1;

	bytesleft=length=strlen(str);

	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spa_ocbuf,str+(length-bytesleft),bytesleft);
		spa_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spa_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(str, length, "TX-A");
#else
#ifdef RS232_MONITOR_A
	_RS232_echo(str, length, "TX-A");
#endif
#endif
}

/*** Beginheader cof_serAwrite */
scofunc void cof_serAwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serAwrite                   <RS232.LIB>

SYNTAX:		   void cof_serAwrite(void *data, int length);

DESCRIPTION:   Writes length bytes to the A port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serAwrite(void *data, int length)
{
	static int bytesleft;
   static char *v;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spa_ocbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spa_ocbuf));
   havelock=1;

   v = (char *)data;
	bytesleft=length;
	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spa_ocbuf,v+(length-bytesleft),bytesleft);
		spa_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spa_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(v, length, "TX-A");
#else
#ifdef RS232_MONITOR_A
	_RS232_echo(v, length, "TX-A");
#endif
#endif
}

/*** Beginheader serAflowcontrolOn */
void serAflowcontrolOn();
/*** endheader */

//defaults for flow control RTS/CTS
#ifndef SERA_RTS_PORT
#define SERA_RTS_PORT PBDR
#warnt "SERA_RTS_PORT not defined: defaulting to PBDR"
#endif

#ifndef SERA_RTS_SHADOW
#define SERA_RTS_SHADOW PBDRShadow
#warnt "SERA_RTS_SHADOW not defined: defaulting to PBDRShadow"
#endif

#ifndef SERA_RTS_BIT
#define SERA_RTS_BIT 6
#warnt "SERA_RTS_BIT not defined: defaulting to 6"
#endif

#ifndef SERA_CTS_PORT
#define SERA_CTS_PORT PBDR
#warnt "SERA_CTS_PORT not defined: defaulting to PBDR"
#endif

#ifndef SERA_CTS_BIT
#define SERA_CTS_BIT 6
#warnt "SERA_CTS_BIT not defined: defaulting to 6"
#endif

#asm root
spa_checkcts_fc::
	 bool	hl
;ioi ld 	a, (SERA_CTS_PORT)
	IOREAD_A(SERA_CTS_PORT)
	 and	1 << SERA_CTS_BIT
	 ld	L, a
	 ret

spa_rtsoff_fc::
	 ld	 a, (SERA_RTS_SHADOW)
	 set	 SERA_RTS_BIT, a		;set RTS high (inactive)
	 ld	 (SERA_RTS_SHADOW), a
;ioi ld	 (SERA_RTS_PORT), a
	IOWRITE_A(SERA_RTS_PORT)
	 ret

spa_rtson_fc::
	 ld	 a, (SERA_RTS_SHADOW)
	 res   SERA_RTS_BIT, a		;set RTS low (active)
	 ld	 (SERA_RTS_SHADOW), a
;ioi ld	 (SERA_RTS_PORT), a
	IOWRITE_A(SERA_RTS_PORT)
	 ret

#endasm

/* START FUNCTION DESCRIPTION ********************************************
serAflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serAflowcontrolOn();

DESCRIPTION:   Turns on hardware flow control for channel A. This enables two
					digital lines that handle flow control, CTS(clear to send)
					and RTS(ready to send).
					CTS is an input that will be pulled active low by the other
					system when it is ready to receive data. The RTS signal
					is an output that the system uses to indicate that it is
					ready to receive data. It is driven low when data can be
					received.
					If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERA_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERA_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERA_RTS_BIT - the bit number for the RTS line
 					SERA_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERA_CTS_BIT - the bit number for the CTS line

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serAflowcontrolOn()
{
	artscts = 1;
	//set flow control ISR functions
	a_checkctsfunc = spa_checkcts_fc;
	a_rtsoff = spa_rtsoff_fc;
	a_rtson = spa_rtson_fc;
	serArtsLo = (int)(AINBUFSIZE * 0.2);
	serArtsHi = (int)(AINBUFSIZE * 0.8);
	// turn on RTS if buffer is below 80%
	if (serArdUsed() < serArtsHi) (*a_rtson)();
}

/*** Beginheader serAflowcontrolOff */
void serAflowcontrolOff();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serAflowcontrolOff();

DESCRIPTION:   Turns off hardware flow control for channel A.
               This function is non-reentrant.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serAflowcontrolOff()
{
	artscts = 0;
}

/*** Beginheader serAparity */
void serAparity(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAparity                   <RS232.LIB>

SYNTAX:		   void serAparity(int state);

DESCRIPTION:   Sets parity type for channel A. This function is non-reentrant.

PARAMETER1:		A bit mask for selecting parity mode
					PARAM_EPARITY	0x01
					PARAM_OPARITY	0x02
					PARAM_2STOP 	0x03
					PARAM_NOPARITY 0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serAparity(int state)
{
	if (state) {
		if (state == PARAM_OPARITY)
		{
			aparity = 1;
			atwostop = 0;
			aparitytype = 0;
		}
		else if (state == PARAM_EPARITY)
		{
			aparity = 1;
			atwostop = 0;
			aparitytype = 1;
		}
		else
		{
			atwostop = 1;
			aparity = 0;
		}
	}
	else
	{
		aparity = 0;
		atwostop = 0;
	}
	if(asevenbit && !aparity && !atwostop)
	{
		BitWrPortI(SACR, &SACRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SACR, &SACRShadow, 0, 2);
	}
}

/*** Beginheader serAdatabits */
void serAdatabits(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAdatabits                   <RS232.LIB>

SYNTAX:		   void serAdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel A.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
					PARAM_7BIT	0x01
					PARAM_8BIT	0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serAdatabits(int state)
{
	if (state == PARAM_7BIT)
	{
		asevenbit = 1;
	}
	else
	{
		asevenbit = 0;
	}
	if(asevenbit && !aparity && !atwostop)
	{
		BitWrPortI(SACR, &SACRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SACR, &SACRShadow, 0, 2);
	}
}

/*** Beginheader serArdFree */
int serArdFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serArdFree                   <RS232.LIB>

SYNTAX:		   int serArdFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port A input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the A input buffer
END DESCRIPTION **********************************************************/

nodebug int serArdFree()
{
	return (int)cbuf_free(spa_icbuf);
}

/*** Beginheader serAwrFree */
int serAwrFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAwrFree                   <RS232.LIB>

SYNTAX:		   int serAwrFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port A transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the A transmit buffer
END DESCRIPTION **********************************************************/

nodebug int serAwrFree()
{
	return (int)cbuf_free(spa_ocbuf);
}

/*** Beginheader serArdUsed */
int serArdUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serArdUsed                   <RS232.LIB>

SYNTAX:		   int serArdUsed();

DESCRIPTION:   Returns the number of characters in the A input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the A input buffer
END DESCRIPTION **********************************************************/

nodebug int serArdUsed()
{
	return (int)cbuf_used(spa_icbuf);
}

/*** Beginheader serAwrUsed */
int serAwrUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAwrUsed                   <RS232.LIB>

SYNTAX:		   int serAwrUsed();

DESCRIPTION:   Returns the number of characters in the A output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the A output buffer
END DESCRIPTION **********************************************************/

nodebug int serAwrUsed()
{
   return (int)cbuf_used(spa_ocbuf);
}

/*** Beginheader serArdFlush */
void serArdFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serArdFlush                  <RS232.LIB>

SYNTAX:		   void serArdFlush();

DESCRIPTION:   Flushes the serial port A input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serArdFlush()
{
	cbuf_flush(spa_icbuf);
}

/*** Beginheader serAwrFlush */
void serAwrFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAwrFlush                  <RS232.LIB>

SYNTAX:		   void serAwrFlush();

DESCRIPTION:   Flushes the serial port A transmit buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serAwrFlush()
{
	cbuf_flush(spa_ocbuf);
}

/*** Beginheader serAclose */
void serAclose();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serAclose                   <RS232.LIB>

SYNTAX:		   void serAclose();

DESCRIPTION:   Disables the A serial port. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm xmem

serAclose::
    ld 	a, 0xc9
    ipset 1
#if _USER
c	 SetVectIntern(SERA_OFS/0x10, spa_dummyfunc);
#else
    ld	(INTVEC_BASE + SERA_OFS), a		; ret in first byte of spaisr_start
#endif

    ld    a,0x00        ; disable interrupts for port
	 ld    (SACRShadow),a
;ioi ld    (SACR),a
	IOWRITE_A(SACR)
#ifdef SERA_USEPORTD
    ld    a,(PDFRShadow)
    res	 ADRIVE_TXD, a    ;return to normal output
    ld    (PDFRShadow),a
;ioi ld    (PDFR),a
	IOWRITE_A(PDFR)
#else
    ld    a,(PCFRShadow)
    res	 ADRIVE_TXD, a    ;return to normal output
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
#endif

    ipres
    lret

#endasm

/*** Beginheader serArtsLo, serArtsHi, serAopen, serAgetError,
     spa_icbuf, spa_ocbuf */
extern int serArtsLo;
extern int serArtsHi;
int serAopen(long baud);
char serAgetError();
void spa_init();
root void spa_starttx();
root void aDisable();
root void aEnable();
root void spa_dummyfunc();
extern char spa_icbuf[];
extern char spa_ocbuf[];
extern char artscts;
extern char aparity;
extern char aparitytype;
extern char asevenbit;
extern char atwostop;
//pointers to flow control functions
extern int (*a_checkctsfunc)();
extern void (*a_rtsoff)();
extern void (*a_rtson)();
#define ADRIVE_TXD 6
extern char alongstop;
extern char aparityerror;
extern char aoverrun;
extern char aoverflow;
/*** endheader */

#undef AINBUFOK

#ifndef AINBUFSIZE
#define AINBUFSIZE 31
#warnt "AINBUFSIZE undefined, defaulting to 31"
#endif

#if (AINBUFSIZE & (AINBUFSIZE+1)) == 0
#define AINBUFOK 1
#endif

#ifndef AINBUFOK
#undef AINBUFSIZE
#define AINBUFSIZE 31
#warnt "AINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef AOUTBUFOK

#ifndef AOUTBUFSIZE
#define AOUTBUFSIZE 31
#warnt "AOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (AOUTBUFSIZE & (AOUTBUFSIZE+1)) == 0
#define AOUTBUFOK 1
#endif

#ifndef AOUTBUFOK
#undef AOUTBUFSIZE
#define AOUTBUFSIZE 31
#warnt "AOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char spa_icbuf[AINBUFSIZE+9];
char spa_ocbuf[AOUTBUFSIZE+9];

int  serArtsLo;
int  serArtsHi;
char alongstop;
char aparityerror;
char aoverrun;
char aoverflow;

char artscts;
char aparity;
char aparitytype;
char asevenbit;
char atwostop;
int (*a_checkctsfunc)();
void (*a_rtsoff)();
void (*a_rtson)();

/* START FUNCTION DESCRIPTION ********************************************
serAopen                   <RS232.LIB>

SYNTAX:		   int serAopen(long baud);

DESCRIPTION:   Opens the A serial port.
               This function is non-reentrant.

PARAMETER1:    baud : bits per second of data transfer

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

RELATED WORDS: serAgetc, serAgetc, serApeek,
               serAputs, serAwrite,
               cof_serAgetc, cof_serAgets, cof_serAread,
               cof_serAputc, cof_serAputs, cof_serAwrite
               serAclose

END DESCRIPTION **********************************************************/

nodebug int serAopen(long baud)
{
   static long divisor, ta1div;
   static float baudratio;
	static unsigned long t;

   ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	WrPortI(TACR, &TACRShadow, TACRShadow | 0x10);  // set 'use port A' bit
	}
	else
	{
   	WrPortI(TACR, &TACRShadow, TACRShadow & ~0x10); // clear bit
	}

	artscts = 0;
	asevenbit = 0;
	aparity = 0;
	aparitytype = 0;
	atwostop = 0;
	alongstop = 0;
	aparityerror = 0;
	aoverrun = 0;
	aoverflow = 0;
	//use the dummy versions of the flow control functions
	//all they do is return. They are placeholders in case flow control
	//enabled
	a_checkctsfunc = spa_dummyfunc;
	a_rtsoff = spa_dummyfunc;
	a_rtson = spa_dummyfunc;
	WrPortI(TAT4R, &TAT4RShadow, (char)divisor);
   cbuf_init(spa_icbuf,AINBUFSIZE);
   cbuf_init(spa_ocbuf,AOUTBUFSIZE);

   spa_init();
   t = MS_TIMER;
   // let baud timer time out before using port
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   cbuf_getch(spa_icbuf);
   cbuf_getch(spa_icbuf);
   baudratio = ((RS232_BASEFREQ*freq_divider) /
   	(32 * ((divisor & 0xff) + 1) + 0.5)) / (float)(baud * (ta1div + 1));
   return (baudratio > 0.95 && baudratio < 1.05);
}

/* START FUNCTION DESCRIPTION ********************************************
serAgetError                   <RS232.LIB>

SYNTAX:		   char serAgetError();

DESCRIPTION:   Returns the error flags byte for serial channel A
					This can then be compared against error bitmasks to determine
					what errors occured. Additionally, any bits set in the returned
					error flags will be automatically cleared. This function is
               non-reentrant.

					Error bitmasks:
						SER_PARITY_ERROR	0x01
						SER_OVERRUN_ERROR 0x02
						SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

END DESCRIPTION **********************************************************/

nodebug char serAgetError()
{
	static char error_flags;

	error_flags = 0;
	if	(aoverrun)
	{
		error_flags |= SER_OVERRUN_ERROR;
		aoverrun = 0;
	}
	if (aparityerror)
	{
		error_flags |= SER_PARITY_ERROR;
		aparityerror = 0;
	}
	if (aoverflow)
	{
		error_flags |= SER_OVERFLOW_ERROR;
		aoverflow = 0;
	}
	return error_flags;
}

#asm root

;
; interrupt routine to be copied into interrupt table
;

spaisr_start::
    call  spa_isr       ; 19
    ret                 ; 8

spa_dummyfunc::
	ret
#endasm

// The following origin segment changes the serial A interrupt vector code
// to point to the interrupt vector relay table, so that the isr can be modified.
#if _RK_FIXED_VECTORS
#rcodorg sera_intvec apply
#asm
	INTVEC_RELAY_SETUP(intvec_relay+SERA_OFS)
#endasm
#rcodorg rootcode resume
#endif

#asm xmem
;
; spa_init
;

spa_init::
#if _USER
    ipset 1
c	 SetVectIntern(SERA_OFS/0x10, spaisr_start);
#else
	 ld de, INTVEC_BASE + SERA_OFS
	 ld hl, spaisr_start
    ipset 1

    ld    bc,0x0010     ; copy 16 bytes from spaisr_start into interrupt table
	#if __SEPARATE_INST_DATA__
	    call inst2data_ldir
	#else
	    ldir
	#endif
#endif
#ifdef SERA_USEPORTD
    ld	 a, (PDDRShadow)
    set	 ADRIVE_TXD, a    ;Tx should initially be idle high
    ld	 (PDDRShadow), a
;ioi ld	 (PDDR), a
	IOWRITE_A(PDFR)
	 ld	 a, (PDDDRShadow)
	 set	 ADRIVE_TXD, a
	 ld	 (PDDDRShadow), a
;ioi ld	 (PDDDR), a
	IOWRITE_A(PDDDR)
    ld    a,(PDFRShadow)
    set	 ADRIVE_TXD, a    ;Tx should initially be idle high
    ld    (PDFRShadow),a
;ioi ld    (PDFR),a
	IOWRITE_A(PDFR)
    ld    a,0x11
    ld    (SACRShadow),a
;ioi ld    (SACR),a      ; enable interrupts, use parallel port D for
	IOWRITE_A(SACR)
								; serial port B

#else
    ld	 a, (PCDRShadow)
    set	 ADRIVE_TXD, a    ;Tx should initially be idle high
    ld	 (PCDRShadow), a
;ioi ld	 (PCDR), a
	IOWRITE_A(PCDR)
    ld    a,(PCFRShadow)
    set	 ADRIVE_TXD, a    ;Tx should initially be idle high
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ld    a,0x01
    ld    (SACRShadow),a
;ioi ld    (SACR),a       ; enable interrupts, use parallel port C
	IOWRITE_A(SACR)
								 ; for serial port B
#endif

    ipres
    lret

#endasm

#asm root

spa_starttx::				;called by C put routines to start up interrupt loop,
								; if tx is idle
	 push	 af				; cbuf_getch inside of spa_txload uses most of the
	 							; registers
	 push	 bc
	 push	 de
	 push	 hl
	 ipset 1

;ioi ld	 a, (SASR)
	IOREAD_A(SASR)
	 bit	 2, a
	 jr	 nz, spa_starttx_exit	; if tx is busy then it will catch whatever
	 										; is in the buffer
	 ld	 a, (artscts)
	 or	 a
	 jr	 z, spa_starttx_load

	 call  spa_checkcts
	 bool	 hl
	 jr	 nz, spa_starttx_dummy

spa_starttx_load:
	 call	 aEnable
	 call	 spa_txload
	 jr	 spa_starttx_exit

spa_starttx_dummy:
	 call	 aDisable
	 ld	 a, 23
;ioi ld	 (SADR), a
	IOWRITE_A(SADR)

spa_starttx_exit:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

aDisable::
#ifdef SERA_USEPORTD
	 ld    a,(PDDRShadow)
    set   ADRIVE_TXD,a	  ;make sure Tx is high(idle)
    ld    (PDDRShadow),a
;ioi ld    (PDDR),a
	IOWRITE_A(PDDR)
    ld    a,(PDFRShadow)
    res   ADRIVE_TXD,a
    ld    (PDFRShadow),a
;ioi ld    (PDFR),a
	IOWRITE_A(PDFR)
	 ret
#else
	 ld    a,(PCDRShadow)
    set   ADRIVE_TXD,a	  ;make sure Tx is high(idle)
    ld    (PCDRShadow),a
;ioi ld    (PCDR),a
	IOWRITE_A(PCDR)
    ld    a,(PCFRShadow)
    res   ADRIVE_TXD,a
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ret
#endif

aEnable::
#ifdef SERA_USEPORTD
    ld    a,(PDFRShadow)
    set   ADRIVE_TXD,a
    ld    (PDFRShadow),a
;ioi ld    (PDFR),a
	IOWRITE_A(PDFR)
	 ret
#else
	 ld    a,(PCFRShadow)
    set   ADRIVE_TXD,a
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ret
#endif


spa_checkcts::				;hl will be non-zero if CTS is high, uses register a
	 ld	hl, (a_checkctsfunc)
	 jp	(hl)


spa_txload::
	 ld	 a, (alongstop)	;check if we are in a long stop
	 or	 a
	 jp	 nz, spa_txload_exit		;don't load a byte if we have a long stop

    ld    hl,spa_ocbuf  ; 6,	retrieve character from circular buffer
    push  hl            ; 10
    lcall  cbuf_getch    ; 12+...
    add	 sp, 2
    bit   7,h           ; 4,	was there a character?
    jp    nz,spa_txload_exit

	 ld	 a, (atwostop)
	 or	 a
	 jp	 nz, spa_txload_2stop

	 ld	 a, (aparity)	;check to see if we need to add a parity bit
	 or	 a
	 jp	 z, spa_txload_sendbyte
	 ld	 a, (asevenbit) ;are we doing 7 or 8 bit data?
	 or	 a
	 jr	 nz, spa_txload_7bitparity
spa_txload_8bitparity:
	 push	 hl	;save the byte value
	 ld	 a, (aparitytype)
	 ld	 h, a
	 lcall ser8_getparity
	 bool  hl
	 pop	 hl
	 jr	 z, spa_txload_9bitlow

#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
spa_txload_9bithigh:
	 ld	 a, L
;ioi ld	 (SALR), a
	IOWRITE_A(SALR)
	 jr	 spa_txload_exit
#else
spa_txload_9bithigh:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, spa_txload_setlongstop
	 ld	 a, L
;ioi ld	 (SALR), a
	IOWRITE_A(SALR)
	 jr	 spa_txload_exit

spa_txload_setlongstop:
	 ld	 a, 0x01
	 ld	 (alongstop), a	;set the long stop flag
	 jp	 spa_txload_sendbyte
#endif

spa_txload_9bitlow:
	 ld	 a, L
;ioi ld	 (SAAR), a			;load byte into alternate register
	IOWRITE_A(SAAR)
	 jr	 spa_txload_exit

spa_txload_7bitparity:
	 ld	 a, (aparitytype)
	 ld	 h, a
	 lcall ser7_setparity
	 jp	 spa_txload_sendbyte

spa_txload_2stop:
	 ld	 a, (asevenbit)
	 or	 a
	 jr	 z, spa_txload_9bithigh
	 ld	 a, L
	 or	 0x80
	 ld	 L, a
spa_txload_sendbyte:
    ld	 a, L
;ioi ld	 (SADR), a
	IOWRITE_A(SADR)
spa_txload_exit:
	 ret
#endasm

/*** BeginHeader spa_isr */
root void spa_isr();
/*** EndHeader */

#asm
;
; spa_isr
;

spa_isr::
	push	af					; 7, 	restore registers needed by isr
	push	bc					; 7
	push	de					; 7
	push	hl					; 7

;ioi ld	 a,(SASR)			; 11,	interrupt source rx or tx
	IOREAD_A(SASR)
#if (_USER)
	;acknowledge interrupt immediately for RabbitSys
	IOWRITE_A(SASR)
#endif
	 ld    c,a
	 rla						; 2
	 jp	 c,spa_rx			; 5

spa_tx:
    bit   2,c           ; Tx busy? bit 2 shifted via rla
    jr    nz,spa_txbusy
spa_txidle:             ; Tx idle, safe for enable/disable transition
	 ld	 a, (alongstop)
	 or	 a
	 jr	 nz, spa_dolongstop	;handle request for a loooong (2 byte) stop bit

	 ld 	 a, (artscts)
	 or	 a
    jr	 z, spa_trytosend ;try one more time to load a byte
	 call  spa_checkcts
	 bool	 hl
	 jr	 nz, spa_disabletx

spa_trytosend:
	 call	 aEnable
	 call	 spa_txload				;CTS is on, so try to load a normal byte
	 jr	 spa_donomore

spa_dolongstop:
	 xor	 a
	 ld	 (alongstop), a		;clear out the long stop flag
spa_disabletx:
	 call  aDisable
	 ld	 a, 42
;ioi ld	 (SADR), a				; load 42 into SADR as a dummy byte,
	IOWRITE_A(SADR)
										; to keep the interrupt loop going
	 jr	 spa_donomore

spa_txbusy:
    ld    a,(PCFRShadow)		; check to make sure tx is enabled
    bit   ADRIVE_TXD,a			; if not, dummy character still needs to
    									; clear out
    jr    z, spa_donomore
	 ld 	 a, (artscts)			; are we using CTS?
	 or	 a
    jr	 z, spa_txallgood
	 call  spa_checkcts
	 bool	 hl
	 jr	 nz, spa_donomore		; CTS is off, don't fill SBDR
spa_txallgood:
	 call	 spa_txload				; will load a good byte, it there is one to
	 									; be loaded
spa_donomore:
;ioi ld    (SASR),a      ; 10,	clear interrupt source
#if !(_USER)
	IOWRITE_A(SASR)
#endif
    ipres               ; 4
    pop   hl            ; 7, 	restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

spa_rx:
;ioi ld    a,(SADR)      ; 11,	receive the character
	IOREAD_A(SADR)
    bool  hl            ; 2,	place character on circular buffer
    ld    l,a           ; 2,		throw it away if no room
 	 ld	 b,a				; save for later possible parity check
	 ld	 a, (asevenbit)
	 or	 a
	 jr	 z, spa_rxcontinue
	 ld	 a, L
	 and	 0x7f
	 ld	 L, a				;mask out MSB for 7 bit data
spa_rxcontinue:
	 push	 bc				; save byte copy and status register copy
    push  hl            ; 10
    ld    hl,spa_icbuf  ; 6
    push  hl            ; 10
    lcall  cbuf_putch	   ; 12+...
    add   sp,4          ; 4
	 bool	 hl
	 jr	 nz, spa_checkoverrun
	 ld	 a, 0x01
	 ld	 (aoverflow), a
spa_checkoverrun:
    pop	 bc
    bit	 5, c				;test for receiver overrun
    jr	 z, spa_checkparity
    ld	 a, 0x01
    ld	 (aoverrun), a

spa_checkparity:
	 ld	 a, (aparity)
	 or	 a								; see if we need to check parity of
	 										; incoming byte
	 jr	 z, spa_rx_flowcontrol
	 ld	 a, (asevenbit)
	 or	 a
	 jr	 nz, spa_check7bit
spa_check8bit:
	 ld	 l, b
	 ld	 a, (aparitytype)
	 ld	 h, a
	 lcall ser8_getparity
	 bool  hl
	 jr	 z, spa_check9low
spa_check9high:						; 9th parity bit should be high,
											; otherwise we have a parity error
	 bit	 6, c							; C reg should still have a snapshot of
	 										; the status register, checking bit 9
	 jr	 z, spa_rx_flowcontrol	; no 9th bit detected (9th bit high),
	 										; so we are OK
	 or	 a, 0x01
	 ld	 (aparityerror), a		;signal a parity error
	 jr	 spa_rx_flowcontrol
spa_check9low:
	 bit	 6, c
	 jr	 nz, spa_rx_flowcontrol	; 9th bit detected (9th bit low),
	 										; which is what we expect
	 or	 a, 0x01
	 ld	 (aparityerror), a
	 jr	 spa_rx_flowcontrol
spa_check7bit:
	 ld	 l, b
	 ld	 a, (aparitytype)
	 ld	 h, a
	 lcall ser7_checkparity
	 bool	 hl
	 jr	 nz, spa_rx_flowcontrol
	 or	 a, 0x01
	 ld	 (aparityerror), a

spa_rx_flowcontrol:
    ld    a,(artscts)
    or    a
    jr    z,spa_rx0
    ld    hl,spa_icbuf  ;
    push  hl            ;
    lcall  cbuf_used     ;
    add   sp,2          ;
    ld    d,h
    ld    e,l
    ld    b,d
    ld    c,e           ; copy number bytes used to bc
    ld    hl,(serArtsHi);
    ld    a,d           ;
    cp    h             ;
    jr    c,spa_rx0     ;
    ld    a,e           ;
    cp    l             ;
    jr    c,spa_rx0     ;
spa_overHi:					; turn off the RTS line
	 ld	 hl, spa_rx0
	 push	 hl				;set return address
	 ld	 hl, (a_rtsoff)
	 jp	 (hl)
spa_rx0:
    ipres               ; 4
    pop   hl            ; 7,  restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

#endasm

//************************************************************************
//****************************** PORT B **********************************
//************************************************************************

/*** Beginheader serBgetc */
int  serBgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBgetc                     <RS232.LIB>

SYNTAX:	      int serBgetc();

DESCRIPTION:   Get next available character from serial port B read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	success: the next character in the low byte, 0 in the high byte
               failure: the integer -1

END DESCRIPTION **********************************************************/

nodebug int serBgetc()
{
   static int n;

   if (cbuf_rdlock(spb_icbuf))
   {
      n = cbuf_getch(spb_icbuf);
      if (brtscts && cbuf_used(spb_icbuf) <= serBrtsLo)
      {
      	(*b_rtson)(); //set port B RTS line high
      }
      cbuf_rdunlock(spb_icbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_RXC, 'B', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_B
	   if (n >= 0) printf(RS232_RXC, 'B', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = -1;
   }
   return n;
}

/*** Beginheader serBread */
int  serBread(void *data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBread                   <RS232.LIB>

SYNTAX:		   int serBread(void *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from serial port B or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port B
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port B

END DESCRIPTION **********************************************************/

nodebug int serBread(void *data, int length, unsigned long tmout)
{
   static int  n, nread, timedOut;
   static char *p;
   static unsigned long chtm;

   p = (char *)data;
   nread = timedOut = 0;

   if (cbuf_rdlock(spb_icbuf))
   {
      chtm = MS_TIMER;
      while (nread < length && !timedOut)
      {
      	// once in, finish or timeout
         if ((n = cbuf_get(spb_icbuf, p + nread, length - nread)) > 0)
         {
      		if (brtscts && cbuf_used(spb_icbuf) <= serBrtsLo)
      		{
      			(*b_rtson)();
      		}
            chtm = MS_TIMER;
            nread += n;
         }
         else
         {
            if (nread)
            {
               if (MS_TIMER - chtm >= tmout)
               {
                  timedOut = 1;
               }
            }
            else
            {
               break;   // just break out of while if
                        // we have not yet begun to read data
            }
         }
      }
	   cbuf_rdunlock(spb_icbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-B");
#else
#ifdef RS232_MONITOR_B
	_RS232_echo(p, nread, "RX-B");
#endif
#endif
   return nread;
}

/*** Beginheader serBpeek */
int serBpeek();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBpeek                   <RS232.LIB>

SYNTAX:		   int serBpeek();

DESCRIPTION:   returns the 1st character of the data in the B input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not
END DESCRIPTION **********************************************************/

nodebug int serBpeek()
{
  return (int)cbuf_peek(spb_icbuf);
}

/*** Beginheader serBputc */
int serBputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBputc                     <RS232.LIB>

SYNTAX:	      int serBputc(char c);

DESCRIPTION:   Write a character to serial port B write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port B write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

END DESCRIPTION **********************************************************/

nodebug int serBputc(int c)
{
   static int n;

   if (cbuf_wrlock(spb_ocbuf))
   {
      n = cbuf_putch(spb_ocbuf, c);
      if (n)
      {
      	spb_starttx();
      }
      cbuf_wrunlock(spb_ocbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_TXC, 'B', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_B
	   if (n >= 0) printf(RS232_TXC, 'B', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = 0;
   }
   return n;
}

/*** Beginheader serBputs */
int serBputs(char *s);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBputs                     <RS232.LIB>

SYNTAX:     	int serBputs(char* s);

DESCRIPTION:   Calls serBwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port B.

END DESCRIPTION **********************************************************/

nodebug int serBputs(char *s)
{
   return serBwrite(s, strlen(s));
}

/*** Beginheader serBwrite */
int serBwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBwrite                   <RS232.LIB>

SYNTAX:		   int serBwrite(void *data, int length);

DESCRIPTION:   Transmits length bytes to serial port B.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port B
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port B.

END DESCRIPTION **********************************************************/

nodebug int serBwrite(void *data, int length)
{
   static int bytesleft;
   static char *p;

   p = (char *)data;
   bytesleft = length;
   if (cbuf_wrlock(spb_ocbuf))
   {
      while (bytesleft)
      {
         bytesleft -= cbuf_put(spb_ocbuf, p+(length-bytesleft), bytesleft);
         spb_starttx();
      }
      cbuf_wrunlock(spb_ocbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, length - bytesleft, "TX-B");
#else
#ifdef RS232_MONITOR_B
	_RS232_echo(p, length - bytesleft, "TX-B");
#endif
#endif
   return length - bytesleft;
}

/*** Beginheader cof_serBgetc */
scofunc int cof_serBgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serBgetc                   <RS232.LIB>

SYNTAX:		   int cof_serBgetc();

DESCRIPTION:   Yields to other tasks until a character is read from port B.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port B

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serBgetc()
{
	static int c;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spb_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spb_icbuf));
	havelock=1;

	waitfor((c=cbuf_getch(spb_icbuf)) != -1);

   if (brtscts && cbuf_used(spb_icbuf) <= serBrtsLo)
   {
   	(*b_rtson)();
   }

	cbuf_rdunlock(spb_icbuf);
#ifdef RS232_MONITOR
   if (c >= 0) printf(RS232_RXC, 'B', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_B
   if (c >= 0) printf(RS232_RXC, 'B', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
	return c;
}

/*** Beginheader cof_serBgets */
scofunc int cof_serBgets(char *s, int max, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serBgets                   <RS232.LIB>

SYNTAX:		   int cof_serBgets(char *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port B until a null terminator, carriage
					return or linefeed is read, max characters are read, or until
					tmout milliseconds transpires between characters after the
					first one is read. It yields to other tasks for as long as
					the input buffer is locked or whenever the buffer becomes
					empty as characters are read. s will always be null terminated
					upon return. This function is non-reentrant.

PARAMETER1:    s    : Character array into which a null terminated string
                      is read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serBgets(char *s, int max, unsigned long tmout)
{
   static int  c, started, timedOut;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spb_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spb_icbuf));
   havelock=1;

   p = s;
   c = started = timedOut = 0;

   while (c != RS232_CR && p-s < max && !timedOut)
   {
      if ((c = cbuf_getch(spb_icbuf)) != -1)
      {
         switch (c)
         {
            case  8: if (p > s) --p; break;
            case  0:
            case RS232_LF: c = RS232_CR;
            case RS232_CR: break;
            default: *p++ = c; break;
         }

   		if (brtscts && cbuf_used(spb_icbuf) <= serBrtsLo)
   		{
   			(*b_rtson)();
   		}

         if (!started) started = 1;
         chtm = MS_TIMER;  // timeout starts anew
      }
      else
      {
         if (started && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   *p=0;  // null terminate whether timed out, max length, or normal
	cbuf_rdunlock(spb_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(s, p - s, "RX-B");
#else
#ifdef RS232_MONITOR_B
	_RS232_echo(s, p - s, "RX-B");
#endif
#endif
   return !timedOut; //
}

/*** Beginheader cof_serBread */
scofunc int cof_serBread(void* data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serBread                   <RS232.LIB>

SYNTAX:		   int cof_serBread(void* data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port B or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which chsaracters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serBread(void* data, int length, unsigned long tmout)
{
   static int nread, timedOut;
   static int n;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spb_icbuf);
	}

   p = (char *)data;
	havelock=0;
	waitfor(cbuf_rdlock(spb_icbuf));
   havelock=1;

   n = nread = timedOut = 0;
   chtm = MS_TIMER;
   while(nread < length && !timedOut)
   {
      if ((n = cbuf_get(spb_icbuf, p + nread, length - nread)) > 0)
      {
         nread += n;
   		if (brtscts && cbuf_used(spb_icbuf) <= serBrtsLo)
   		{
   			(*b_rtson)();
   		}
         if(nread < length)
         {
            yield;
            chtm = MS_TIMER;      // timeout starts anew
         }
      }
      else
      {
         if (nread && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   cbuf_rdunlock(spb_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-B");
#else
#ifdef RS232_MONITOR_B
	_RS232_echo(p, nread, "RX-B");
#endif
#endif
   return nread;
}

/*** Beginheader cof_serBputc */
scofunc void cof_serBputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serBputc                   <RS232.LIB>

SYNTAX:		   void cof_serBputc(int c);

DESCRIPTION:   Writes a character to the B port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serBputc(int c)
{
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spb_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spb_ocbuf));
   havelock=1;

	waitfor(cbuf_putch(spb_ocbuf,c));

	spb_starttx();
	cbuf_wrunlock(spb_ocbuf);
#ifdef RS232_MONITOR
	if (c >= 0) printf(RS232_TXC, 'B', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_B
	if (c >= 0) printf(RS232_TXC, 'B', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
}

/*** Beginheader cof_serBputs */
scofunc void cof_serBputs(char *str);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serBputs                   <RS232.LIB>

SYNTAX:		   void cof_serBputs(char *str);

DESCRIPTION:   Writes a null terminated string to the B port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serBputs(char *str)
{
	static int bytesleft,length;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spb_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spb_ocbuf));
   havelock=1;

	bytesleft=length=strlen(str);

	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spb_ocbuf,str+(length-bytesleft),bytesleft);
		spb_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spb_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(str, length, "TX-B");
#else
#ifdef RS232_MONITOR_B
	_RS232_echo(str, length, "TX-B");
#endif
#endif
}

/*** Beginheader cof_serBwrite */
scofunc void cof_serBwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serBwrite                   <RS232.LIB>

SYNTAX:		   void cof_serBwrite(void *data, int length);

DESCRIPTION:   Writes length bytes to the B port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serBwrite(void *data, int length)
{
	static int bytesleft;
   static char *v;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spb_ocbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spb_ocbuf));
   havelock=1;

   v = (char *)data;
	bytesleft=length;
	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spb_ocbuf,v+(length-bytesleft),bytesleft);
		spb_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spb_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(v, length, "TX-B");
#else
#ifdef RS232_MONITOR_B
	_RS232_echo(v, length, "TX-B");
#endif
#endif
}

/*** Beginheader serBflowcontrolOn */
void serBflowcontrolOn();
/*** endheader */

//defaults for flow control RTS/CTS
#ifndef SERB_RTS_PORT
#define SERB_RTS_PORT PCDR
#warnt "SERB_RTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERB_RTS_SHADOW
#define SERB_RTS_SHADOW PCDRShadow
#warnt "SERB_RTS_SHADOW not defined: defaulting to PCDRShadow"
#endif

#ifndef SERB_RTS_BIT
#define SERB_RTS_BIT 2
#warnt "SERB_RTS_BIT not defined: defaulting to 2"
#endif

#ifndef SERB_CTS_PORT
#define SERB_CTS_PORT PCDR
#warnt "SERB_CTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERB_CTS_BIT
#define SERB_CTS_BIT 3
#warnt "SERB_CTS_BIT not defined: defaulting to 3"
#endif

#asm root
spb_checkcts_fc::
	 bool	hl
;ioi ld 	a, (SERB_CTS_PORT)
	IOREAD_A(SERB_CTS_PORT)
	 and	1 << SERB_CTS_BIT
	 ld	L, a
	 ret

spb_rtsoff_fc::
	 ld	 a, (SERB_RTS_SHADOW)
	 set	 SERB_RTS_BIT, a		;set RTS high (inactive)
	 ld	 (SERB_RTS_SHADOW), a
;ioi ld	 (SERB_RTS_PORT), a
	IOWRITE_A(SERB_RTS_PORT)
	 ret

spb_rtson_fc::
	 ld	 a, (SERB_RTS_SHADOW)
	 res   SERB_RTS_BIT, a		;set RTS low (active)
	 ld	 (SERB_RTS_SHADOW), a
;ioi ld	 (SERB_RTS_PORT), a
	IOWRITE_A(SERB_RTS_PORT)
	 ret

#endasm

/* START FUNCTION DESCRIPTION ********************************************
serBflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serBflowcontrolOn();

DESCRIPTION:   Turns on hardware flow control for channel B. This enables two
					digital lines that handle flow control, CTS(clear to send)
					and RTS(ready to send).
					CTS is an input that will be pulled active low by the other
					system when it is ready to receive data. The RTS signal
					is an output that the system uses to indicate that it is
					ready to receive data. It is driven low when data can be
					received.
					If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERB_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERB_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERB_RTS_BIT - the bit number for the RTS line
 					SERB_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERB_CTS_BIT - the bit number for the CTS line

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serBflowcontrolOn()
{
	brtscts = 1;
	//set flow control ISR functions
	b_checkctsfunc = spb_checkcts_fc;
	b_rtsoff = spb_rtsoff_fc;
	b_rtson = spb_rtson_fc;
	serBrtsLo = (int)(BINBUFSIZE * 0.2);
	serBrtsHi = (int)(BINBUFSIZE * 0.8);
	// turn on RTS if buffer is below 80%
	if (serBrdUsed() < serBrtsHi) (*b_rtson)();
}

/*** Beginheader serBflowcontrolOff */
void serBflowcontrolOff();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serBflowcontrolOff();

DESCRIPTION:   Turns off hardware flow control for channel B.
               This function is non-reentrant.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serBflowcontrolOff()
{
	brtscts = 0;
}

/*** Beginheader serBparity */
void serBparity(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBparity                   <RS232.LIB>

SYNTAX:		   void serBparity(int state);

DESCRIPTION:   Sets parity type for channel B. This function is non-reentrant.

PARAMETER1:		A bit mask for selecting parity mode
					PARAM_EPARITY	0x01
					PARAM_OPARITY	0x02
					PARAM_2STOP 	0x03
					PARAM_NOPARITY 0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serBparity(int state)
{
	if (state) {
		if (state == PARAM_OPARITY)
		{
			bparity = 1;
			btwostop = 0;
			bparitytype = 0;
		}
		else if (state == PARAM_EPARITY)
		{
			bparity = 1;
			btwostop = 0;
			bparitytype = 1;
		}
		else
		{
			btwostop = 1;
			bparity = 0;
		}
	}
	else
	{
		btwostop = 0;
		bparity = 0;
	}
	if(bsevenbit && !bparity && !btwostop)
	{
		BitWrPortI(SBCR, &SBCRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SBCR, &SBCRShadow, 0, 2);
	}
}

/*** Beginheader serBdatabits */
void serBdatabits(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBdatabits                   <RS232.LIB>

SYNTAX:		   void serBdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel B.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
					PARAM_7BIT	0x01
					PARAM_8BIT	0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serBdatabits(int state)
{
	if (state == PARAM_7BIT)
	{
		bsevenbit = 1;
	}
	else
	{
		bsevenbit = 0;
	}
	if(bsevenbit && !bparity && !btwostop)
	{
		BitWrPortI(SBCR, &SBCRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SBCR, &SBCRShadow, 0, 2);
	}
}

/*** Beginheader serBrdFlush */
void serBrdFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBrdFlush                  <RS232.LIB>

SYNTAX:		   void serBrdFlush();

DESCRIPTION:   Flushes the serial port B input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serBrdFlush()
{
	cbuf_flush(spb_icbuf);
}

/*** Beginheader serBwrFlush */
void serBwrFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBwrFlush                  <RS232.LIB>

SYNTAX:		   void serBwrFlush();

DESCRIPTION:   Flushes the serial port B transmit buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serBwrFlush()
{
	cbuf_flush(spb_ocbuf);
}

/*** Beginheader serBrdFree */
int serBrdFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBrdFree                   <RS232.LIB>

SYNTAX:		   int serBrdFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port B input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the B input buffer
END DESCRIPTION **********************************************************/

nodebug int serBrdFree()
{
	return (int)cbuf_free(spb_icbuf);
}

/*** Beginheader serBwrFree */
int serBwrFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBwrFree                   <RS232.LIB>

SYNTAX:		   int serBwrFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port B transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the B transmit buffer
END DESCRIPTION **********************************************************/

nodebug int serBwrFree()
{
	return (int)cbuf_free(spb_ocbuf);
}

/*** Beginheader serBrdUsed */
int serBrdUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBrdUsed                   <RS232.LIB>

SYNTAX:		   int serBrdUsed();

DESCRIPTION:   Returns the number of characters in the B input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the B input buffer
END DESCRIPTION **********************************************************/

nodebug int serBrdUsed()
{
	return (int)cbuf_used(spb_icbuf);
}

/*** Beginheader serBwrUsed */
int serBwrUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBwrUsed                   <RS232.LIB>

SYNTAX:		   int serBwrUsed();

DESCRIPTION:   Returns the number of characters in the B output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the B output buffer
END DESCRIPTION **********************************************************/

nodebug int serBwrUsed()
{
	return (int)cbuf_used(spb_ocbuf);
}

/*** Beginheader serBclose */
void serBclose();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serBclose                   <RS232.LIB>

SYNTAX:		   void serBclose();

DESCRIPTION:   Disables the B serial port. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm xmem

serBclose::
    ld 	a, 0xc9
    ipset 1
#if _USER
c	 SetVectIntern(SERB_OFS/0x10, spb_dummyfunc);
#else
    ld	(INTVEC_BASE + SERB_OFS), a		; ret in first byte of spbisr_start
#endif
    ld    a,0x00        ; disable interrupts for port
	 ld    (SBCRShadow),a
;ioi ld    (SBCR),a
	IOWRITE_A(SBCR)
#ifdef SERB_USEPORTD
    ld    a,(PDFRShadow)
    res	 BDRIVE_TXD, a    ;return to normal output
    ld    (PDFRShadow),a
;ioi ld    (PDFR),a
	IOWRITE_A(PDFR)
#else
    ld    a,(PCFRShadow)
    res	 BDRIVE_TXD, a    ;return to normal output
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
#endif
    ipres
    lret

#endasm

/*** Beginheader serBrtsLo, serBrtsHi, serBopen, serBgetError,
     spb_icbuf, spb_ocbuf */
extern int serBrtsLo;
extern int serBrtsHi;
int serBopen(long baud);
char serBgetError();
void spb_init();
root void spb_starttx();
root void bDisable();
root void bEnable();
root void spb_dummyfunc();
extern char spb_icbuf[];
extern char spb_ocbuf[];
extern char brtscts;
extern char bparity;
extern char bparitytype;
extern char bsevenbit;
extern char btwostop;
//pointers to flow control functions
extern int (*b_checkctsfunc)();
extern void (*b_rtsoff)();
extern void (*b_rtson)();
extern char blongstop;
extern char boverrun;
extern char bparityerror;
extern char boverflow;
#define BDRIVE_TXD 4
/*** endheader */

#if ((_BOARD_TYPE_ == RCM2200) || (_BOARD_TYPE_ == RCM2300) || \
     (_BOARD_TYPE_ == RCM2250) || (_BOARD_TYPE_ == RCM2260A))
#define SERB_USEPORTD
#endif

#undef BINBUFOK

#ifndef BINBUFSIZE
#define BINBUFSIZE 31
#warnt "BINBUFSIZE undefined, defaulting to 31"
#endif

#if (BINBUFSIZE & (BINBUFSIZE+1)) == 0
#define BINBUFOK 1
#endif

#ifndef BINBUFOK
#undef BINBUFSIZE
#define BINBUFSIZE 31
#warnt "BINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef BOUTBUFOK

#ifndef BOUTBUFSIZE
#define BOUTBUFSIZE 31
#warnt "BOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (BOUTBUFSIZE & (BOUTBUFSIZE+1)) == 0
#define BOUTBUFOK 1
#endif

#ifndef BOUTBUFOK
#undef BOUTBUFSIZE
#define BOUTBUFSIZE 31
#warnt "BOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char spb_icbuf[BINBUFSIZE+9];
char spb_ocbuf[BOUTBUFSIZE+9];

int  serBrtsLo;
int  serBrtsHi;
char blongstop;
char boverrun;
char boverflow;
char bparityerror;

char brtscts;
char bparity;
char bparitytype;
char bsevenbit;
char btwostop;
int (*b_checkctsfunc)();
void (*b_rtsoff)();
void (*b_rtson)();

/* START FUNCTION DESCRIPTION ********************************************
serBopen                   <RS232.LIB>

SYNTAX:		   int serBopen(long baud);

DESCRIPTION:   Opens the B serial port. This function is non-reentrant.
               This function is non-reentrant.
					Note: The alternate pins on parallel port D can be used
					for serial port B by defining SERB_USEPORTD at the
					beginning of a program. See the section on parallel port
					D in the Rabbit documentation for more detail on the
					alternate serial port pins.

PARAMETER1:    baud : bits per second of data transfer

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

RELATED WORDS: serBgetc, serBgetc, serBpeek,
               serBputs, serBwrite,
               cof_serBgetc, cof_serBgets, cof_serBread,
               cof_serBputc, cof_serBputs, cof_serBwrite
               serBclose

END DESCRIPTION **********************************************************/

nodebug int serBopen(long baud)
{
   static long divisor, ta1div;
   static float baudratio;
	static unsigned long t;

   ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	WrPortI(TACR, &TACRShadow, TACRShadow | 0x20);  // set 'use port A' bit
	}
	else
	{
   	WrPortI(TACR, &TACRShadow, TACRShadow & ~0x20); // clear bit
	}

	brtscts = 0;
	bsevenbit = 0;
	bparity = 0;
	bparitytype = 0;
	btwostop = 0;
	blongstop = 0;
	bparityerror = 0;
	boverrun = 0;
	boverflow = 0;
	//use the dummy versions of the flow control functions
	//all they do is return. They are placeholders in case flow control
	//enabled
	b_checkctsfunc = spb_dummyfunc;
	b_rtsoff = spb_dummyfunc;
	b_rtson = spb_dummyfunc;
	WrPortI(TAT5R, &TAT5RShadow, (char)divisor);
   cbuf_init(spb_icbuf,BINBUFSIZE);
   cbuf_init(spb_ocbuf,BOUTBUFSIZE);

   spb_init();
   t = MS_TIMER;
   // let baud timer time out before using port
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   cbuf_getch(spb_icbuf);
   cbuf_getch(spb_icbuf);
   baudratio = ((RS232_BASEFREQ*freq_divider) /
   	(32 * ((divisor & 0xff) + 1) + 0.5)) / (float)(baud * (ta1div + 1));
   return (baudratio > 0.95 && baudratio < 1.05);
}

/* START FUNCTION DESCRIPTION ********************************************
serBgetError                   <RS232.LIB>

SYNTAX:		   char serBgetError();

DESCRIPTION:   Returns the error flags byte for serial channel B
					This can then be compared against error bitmasks to determine
					what errors occured. Additionally, any bits set in the returned
					error flags will be automatically cleared. This function is
               non-reentrant.

					Error bitmasks:
						SER_PARITY_ERROR	0x01
						SER_OVERRUN_ERROR 0x02
						SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

END DESCRIPTION **********************************************************/

nodebug char serBgetError()
{
	static char error_flags;

	error_flags = 0;
	if	(boverrun)
	{
		error_flags |= SER_OVERRUN_ERROR;
		boverrun = 0;
	}
	if (bparityerror)
	{
		error_flags |= SER_PARITY_ERROR;
		bparityerror = 0;
	}
	if (boverflow)
	{
		error_flags |= SER_OVERFLOW_ERROR;
		boverflow = 0;
	}

	return error_flags;
}


#asm root

;
; interrupt routine to be copied into interrupt table
;

spbisr_start::
    call  spb_isr       ; 19
    ret                 ; 8

spb_dummyfunc::
	ret

#endasm

#asm xmem

;
; spb_init
;

spb_init::
#if _USER
    ipset 1
c	 SetVectIntern(SERB_OFS/0x10, spbisr_start);
#else
	 ld de, INTVEC_BASE + SERB_OFS
	 ld hl, spbisr_start
    ld    bc,0x0010     ; copy 16 bytes from spbisr_start into interrupt table
    ipset 1

	#if __SEPARATE_INST_DATA__
	    call inst2data_ldir
	#else
	    ldir
	#endif
#endif

#ifdef SERB_USEPORTD
    ld	 a, (PDDRShadow)
    set	 BDRIVE_TXD, a    ;Tx should initially be idle high
    ld	 (PDDRShadow), a
;ioi ld	 (PDDR), a
	IOWRITE_A(PDDR)
	 ld	 a, (PDDDRShadow)
	 set	 BDRIVE_TXD, a
	 ld	 (PDDDRShadow), a
;ioi ld	 (PDDDR), a
	IOWRITE_A(PDDDR)
    ld    a,(PDFRShadow)
    set	 BDRIVE_TXD, a    ;Tx should initially be idle high
    ld    (PDFRShadow),a
;ioi ld    (PDFR),a
	IOWRITE_A(PDFR)
    ld    a,0x11
    ld    (SBCRShadow),a
;ioi ld    (SBCR),a      ; enable interrupts, use parallel port D for
	IOWRITE_A(SBCR)
								; serial port B
#else
    ld	 a, (PCDRShadow)
    set	 BDRIVE_TXD, a    ;Tx should initially be idle high
    ld	 (PCDRShadow), a
;ioi ld	 (PCDR), a
	IOWRITE_A(PCDR)
    ld    a,(PCFRShadow)
    set	 BDRIVE_TXD, a    ;Tx should initially be idle high
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ld    a,0x01
    ld    (SBCRShadow),a
;ioi ld    (SBCR),a      ; enable interrupts, use parallel port C for
	IOWRITE_A(SBCR)
								; serial port B
#endif
    ipres
    lret

#endasm

#asm root

spb_starttx::				; called by C put routines to start up interrupt loop,
								; if tx is idle
	 push	 af				; cbuf_getch inside of spb_txload uses most of
	 							; the registers
	 push	 bc
	 push	 de
	 push	 hl
	 ipset 1

;ioi ld	 a, (SBSR)
	IOREAD_A(SBSR)
	 bit	 2, a
	 jr	 nz, spb_starttx_exit	; if tx is busy then it will catch whatever
	 										; is in the buffer
	 ld	 a, (brtscts)
	 or	 a
	 jr	 z, spb_starttx_load

	 call  spb_checkcts
	 bool	 hl
	 jr	 nz, spb_starttx_dummy

spb_starttx_load:
	 call	 bEnable
	 call	 spb_txload
	 jr	 spb_starttx_exit

spb_starttx_dummy:
	 call	 bDisable
	 ld	 a, 23
;ioi ld	 (SBDR), a
	IOWRITE_A(SBDR)

spb_starttx_exit:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

bDisable::
#ifdef SERB_USEPORTD
	 ld    a,(PDDRShadow)
    set   BDRIVE_TXD,a	  ;make sure Tx is high(idle)
    ld    (PDDRShadow),a
;ioi ld    (PDDR),a
	IOWRITE_A(PDDR)
    ld    a,(PDFRShadow)
    res   BDRIVE_TXD,a
    ld    (PDFRShadow),a
;ioi ld    (PDFR),a
	IOWRITE_A(PDFR)
	 ret
#else
	 ld    a,(PCDRShadow)
    set   BDRIVE_TXD,a	  ;make sure Tx is high(idle)
    ld    (PCDRShadow),a
;ioi ld    (PCDR),a
	IOWRITE_A(PCDR)
    ld    a,(PCFRShadow)
    res   BDRIVE_TXD,a
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ret
#endif

bEnable::
#ifdef SERB_USEPORTD
    ld    a,(PDFRShadow)
    set   BDRIVE_TXD,a
    ld    (PDFRShadow),a
;ioi ld    (PDFR),a
	IOWRITE_A(PDFR)
	 ret
#else
	 ld    a,(PCFRShadow)
    set   BDRIVE_TXD,a
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ret
#endif

spb_checkcts::				;hl will be non-zero if CTS is high, uses register a
	 ld	hl, (b_checkctsfunc)
	 jp	(hl)

;
; spb_txload
;

spb_txload::
	 ld	 a, (blongstop)	;check if we are in a long stop
	 or	 a
	 jp	 nz, spb_txload_exit		;don't load a byte if we have a long stop

    ld    hl,spb_ocbuf  ; 6,	retrieve character from circular buffer
    push  hl            ; 10
    lcall  cbuf_getch    ; 12+...
    add	 sp, 2
    bit   7,h           ; 4,	was there a character?
    jp    nz,spb_txload_exit

    ld	 a, (btwostop)
    or	 a
    jp	 nz, spb_txload_2stop

    ld	 a, (bparity)	;check to see if we need to add a parity bit
	 or	 a
	 jp	 z, spb_txload_sendbyte
	 ld	 a, (bsevenbit) ;are we doing 7 or 8 bit data?
	 or	 a
	 jr	 nz, spb_txload_7bitparity
spb_txload_8bitparity:
	 push	 hl	;save the byte value
	 ld	 a, (bparitytype)
	 ld	 h, a
	 lcall ser8_getparity
	 bool  hl
	 pop	 hl
	 jr	 z, spb_txload_9bitlow

#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
spb_txload_9bithigh:
	 ld	 a, L
;ioi ld	 (SBLR), a
	IOWRITE_A(SBLR)
	 jr	 spb_txload_exit
#else
spb_txload_9bithigh:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, spb_txload_setlongstop
	 ld	 a, L
;ioi ld	 (SBLR), a
	IOWRITE_A(SBLR)
	 jr	 spb_txload_exit

spb_txload_setlongstop:
	 ld	 a, 0x01
	 ld	 (blongstop), a	;set the long stop flag
	 jp	 spb_txload_sendbyte
#endif

spb_txload_9bitlow:
	 ld	 a, L
;ioi ld	 (SBAR), a			;load byte into 9bit register
	IOWRITE_A(SBAR)
	 jr	 spb_txload_exit

spb_txload_7bitparity:
	 ld	 a, (bparitytype)
	 ld	 h, a
	 lcall ser7_setparity
	 jp	 spb_txload_sendbyte

spb_txload_2stop:
	 ld	 a, (bsevenbit)
	 or	 a
	 jr	 z, spb_txload_9bithigh		;2 stop bits after 8bit data
	 ld	 a, L
	 or	 0x80								; 2 stop bits after 7bit data,
	 ld	 L, a
spb_txload_sendbyte:
    ld	 a, L
;ioi ld	 (SBDR), a
	IOWRITE_A(SBDR)
spb_txload_exit:
	 ret
#endasm

/*** BeginHeader spb_isr */
root void spb_isr(void);
/*** EndHeader */
#asm
;
; spb_isr
;

spb_isr::
	push	af					; 7, 	restore registers needed by isr
	push	bc					; 7
	push	de					; 7
	push	hl					; 7

;ioi ld	 a,(SBSR)			; 11,	interrupt source rx or tx
	IOREAD_A(SBSR)
#if (_USER)
	;acknowledge interrupt immediately for RabbitSys
	IOWRITE_A(SBSR)
#endif
	 ld    c,a
	 rla						; 2
	 jp	 c,spb_rx			; 5

spb_tx:
    bit   2,c           ; Tx busy? bit 2 shifted via rla
    jr    nz,spb_txbusy
spb_txidle:             ; Tx idle, safe for enable/disable transition
	 ld	 a, (blongstop)
	 or	 a
	 jr	 nz, spb_dolongstop	;handle request for a loooong (2 byte) stop bit

	 ld 	 a, (brtscts)
	 or	 a
    jr	 z, spb_trytosend ;try one more time to load a byte
	 call  spb_checkcts
	 bool	 hl
	 jr	 nz, spb_disabletx

spb_trytosend:
	 call	 bEnable
	 call	 spb_txload				;CTS is on, so try to load a normal byte
	 jr	 spb_donomore

spb_dolongstop:
	 xor	 a
	 ld	 (blongstop), a		;clear out the long stop flag
spb_disabletx:
	 call  bDisable
	 ld	 a, 0x42
;ioi ld	 (SBDR), a				; load 42 into SADR as a dummy byte,
	IOWRITE_A(SBDR)
										; to keep the interrupt loop going
	 jr	 spb_donomore

spb_txbusy:
    ld    a,(PCFRShadow)		; check to make sure tx is enabled
    bit   BDRIVE_TXD,a			; if not, dummy character still needs to
    									; clear out
    jr    z, spb_donomore
	 ld 	 a, (brtscts)			; are we using CTS?
	 or	 a
    jr	 z, spb_txallgood
	 call  spb_checkcts
	 bool	 hl
	 jr	 nz, spb_donomore		; CTS is off, don't fill SBDR
spb_txallgood:
	 call	 spb_txload				; will load a good byte, it there is one to
	 									; be loaded
spb_donomore:
;ioi ld    (SBSR),a      ; 10,	clear interrupt source
#if !(_USER)
	IOWRITE_A(SBSR)
#endif
    ipres               ; 4
    pop   hl            ; 7, 	restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

spb_rx:
;ioi ld    a,(SBDR)      ; 11,	receive the character
	IOREAD_A(SBDR)
    bool  hl            ; 2,	place character on circular buffer
    ld    l,a           ; 2,		throw it away if no room
	 ld	 b, a				; save the byte for possible parity check
	 ld	 a, (bsevenbit)
	 or	 a
	 jr	 z, spb_rxcontinue
	 ld	 a, L
	 and	 0x7f
	 ld	 L, a				;mask out MSB for 7 bit data
spb_rxcontinue:
	 push	 bc				; hold onto byte copy and status register
    push  hl            ; 10
    ld    hl,spb_icbuf  ; 6
    push  hl            ; 10
    lcall  cbuf_putch	   ; 12+...
    add   sp,4          ; 4
	 bool	 hl
	 jr	 nz, spb_checkoverrun
	 ld	 a, 0x01
	 ld	 (boverflow), a
spb_checkoverrun:
    pop	 bc				; get copy and status reg back
	 bit	 5, c				;check for receiver overrun
	 jr	 z, spb_checkparity
	 ld	 a, 0x01
	 ld	 (boverrun), a

spb_checkparity:
	 ld	 a, (bparity)
	 or	 a								; see if we need to check parity of
	 										; incoming byte
	 jr	 z, spb_rx_flowcontrol
	 ld	 a, (bsevenbit)
	 or	 a
	 jr	 nz, spb_check7bit
spb_check8bit:
	 ld	 L, b
	 ld	 a, (bparitytype)
	 ld	 h, a
	 lcall ser8_getparity
	 bool  hl
	 jr	 z, spb_check9low
spb_check9high:						; 9th parity bit should be high,
											; otherwise we have a parity error
	 bit	 6, c							; C reg should still have a snapshot of
	 										; the status register, checking bit 9
	 jr	 z, spb_rx_flowcontrol	; no 9th bit detected (9th bit high),
	 										; so we are OK
	 ld	 a, 0x01
	 ld	 (bparityerror), a				;signal a parity error
	 jr	 spb_rx_flowcontrol
spb_check9low:
	 bit	 6, c
	 jr	 nz, spb_rx_flowcontrol	; 9th bit detected (9th bit low),
	 										; which is what we expect
	 ld	 a, 0x01
	 ld	 (bparityerror), a
	 jr	 spb_rx_flowcontrol
spb_check7bit:
	 ld	 L, b
	 ld	 a, (bparitytype)
	 ld	 h, a
	 lcall ser7_checkparity
	 bool	 hl
	 jr	 nz, spb_rx_flowcontrol
	 ld	 a, 0x01
	 ld	 (bparityerror), a

spb_rx_flowcontrol:
    ld    a,(brtscts)
    or    a
    jr    z,spb_rx0
    ld    hl,spb_icbuf  ;
    push  hl            ;
    lcall  cbuf_used     ;
    add   sp,2          ;
    ld    d,h
    ld    e,l
    ld    b,d
    ld    c,e           ; copy number bytes used to bc
    ld    hl,(serBrtsHi);
    ld    a,d           ;
    cp    h             ;
    jr    c,spb_rx0     ;
    ld    a,e           ;
    cp    l             ;
    jr    c,spb_rx0     ;
spb_overHi:					; turn off the RTS line
	 ld	 hl, spb_rx0
	 push	 hl				;set return address
	 ld	 hl, (b_rtsoff)
	 jp	 (hl)
spb_rx0:
    ipres               ; 4
    pop   hl            ; 7,  restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

#endasm

//************************************************************************
//****************************** PORT C **********************************
//************************************************************************

/*** Beginheader serCgetc */
int  serCgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCgetc                     <RS232.LIB>

SYNTAX:	      int serCgetc();

DESCRIPTION:   Get next available character from serial port C read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	success: the next character in the low byte, 0 in the high byte
               failure: the integer -1

END DESCRIPTION **********************************************************/

nodebug int serCgetc()
{
   static int n;

   if (cbuf_rdlock(spc_icbuf))
   {
      n = cbuf_getch(spc_icbuf);
      if (crtscts && cbuf_used(spc_icbuf) <= serCrtsLo)
      {
      	(*c_rtson)();  // turn on RTS for serial port 2(C)
      }
      cbuf_rdunlock(spc_icbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_RXC, 'C', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_C
	   if (n >= 0) printf(RS232_RXC, 'C', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = -1;
   }
   return n;
}

/*** Beginheader serCread */
int  serCread(void *data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCread                   <RS232.LIB>

SYNTAX:		   int serCread(void *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from serial port C or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port C
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port C

END DESCRIPTION **********************************************************/

nodebug int  serCread(void *data, int length, unsigned long tmout)
{
   static int  n, nread, timedOut;
   static char *p;
   static unsigned long chtm;

   p = (char *)data;
   nread = timedOut = 0;

   if (cbuf_rdlock(spc_icbuf))
   {
      chtm = MS_TIMER;
      while (nread < length && !timedOut)
      {
      	// once in, finish or timeout
         if ((n = cbuf_get(spc_icbuf, p + nread, length - nread)) > 0)
         {
      		if (crtscts && cbuf_used(spc_icbuf) <= serCrtsLo)
      		{
      			(*c_rtson)();
      		}
            chtm = MS_TIMER;
            nread += n;
         }
         else
         {
            if (nread)
            {
               if (MS_TIMER - chtm >= tmout)
               {
                  timedOut = 1;
               }
            }
            else
            {
               break;   // just break out of while if
                        // we have not yet begun to read data
            }
         }
      }
	   cbuf_rdunlock(spc_icbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-C");
#else
#ifdef RS232_MONITOR_C
	_RS232_echo(p, nread, "RX-C");
#endif
#endif
   return nread;
}

/*** Beginheader serCpeek */
int serCpeek();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCpeek                   <RS232.LIB>

SYNTAX:		   int serCpeek();

DESCRIPTION:   Returns the 1st character of the data in the C input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not
END DESCRIPTION **********************************************************/

nodebug int serCpeek()
{
  return (int)cbuf_peek(spc_icbuf);
}

/*** Beginheader serCputc */
int serCputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCputc                     <RS232.LIB>

SYNTAX:	      int serCputc(char c);

DESCRIPTION:   Write a character to serial port C write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port C write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

END DESCRIPTION **********************************************************/

nodebug int serCputc(int c)
{
   static int n;

   if (cbuf_wrlock(spc_ocbuf))
   {
      n = cbuf_putch(spc_ocbuf, c);
      if (n)
      {
      	spc_starttx();
      }
      cbuf_wrunlock(spc_ocbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_TXC, 'C', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_C
	   if (n >= 0) printf(RS232_TXC, 'C', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = 0;
   }
   return n;
}

/*** Beginheader serCputs */
int serCputs(char *s);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCputs                     <RS232.LIB>

SYNTAX:     	int serCputs(char* s);

DESCRIPTION:   Calls serCwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port C.

END DESCRIPTION **********************************************************/

nodebug int serCputs(char *s)
{
   return serCwrite(s, strlen(s));
}

/*** Beginheader serCwrite */
int serCwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCwrite                   <RS232.LIB>

SYNTAX:		   int serCwrite(void *data, int length);

DESCRIPTION:   Transmits length bytes to serial port C.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port C
               length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port C.

END DESCRIPTION **********************************************************/

nodebug int serCwrite(void *data, int length)
{
   static int bytesleft;
   static char *p;

   p = (char *)data;
   bytesleft = length;
   if (cbuf_wrlock(spc_ocbuf))
   {
      while (bytesleft)
      {
         bytesleft -= cbuf_put(spc_ocbuf, p+(length-bytesleft), bytesleft);
         spc_starttx();
      }
      cbuf_wrunlock(spc_ocbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, length - bytesleft, "TX-C");
#else
#ifdef RS232_MONITOR_C
	_RS232_echo(p, length - bytesleft, "TX-C");
#endif
#endif
   return length - bytesleft;
}

/*** Beginheader cof_serCgetc */
scofunc int cof_serCgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serCgetc                   <RS232.LIB>

SYNTAX:		   int cof_serCgetc();

DESCRIPTION:   Yields to other tasks until a character is read from port C.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port C

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serCgetc()
{
	static int c;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spc_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spc_icbuf));
	havelock=1;

	waitfor((c=cbuf_getch(spc_icbuf)) != -1);

   if (crtscts && cbuf_used(spc_icbuf) <= serCrtsLo)
   {
   	(*c_rtson)();
   }

	cbuf_rdunlock(spc_icbuf);
#ifdef RS232_MONITOR
   if (c >= 0) printf(RS232_RXC, 'C', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_C
   if (c >= 0) printf(RS232_RXC, 'C', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
	return c;
}

/*** Beginheader cof_serCgets */
scofunc int cof_serCgets(char *s, int max, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serCgets                   <RS232.LIB>

SYNTAX:		   int cof_serCgets(char *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port C until a null terminator, carriage
					return or linefeed is read, max characters are read, or until
					tmout milliseconds transpires between characters after the
					first one is read. It yields to other tasks for as long as
					the input buffer is locked or whenever the buffer becomes
					empty as characters are read. s will always be null terminated
					upon return. This function is non-reentrant.

PARAMETER1:    s    : Character array into which a null terminated string
                      is read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serCgets(char *s, int max, unsigned long tmout)
{
   static int  c, started ,timedOut;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spc_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spc_icbuf));
   havelock=1;

   p = s;
   c = started = timedOut = 0;

   while (c != RS232_CR && p-s < max && !timedOut)
   {
      if ((c = cbuf_getch(spc_icbuf)) != -1)
      {
         switch (c)
         {
            case  8: if (p > s) --p; break;
            case  0:
            case RS232_LF: c = RS232_CR;
            case RS232_CR: break;
            default: *p++ = c; break;
         }

   		if (crtscts && cbuf_used(spc_icbuf) <= serCrtsLo)
   		{
   			(*c_rtson)();
   		}

         if (!started) started = 1;
         chtm = MS_TIMER;  // timeout starts anew
      }
      else
      {
         if (started && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   *p=0;  // null terminate whether timed out, max length, or normal
	cbuf_rdunlock(spc_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(s, p - s, "RX-C");
#else
#ifdef RS232_MONITOR_C
	_RS232_echo(s, p - s, "RX-C");
#endif
#endif
   return !timedOut; //
}

/*** Beginheader cof_serCread */
scofunc int cof_serCread(void* data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serCread                   <RS232.LIB>

SYNTAX:		   int cof_serCread(void* data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port C or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which chsaracters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serCread(void* data, int length, unsigned long tmout)
{
   static int nread, timedOut;
   static int n;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spc_icbuf);
	}

   p = (char *)data;
	havelock=0;
	waitfor(cbuf_rdlock(spc_icbuf));
   havelock=1;

   n = nread = timedOut = 0;
   chtm = MS_TIMER;
   while(nread < length && !timedOut)
   {
      if ((n = cbuf_get(spc_icbuf, p + nread, length - nread)) > 0)
      {
         nread += n;
   		if (crtscts && cbuf_used(spc_icbuf) <= serCrtsLo)
   		{
   			(*c_rtson)();
   		}
         if(nread < length)
         {
            yield;
            chtm = MS_TIMER;      // timeout starts anew
         }
      }
      else
      {
         if (nread && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   cbuf_rdunlock(spc_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-C");
#else
#ifdef RS232_MONITOR_C
	_RS232_echo(p, nread, "RX-C");
#endif
#endif
   return nread;
}

/*** Beginheader cof_serCputc */
scofunc void cof_serCputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serCputc                   <RS232.LIB>

SYNTAX:		   void cof_serCputc(int c);

DESCRIPTION:   Writes a character to the C port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serCputc(int c)
{
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spc_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spc_ocbuf));
   havelock=1;

	waitfor(cbuf_putch(spc_ocbuf,c));

	spc_starttx();
	cbuf_wrunlock(spc_ocbuf);
#ifdef RS232_MONITOR
	if (c >= 0) printf(RS232_TXC, 'C', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_C
	if (c >= 0) printf(RS232_TXC, 'C', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
}

/*** Beginheader cof_serCputs */
scofunc void cof_serCputs(char *str);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serCputs                   <RS232.LIB>

SYNTAX:		   void cof_serCputs(char *str);

DESCRIPTION:   Writes a null terminated string to the C port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serCputs(char *str)
{
	static int bytesleft,length;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spc_ocbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spc_ocbuf));
   havelock=1;

	bytesleft=length=strlen(str);

	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spc_ocbuf,str+(length-bytesleft),bytesleft);
		spc_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spc_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(str, length, "TX-C");
#else
#ifdef RS232_MONITOR_C
	_RS232_echo(str, length, "TX-C");
#endif
#endif
}

/*** Beginheader cof_serCwrite */
scofunc void cof_serCwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serCwrite                   <RS232.LIB>

SYNTAX:		   void cof_serCwrite(void *data, int length);

DESCRIPTION:   Writes length bytes to the C port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serCwrite(void *data, int length)
{
	static int bytesleft;
   static char *v;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spc_ocbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spc_ocbuf));
   havelock=1;

   v = (char *)data;
	bytesleft=length;
	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spc_ocbuf,v+(length-bytesleft),bytesleft);
		spc_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spc_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(v, length, "TX-C");
#else
#ifdef RS232_MONITOR_C
	_RS232_echo(v, length, "TX-C");
#endif
#endif
}

/*** Beginheader serCflowcontrolOn */
void serCflowcontrolOn();
/*** endheader */

//defaults for flow control RTS/CTS
#ifndef SERC_RTS_PORT
#define SERC_RTS_PORT PCDR
#warnt "SERC_RTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERC_RTS_SHADOW
#define SERC_RTS_SHADOW PCDRShadow
#warnt "SERC_RTS_SHADOW not defined: defaulting to PCDRShadow"
#endif

#ifndef SERC_RTS_BIT
#define SERC_RTS_BIT 4
#warnt "SERC_RTS_BIT not defined: defaulting to 4"
#endif

#ifndef SERC_CTS_PORT
#define SERC_CTS_PORT PCDR
#warnt "SERC_CTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERC_CTS_BIT
#define SERC_CTS_BIT 5
#warnt "SERC_CTS_BIT not defined: defaulting to 5"
#endif

#asm root
spc_checkcts_fc::
	 bool	hl
;ioi ld 	a, (SERC_CTS_PORT)
	IOREAD_A(SERC_CTS_PORT)
	 and	1 << SERC_CTS_BIT
	 ld	L, a
	 ret

spc_rtsoff_fc::
	 ld	 a, (SERC_RTS_SHADOW)
	 set	 SERC_RTS_BIT, a		;set RTS high (inactive)
	 ld	 (SERC_RTS_SHADOW), a
;ioi ld	 (SERC_RTS_PORT), a
	IOWRITE_A(SERC_RTS_PORT)
	 ret

spc_rtson_fc::
	 ld	 a, (SERC_RTS_SHADOW)
	 res   SERC_RTS_BIT, a		;set RTS low (active)
	 ld	 (SERC_RTS_SHADOW), a
;ioi ld	 (SERC_RTS_PORT), a
	IOWRITE_A(SERC_RTS_PORT)
	 ret

#endasm

/* START FUNCTION DESCRIPTION ********************************************
serCflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serCflowcontrolOn();

DESCRIPTION:   Turns on hardware flow control for channel C. This enables two
					digital lines that handle flow control, CTS(clear to send)
					and RTS(ready to send).
					CTS is an input that will be pulled active low by the other
					system when it is ready to receive data. The RTS signal
					is an output that the system uses to indicate that it is
					ready to receive data. It is driven low when data can be
					received.
					If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros. This function is non-reentrant.

 					SERC_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERC_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERC_RTS_BIT - the bit number for the RTS line
 					SERC_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERC_CTS_BIT - the bit number for the CTS line

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serCflowcontrolOn()
{
	crtscts = 1;
	//set flow control ISR functions
	c_checkctsfunc = spc_checkcts_fc;
	c_rtsoff = spc_rtsoff_fc;
	c_rtson = spc_rtson_fc;
	serCrtsLo = (int)(CINBUFSIZE * 0.2);
	serCrtsHi = (int)(CINBUFSIZE * 0.8);
	// turn on RTS if buffer is below 80%
	if (serCrdUsed() < serCrtsHi)
	{
		(*c_rtson)();
	}
}

/*** Beginheader serCflowcontrolOff */
void serCflowcontrolOff();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serCflowcontrolOff();

DESCRIPTION:   Turns off hardware flow control for channel C.
               This function is non-reentrant.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serCflowcontrolOff()
{
	crtscts = 0;
}

/*** Beginheader serCparity */
void serCparity(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCparity                   <RS232.LIB>

SYNTAX:		   void serCparity(int state);

DESCRIPTION:   Sets parity type for channel C. This function is non-reentrant.

PARAMETER1:		A bit mask for selecting parity mode
					PARAM_EPARITY	0x01
					PARAM_OPARITY	0x02
					PARAM_2STOP 	0x03
					PARAM_NOPARITY 0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serCparity(int state)
{
	if (state)
	{
		if (state == PARAM_OPARITY)
		{
			cparity = 1;
			cparitytype = 0;
		}
		else if (state == PARAM_EPARITY)
		{
			cparity = 1;
			ctwostop = 0;
			cparitytype = 1;
		}
		else
		{
			cparity = 0;
			ctwostop = 1;
		}
	}
	else
	{
		cparity = 0;
		ctwostop = 0;
	}
	if(csevenbit && !cparity && !ctwostop)
	{
		BitWrPortI(SCCR, &SCCRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SCCR, &SCCRShadow, 0, 2);
	}
}

/*** Beginheader serCdatabits */
void serCdatabits(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCdatabits                   <RS232.LIB>

SYNTAX:		   void serCdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel C.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
					PARAM_7BIT	0x01
					PARAM_8BIT	0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serCdatabits(int state)
{
	if (state == PARAM_7BIT)
	{
		csevenbit = 1;
	}
	else
	{
		csevenbit = 0;
	}
	if(csevenbit && !cparity && !ctwostop)
	{
		BitWrPortI(SCCR, &SCCRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SCCR, &SCCRShadow, 0, 2);
	}
}

/*** Beginheader serCrdFlush */
void serCrdFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCrdFlush                  <RS232.LIB>

SYNTAX:		   void serCrdFlush();

DESCRIPTION:   Flushes the serial port C input buffer. This function is
               non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serCrdFlush()
{
	cbuf_flush(spc_icbuf);
}

/*** Beginheader serCwrFlush */
void serCwrFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCwrFlush                  <RS232.LIB>

SYNTAX:		   void serCwrFlush();

DESCRIPTION:   Flushes the serial port C transmit buffer. This function is
               non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serCwrFlush()
{
	cbuf_flush(spc_ocbuf);
}

/*** Beginheader serCrdFree */
int serCrdFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCrdFree                   <RS232.LIB>

SYNTAX:		   int serCrdFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port C input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the C input buffer
END DESCRIPTION **********************************************************/

nodebug int serCrdFree()
{
	return (int)cbuf_free(spc_icbuf);
}

/*** Beginheader serCwrFree */
int serCwrFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCwrFree                   <RS232.LIB>

SYNTAX:		   int serCwrFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port C transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the C transmit buffer
END DESCRIPTION **********************************************************/

nodebug int serCwrFree()
{
	return (int)cbuf_free(spc_ocbuf);
}

/*** Beginheader serCrdUsed */
int serCrdUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCrdUsed                   <RS232.LIB>

SYNTAX:		   int serCrdUsed();

DESCRIPTION:   Returns the number of characters in the C input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the C input buffer
END DESCRIPTION **********************************************************/

nodebug int serCrdUsed()
{
	return (int)cbuf_used(spc_icbuf);
}

/*** Beginheader serCwrUsed */
int serCwrUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCwrUsed                   <RS232.LIB>

SYNTAX:		   int serCwrUsed();

DESCRIPTION:   Returns the number of characters in the C output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the C output buffer
END DESCRIPTION **********************************************************/

nodebug int serCwrUsed()
{
	return (int)cbuf_used(spc_ocbuf);
}

/*** Beginheader serCclose */
void serCclose();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serCclose                   <RS232.LIB>

SYNTAX:		   void serCclose();

DESCRIPTION:   Disables the C serial port. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm xmem

serCclose::
    ld 	a, 0xc9
    ipset 1
#if _USER
c	 SetVectIntern(SERC_OFS/0x10, spc_dummyfunc);
#else
    ld	(INTVEC_BASE + SERC_OFS), a		; ret in first byte of spcisr_start
#endif

    ld    a,0x00        ; disable interrupts for port
    ld    (SCCRShadow),a
;ioi ld    (SCCR),a
	IOWRITE_A(SCCR)
    ld    a,(PCFRShadow)
    res	 CDRIVE_TXD, a    ;return to normal output
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ipres
    lret

#endasm

/*** Beginheader serCrtsLo, serCrtsHi, serCopen, serCgetError,
     spc_icbuf, spc_ocbuf */
extern int serCrtsLo;
extern int serCrtsHi;
int serCopen(long baud);
char serCgetError();
void spc_init();
root void spc_starttx();
root void cDisable();
root void cEnable();
root void spc_dummyfunc();
extern char spc_icbuf[];
extern char spc_ocbuf[];
extern char crtscts;
extern char cparity;
extern char cparitytype;
extern char csevenbit;
extern char ctwostop;
//pointers to flow control functions
extern int (*c_checkctsfunc)();
extern void (*c_rtsoff)();
extern void (*c_rtson)();
#define CDRIVE_TXD 2
extern char clongstop;
extern char coverrun;
extern char cparityerror;
extern char coverflow;
/*** endheader */

#undef CINBUFOK

#ifndef CINBUFSIZE
#define CINBUFSIZE 31
#warnt "CINBUFSIZE undefined, defaulting to 31"
#endif

#if (CINBUFSIZE & (CINBUFSIZE+1)) == 0
#define CINBUFOK 1
#endif

#ifndef CINBUFOK
#undef CINBUFSIZE
#define CINBUFSIZE 31
#warnt "CINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef COUTBUFOK

#ifndef COUTBUFSIZE
#define COUTBUFSIZE 31
#warnt "COUTBUFSIZE undefined, defaulting to 31"
#endif

#if (COUTBUFSIZE & (COUTBUFSIZE+1)) == 0
#define COUTBUFOK 1
#endif

#ifndef COUTBUFOK
#undef COUTBUFSIZE
#define COUTBUFSIZE 31
#warnt "COUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char spc_icbuf[CINBUFSIZE+9];
char spc_ocbuf[COUTBUFSIZE+9];

int  serCrtsLo;
int  serCrtsHi;
char clongstop;
char coverrun;
char coverflow;
char cparityerror;

char crtscts;
char cparity;
char cparitytype;
char csevenbit;
char ctwostop;
int (*c_checkctsfunc)();
void (*c_rtsoff)();
void (*c_rtson)();

/* START FUNCTION DESCRIPTION ********************************************
serCopen                   <RS232.LIB>

SYNTAX:		   int serCopen(long baud);

DESCRIPTION:   Opens the C serial port.
               This function is non-reentrant.

PARAMETER1:    baud : bits per second of data transfer

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

RELATED WORDS: serCgetc, serCgetc, serCpeek,
               serCputs, serCwrite,
               cof_serCgetc, cof_serCgets, cof_serCread,
               cof_serCputc, cof_serCputs, cof_serCwrite
               serCclose

END DESCRIPTION **********************************************************/

nodebug int serCopen(long baud)
{
   static long divisor, ta1div;
   static float baudratio;
	static unsigned long t;

   ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	WrPortI(TACR, &TACRShadow, TACRShadow | 0x40);  // set 'use port A' bit
	}
	else
	{
   	WrPortI(TACR, &TACRShadow, TACRShadow & ~0x40); // clear bit
	}

	crtscts = 0;
	csevenbit = 0;
	cparity = 0;
	cparitytype = 0;
	ctwostop = 0;
	clongstop = 0;
	cparityerror = 0;
	coverrun = 0;
	coverflow = 0;
	//use the dummy versions of the flow control functions
	//all they do is return. They are placeholders in case flow control
	//enabled
	c_checkctsfunc = spc_dummyfunc;
	c_rtsoff = spc_dummyfunc;
	c_rtson = spc_dummyfunc;
	WrPortI(TAT6R, &TAT6RShadow, (char)divisor);
   cbuf_init(spc_icbuf,CINBUFSIZE);
   cbuf_init(spc_ocbuf,COUTBUFSIZE);

   spc_init();
   t = MS_TIMER;
   // let baud timer time out before using port
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   cbuf_getch(spc_icbuf);
   cbuf_getch(spc_icbuf);
   baudratio = ((RS232_BASEFREQ*freq_divider) /
   	(32 * ((divisor & 0xff) + 1) + 0.5)) / (float)(baud * (ta1div + 1));
   return (baudratio > 0.95 && baudratio < 1.05);
}

/* START FUNCTION DESCRIPTION ********************************************
serCgetError                   <RS232.LIB>

SYNTAX:		   char serCgetError();

DESCRIPTION:   Returns the error flags byte for serial channel C
					This can then be compared against error bitmasks to determine
					what errors occured. Additionally, any bits set in the returned
					error flags will be automatically cleared. This function is
               non-reentrant.

					Error bitmasks:
						SER_PARITY_ERROR	0x01
						SER_OVERRUN_ERROR 0x02
						SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

END DESCRIPTION **********************************************************/

nodebug char serCgetError()
{
	static char error_flags;

	error_flags = 0;
	if	(coverrun)
	{
		error_flags |= SER_OVERRUN_ERROR;
		coverrun = 0;
	}
	if (cparityerror)
	{
		error_flags |= SER_PARITY_ERROR;
		cparityerror = 0;
	}
	if (coverflow)
	{
		error_flags |= SER_OVERFLOW_ERROR;
		coverflow = 0;
	}
	return error_flags;
}



#asm root

;
; interrupt routine to be copied into interrupt table
;

spcisr_start::
    call  spc_isr       ; 19
    ret                 ; 8

spc_dummyfunc::
	ret
#endasm

#asm xmem
;
; spc_init
;

spc_init::
#if _USER
    ipset 1
c	 SetVectIntern(SERC_OFS/0x10, spcisr_start);
#else
	 ld de, INTVEC_BASE + SERC_OFS
	 ld hl, spcisr_start
    ld    bc,0x0010     ; copy 16 bytes from spcisr_start into interrupt table
    ipset 1

	#if __SEPARATE_INST_DATA__
	    call inst2data_ldir
	#else
	    ldir
	#endif
#endif

    ld	 a, (PCDRShadow)
    set	 CDRIVE_TXD, a    ;Tx should initially be idle high
    ld	 (PCDRShadow), a
;ioi ld	 (PCDR), a
	IOWRITE_A(PCDR)
    ld    a,(PCFRShadow)
    set	 CDRIVE_TXD, a	   ;enable serial
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ld    a,0x01        ; enable interrupts for port
    ld    (SCCRShadow),a
;ioi ld    (SCCR),a
	IOWRITE_A(SCCR)
	 ipres
	 lret
#endasm

#asm root
spc_starttx::				;called by C put routines to start up interrupt loop,
								; if tx is idle
	 push	 af				; cbuf_getch inside of spc_txload uses most of
	 							; the registers
	 push	 bc
	 push	 de
	 push	 hl
	 ipset 1

;ioi ld	 a, (SCSR)
	IOREAD_A(SCSR)
	 bit	 2, a
	 jr	 nz, spc_starttx_exit	;if tx is busy then it will catch
	 										; is in the buffer
	 ld	 a, (crtscts)
	 or	 a
	 jr	 z, spc_starttx_load

	 call  spc_checkcts
	 bool	 hl
	 jr	 nz, spc_starttx_dummy

spc_starttx_load:
	 call	 cEnable
	 call	 spc_txload
	 jr	 spc_starttx_exit

spc_starttx_dummy:
	 call	 cDisable
	 ld	 a, 23
;ioi ld	 (SCDR), a
	IOWRITE_A(SCDR)

spc_starttx_exit:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

cDisable::
	 ld    a,(PCDRShadow)
    set   CDRIVE_TXD,a	  ;make sure Tx is high(idle)
    ld    (PCDRShadow),a
;ioi ld    (PCDR),a
	IOWRITE_A(PCDR)
    ld    a,(PCFRShadow)
    res   CDRIVE_TXD,a
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ret


cEnable::
    ld    a,(PCFRShadow)
    set   CDRIVE_TXD,a
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ret


spc_checkcts::				;hl will be non-zero if CTS is high, uses register a
	 ld	hl, (c_checkctsfunc)
	 jp	(hl)

;
; spc_txload
;

spc_txload::
	 ld	 a, (clongstop)	;check if we are in a long stop
	 or	 a
	 jp	 nz, spc_txload_exit		;don't load a byte if we have a long stop

    ld    hl,spc_ocbuf  ; 6,	retrieve character from circular buffer
    push  hl            ; 10
    lcall  cbuf_getch    ; 12+...
    add	 sp, 2
    bit   7,h           ; 4,	was there a character?
    jp    nz,spc_txload_exit

	 ld	 a, (ctwostop)
	 or	 a
	 jp	 nz, spc_txload_2stop

	 ld	 a, (cparity)	;check to see if we need to add a parity bit
	 or	 a
	 jp	 z, spc_txload_sendbyte
	 ld	 a, (csevenbit) ;are we doing 7 or 8 bit data?
	 or	 a
	 jr	 nz, spc_txload_7bitparity
spc_txload_8bitparity:
	 push	 hl	;save the byte value
	 ld	 a, (cparitytype)
	 ld	 h, a
	 lcall	ser8_getparity
	 bool  hl
	 pop 	 hl
	 jr	 z, spc_txload_9bitlow

#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
spc_txload_9bithigh:
	 ld	 a, L
;ioi ld	 (SCLR), a
	IOWRITE_A(SCLR)
	 jr	 spc_txload_exit
#else
spc_txload_9bithigh:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, spc_txload_setlongstop
	 ld	 a, L
;ioi ld	 (SCLR), a
	IOWRITE_A(SCLR)
	 jr	 spc_txload_exit

spc_txload_setlongstop:
	 ld	 a, 0x01
	 ld	 (clongstop), a	;set the long stop flag
	 jp	 spc_txload_sendbyte
#endif

spc_txload_9bitlow:
	 ld	 a, L
;ioi ld	 (SCAR), a			;load byte into alternate register
	IOWRITE_A(SCAR)
	 jr	 spc_txload_exit

spc_txload_7bitparity:
	 ld	 a, (cparitytype)
	 ld	 h, a
	 lcall ser7_setparity
	 jp	 spc_txload_sendbyte

spc_txload_2stop:
	 ld	 a, (csevenbit)
	 or	 a
	 jr	 z, spc_txload_9bithigh			;8data + 2stop = 9th bit high
	 ld	 a, L
	 or	 0x80									;7data + 2stop = 8th bit high
	 ld	 L, a
spc_txload_sendbyte:
    ld	 a, L
;ioi ld	 (SCDR), a
	IOWRITE_A(SCDR)
spc_txload_exit:
	 ret
#endasm

/*** BeginHeader spc_isr */
root void spc_isr(void);
/*** EndHeader */

#asm
;
; spc_isr
;

spc_isr::
	 push	af					; 7, 	restore registers needed by isr
	 push	bc					; 7
	 push	de					; 7
	 push	hl					; 7

;ioi ld	 a,(SCSR)			; 11,	interrupt source rx or tx
	IOREAD_A(SCSR)
#if (_USER)
	;acknowledge interrupt immediately for RabbitSys
	IOWRITE_A(SCSR)
#endif
	 ld    c,a
	 rla						; 2
	 jp	 c,spc_rx			; 5

spc_tx:
    bit   2,c           ; Tx busy? bit 2 shifted via rla
    jr    nz,spc_txbusy
spc_txidle:             ; Tx idle, safe for enable/disable transition
	 ld	 a, (clongstop)
	 or	 a
	 jr	 nz, spc_dolongstop	;handle request for a long stop bit

	 ld 	 a, (crtscts)
	 or	 a
    jr	 z, spc_trytosend ;try one more time to load a byte
	 call  spc_checkcts
	 bool	 hl
	 jr	 nz, spc_disabletx

spc_trytosend:
	 call	 cEnable
	 call	 spc_txload				;CTS is on, so try to load a normal byte
	 jr	 spc_donomore

spc_dolongstop:
	 xor	 a
	 ld	 (clongstop), a		;clear out the long stop flag
spc_disabletx:
	 call  cDisable
	 ld	 a, 42
;ioi ld	 (SCDR), a				; load 42 into SCDR as a dummy byte,
	IOWRITE_A(SCDR)
										; to keep the interrupt loop going
	 jr	 spc_donomore

spc_txbusy:
    ld    a,(PCFRShadow)		; check to make sure tx is enabled
    bit   CDRIVE_TXD,a			; if not, dummy character still needs to
    									; clear out
    jr    z, spc_donomore
	 ld 	 a, (crtscts)			; are we using CTS?
	 or	 a
    jr	 z, spc_txallgood
	 call  spc_checkcts
	 bool	 hl
	 jr	 nz, spc_donomore		; CTS is off, don't fill SCDR
spc_txallgood:
	 call	 spc_txload				; will load a good byte,
	 									; if there is one to be loaded
spc_donomore:
;ioi ld    (SCSR),a      ; 10,	clear interrupt source
#if !(_USER)
	IOWRITE_A(SCSR)
#endif
    ipres               ; 4
    pop   hl            ; 7, 	restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

spc_rx:
;ioi ld    a,(SCDR)      ; 11,	receive the character
	IOREAD_A(SCDR)
    bool  hl            ; 2,	place character on circular buffer
    ld    l,a           ; 2,		throw it away if no room
	 ld	 b,a				;save for later possible parity check
	 ld	 a, (csevenbit)
	 or	 a
	 jr	 z, spc_rxcontinue
	 ld	 a, L
	 and	 0x7f
	 ld	 L, a				;mask out MSB for 7 bit data
spc_rxcontinue:
	 push	 bc				;save byte copy and status register copy
    push  hl            ; 10
    ld    hl,spc_icbuf  ; 6
    push  hl            ; 10
    lcall  cbuf_putch	   ; 12+...
    add   sp,4          ; 4
	 bool	 hl
	 jr	 nz, spc_checkoverrun
	 ld	 a, 0x01
	 ld	 (coverflow), a  ;no room in input buffer
 spc_checkoverrun:
    pop	 bc
    bit	 5, c				;test for receiver overrun
    jr	 z, spc_checkparity
    ld	 a, 0x01
    ld	 (coverrun), a

spc_checkparity:
	 ld	 a, (cparity)
	 or	 a								;see if we need to check parity of
	 										; incoming byte
	 jr	 z, spc_rx_flowcontrol
	 ld	 a, (csevenbit)
	 or	 a
	 jr	 nz, spc_check7bit
spc_check8bit:
	 ld	 l, b
	 ld	 a, (cparitytype)
	 ld	 h, a
	 lcall ser8_getparity
	 bool  hl
	 jr	 z, spc_check9low
spc_check9high:						; 9th parity bit should be high,
											; otherwise we have a parity error
	 bit	 6, c							; C reg should still have a snapshot of
	 										; the status register, checking bit 9
	 jr	 z, spc_rx_flowcontrol	; no 9th bit detected (9th bit high),
	 										; so we are OK
	 ld	 a, 0x01
	 ld	 (cparityerror), a				;signal a parity error
	 jr	 spc_rx_flowcontrol
spc_check9low:
	 bit	 6, c
	 jr	 nz, spc_rx_flowcontrol	; 9th bit detected (9th bit low),
	 										; which is what we expect
	 ld	 a, 0x01
	 ld	 (cparityerror), a
	 jr	 spc_rx_flowcontrol
spc_check7bit:
	 ld	 l, b
	 ld	 a, (cparitytype)
	 ld	 h, a
	 lcall ser7_checkparity
	 bool	 hl
	 jr	 nz, spc_rx_flowcontrol
	 ld	 a, 0x01
	 ld	 (cparityerror), a

spc_rx_flowcontrol:
    ld    a,(crtscts)
    or    a
    jr    z,spc_rx0
    ld    hl,spc_icbuf  ;
    push  hl            ;
    lcall  cbuf_used     ;
    add   sp,2          ;
    ld    d,h
    ld    e,l
    ld    b,d
    ld    c,e           ; copy number bytes used to bc
    ld    hl,(serCrtsHi);
    ld    a,d           ;
    cp    h             ;
    jr    c,spc_rx0     ;
    ld    a,e           ;
    cp    l             ;
    jr    c,spc_rx0     ;
spc_overHi:    			; turn off the RTS line
	 ld	 hl, spc_rx0
	 push	 hl				;set return address
	 ld	 hl, (c_rtsoff)
	 jp	 (hl)

spc_rx0:
    ipres               ; 4
    pop   hl            ; 7,  restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

#endasm

//************************************************************************
//****************************** PORT D **********************************
//************************************************************************

/*** Beginheader serDgetc */
int  serDgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDgetc                     <RS232.LIB>

SYNTAX:	      int serDgetc();

DESCRIPTION:   Get next available character from serial port D read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	success: the next character in the low byte, 0 in the high byte
               failure: the integer -1

END DESCRIPTION **********************************************************/

nodebug int serDgetc()
{
   static int n;

   if (cbuf_rdlock(spd_icbuf))
   {
      n = cbuf_getch(spd_icbuf);
      if (drtscts && cbuf_used(spd_icbuf) <= serDrtsLo)
      {
      	(*d_rtson)();
      }
      cbuf_rdunlock(spd_icbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_RXC, 'D', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_D
	   if (n >= 0) printf(RS232_RXC, 'D', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = -1;
   }
   return n;
}

/*** Beginheader serDread */
int  serDread(void *data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDread                   <RS232.LIB>

SYNTAX:		   int serDread(void *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from serial port D or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port D
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port D

END DESCRIPTION **********************************************************/

nodebug int serDread(void *data, int length, unsigned long tmout)
{
   static int  n, nread, timedOut;
   static char *p;
   static unsigned long chtm;

   p = (char *)data;
   nread = timedOut = 0;

   if (cbuf_rdlock(spd_icbuf))
   {
      chtm = MS_TIMER;
      while (nread < length && !timedOut)
      {
      	// once in, finish or timeout
         if ((n = cbuf_get(spd_icbuf, p + nread, length - nread)) > 0)
         {
      		if (drtscts && cbuf_used(spd_icbuf) <= serDrtsLo)
      		{
      			(*d_rtson)();
      		}
            chtm = MS_TIMER;
            nread += n;
         }
         else
         {
            if (nread)
            {
               if (MS_TIMER - chtm >= tmout)
               {
                  timedOut = 1;
               }
            }
            else
            {
               break;   // just break out of while if
                        // we have not yet begun to read data
            }
         }
      }
	   cbuf_rdunlock(spd_icbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-D");
#else
#ifdef RS232_MONITOR_D
	_RS232_echo(p, nread, "RX-D");
#endif
#endif
   return nread;
}

/*** Beginheader serDpeek */
int serDpeek();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDpeek                   <RS232.LIB>

SYNTAX:		   int serDpeek();

DESCRIPTION:   Returns the 1st character of the data in the D input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not
END DESCRIPTION **********************************************************/

nodebug int serDpeek()
{
  return (int)cbuf_peek(spd_icbuf);
}

/*** Beginheader serDputc */
int serDputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDputc                     <RS232.LIB>

SYNTAX:	      int serDputc(char c);

DESCRIPTION:   Write a character to serial port D write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port D write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

END DESCRIPTION **********************************************************/

nodebug int serDputc(int c)
{
   static int n;

   if (cbuf_wrlock(spd_ocbuf))
   {
      n = cbuf_putch(spd_ocbuf, c);
      if (n)
      {
      	spd_starttx();
      }
      cbuf_wrunlock(spd_ocbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_TXC, 'D', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_D
	   if (n >= 0) printf(RS232_TXC, 'D', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = 0;
   }
   return n;
}

/*** Beginheader serDputs */
int serDputs(char *s);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDputs                     <RS232.LIB>

SYNTAX:     	int serDputs(char* s);

DESCRIPTION:   Calls serDwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port D.

END DESCRIPTION **********************************************************/

nodebug int serDputs(char *s)
{
   return serDwrite(s, strlen(s));
}

/*** Beginheader serDwrite */
int serDwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDwrite                   <RS232.LIB>

SYNTAX:		   int serDwrite(void *data, int length);

DESCRIPTION:   Transmits length bytes to serial port D.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port D
               length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port D.

END DESCRIPTION **********************************************************/

nodebug int serDwrite(void *data, int length)
{
   static int bytesleft;
   static char *p;

   p = (char *)data;
   bytesleft = length;
   if (cbuf_wrlock(spd_ocbuf))
   {
      while (bytesleft)
      {
         bytesleft -= cbuf_put(spd_ocbuf, p+(length-bytesleft), bytesleft);
         spd_starttx();
      }
      cbuf_wrunlock(spd_ocbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, length - bytesleft, "TX-D");
#else
#ifdef RS232_MONITOR_D
	_RS232_echo(p, length - bytesleft, "TX-D");
#endif
#endif
   return length - bytesleft;
}

/*** Beginheader cof_serDgetc */
scofunc int cof_serDgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serDgetc                   <RS232.LIB>

SYNTAX:		   int cof_serDgetc();

DESCRIPTION:   Yields to other tasks until a character is read from port D.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port D

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serDgetc()
{
	static int c;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spd_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spd_icbuf));
	havelock=1;

	waitfor((c=cbuf_getch(spd_icbuf)) != -1);

   if (drtscts && cbuf_used(spd_icbuf) <= serDrtsLo)
   {
   	(*d_rtson)();
   }

	cbuf_rdunlock(spd_icbuf);
#ifdef RS232_MONITOR
   if (c >= 0) printf(RS232_RXC, 'D', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_D
   if (c >= 0) printf(RS232_RXC, 'D', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
	return c;
}

/*** Beginheader cof_serDgets */
scofunc int cof_serDgets(char *s, int max, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serDgets                   <RS232.LIB>

SYNTAX:		   int cof_serDgets(char *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port D until a null terminator, carriage
					return or linefeed is read, max characters are read, or until
					tmout milliseconds transpires between characters after the
					first one is read. It yields to other tasks for as long as
					the input buffer is locked or whenever the buffer becomes
					empty as characters are read. s will always be null terminated
					upon return. This function is non-reentrant.

PARAMETER1:    s    : Character array into which a null terminated string
                      is read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serDgets(char *s, int max, unsigned long tmout)
{
   static int  c, started, timedOut;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spd_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spd_icbuf));
   havelock=1;

   p = s;
   c = started = timedOut = 0;

   while (c != RS232_CR && p-s < max && !timedOut)
   {
      if ((c = cbuf_getch(spd_icbuf)) != -1)
      {
         switch (c)
         {
            case  8: if (p > s) --p; break;
            case  0:
            case RS232_LF: c = RS232_CR;
            case RS232_CR: break;
            default: *p++ = c; break;
         }

   		if (drtscts && cbuf_used(spd_icbuf) <= serDrtsLo)
   		{
   			(*d_rtson)();
   		}

         if (!started) started = 1;
         chtm = MS_TIMER;  // timeout starts anew
      }
      else
      {
         if (started && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   *p=0;  // null terminate whether timed out, max length, or normal
	cbuf_rdunlock(spd_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(s, p - s, "RX-D");
#else
#ifdef RS232_MONITOR_D
	_RS232_echo(s, p - s, "RX-D");
#endif
#endif
   return !timedOut; //
}

/*** Beginheader cof_serDread */
scofunc int cof_serDread(void* data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serDread                   <RS232.LIB>

SYNTAX:		   int cof_serDread(void* data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port D or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which chsaracters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serDread(void* data, int length, unsigned long tmout)
{
   static int nread, timedOut;
   static int n;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spd_icbuf);
	}

   p = (char *)data;
	havelock=0;
	waitfor(cbuf_rdlock(spd_icbuf));
   havelock=1;

   n = nread = timedOut = 0;
   chtm = MS_TIMER;
   while(nread < length && !timedOut)
   {
      if ((n = cbuf_get(spd_icbuf, p + nread, length - nread)) > 0)
      {
         nread += n;
   		if (drtscts && cbuf_used(spd_icbuf) <= serDrtsLo)
   		{
   			(*d_rtson)();
   		}
         if(nread < length)
         {
            yield;
            chtm = MS_TIMER;      // timeout starts anew
         }
      }
      else
      {
         if (nread && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   cbuf_rdunlock(spd_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-D");
#else
#ifdef RS232_MONITOR_D
	_RS232_echo(p, nread, "RX-D");
#endif
#endif
   return nread;
}

/*** Beginheader cof_serDputc */
scofunc void cof_serDputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serDputc                   <RS232.LIB>

SYNTAX:		   void cof_serDputc(int c);

DESCRIPTION:   Writes a character to the D port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serDputc(int c)
{
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spd_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spd_ocbuf));
   havelock=1;

	waitfor(cbuf_putch(spd_ocbuf,c));

	spd_starttx();
	cbuf_wrunlock(spd_ocbuf);
#ifdef RS232_MONITOR
	if (c >= 0) printf(RS232_TXC, 'D', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_D
	if (c >= 0) printf(RS232_TXC, 'D', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
}

/*** Beginheader cof_serDputs */
scofunc void cof_serDputs(char *str);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serDputs                   <RS232.LIB>

SYNTAX:		   void cof_serDputs(char *str);

DESCRIPTION:   Writes a null terminated string to the D port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serDputs(char *str)
{
	static int bytesleft,length;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spd_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spd_ocbuf));
   havelock=1;

	bytesleft=length=strlen(str);

	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spd_ocbuf,str+(length-bytesleft),bytesleft);
		spd_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spd_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(str, length, "TX-D");
#else
#ifdef RS232_MONITOR_D
	_RS232_echo(str, length, "TX-D");
#endif
#endif
}

/*** Beginheader cof_serDwrite */
scofunc void cof_serDwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serDwrite                   <RS232.LIB>

SYNTAX:		   void cof_serDwrite(void *data, int length);

DESCRIPTION:   Writes length bytes to the D port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serDwrite(void *data, int length)
{
	static int bytesleft;
   static char *v;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spd_ocbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spd_ocbuf));
   havelock=1;

   v = (char *)data;
	bytesleft=length;
	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spd_ocbuf,v+(length-bytesleft),bytesleft);
		spd_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spd_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(v, length, "TX-D");
#else
#ifdef RS232_MONITOR_D
	_RS232_echo(v, length, "TX-D");
#endif
#endif
}

/*** Beginheader serDflowcontrolOn */
void serDflowcontrolOn();
/*** endheader */
//defaults for flow control RTS/CTS

#ifndef SERD_RTS_PORT
#define SERD_RTS_PORT PBDR
#warnt "SERD_RTS_PORT not defined: defaulting to PBDR"
#endif

#ifndef SERD_RTS_SHADOW
#define SERD_RTS_SHADOW PBDRShadow
#warnt "SERD_RTS_SHADOW not defined: defaulting to PBDRShadow"
#endif

#ifndef SERD_RTS_BIT
#define SERD_RTS_BIT 6
#warnt "SERD_RTS_BIT not defined: defaulting to 6"
#endif

#ifndef SERD_CTS_PORT
#define SERD_CTS_PORT PBDR
#warnt "SERD_CTS_PORT not defined: defaulting to PBDR"
#endif

#ifndef SERD_CTS_BIT
#define SERD_CTS_BIT 6
#warnt "SERD_CTS_BIT	not defined: defaulting to 6"
#endif

#asm root
spd_checkcts_fc::
	 bool	hl
;ioi ld 	a, (SERD_CTS_PORT)
	IOREAD_A(SERD_CTS_PORT)
	 and	1 << SERD_CTS_BIT
	 ld	L, a
	 ret

spd_rtsoff_fc::
	 ld	 a, (SERD_RTS_SHADOW)
	 set	 SERD_RTS_BIT, a		;set RTS high (inactive)
	 ld	 (SERD_RTS_SHADOW), a
;ioi ld	 (SERD_RTS_PORT), a
	IOWRITE_A(SERD_RTS_PORT)
	 ret

spd_rtson_fc::
	 ld	 a, (SERD_RTS_SHADOW)
	 res   SERD_RTS_BIT, a		;set RTS low (active)
	 ld	 (SERD_RTS_SHADOW), a
;ioi ld	 (SERD_RTS_PORT), a
	IOWRITE_A(SERD_RTS_PORT)
	 ret

#endasm

/* START FUNCTION DESCRIPTION ********************************************
serDflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serDflowcontrolOn();

DESCRIPTION:   Turns on hardware flow control for channel D. This enables two
					digital lines that handle flow control, CTS(clear to send)
					and RTS(ready to send).
					CTS is an input that will be pulled active low by the other
					system when it is ready to receive data. The RTS signal
					is an output that the system uses to indicate that it is
					ready to receive data. It is driven low when data can be
					received.
					If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros. This function is non-reentrant.

 					SERD_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERD_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERD_RTS_BIT - the bit number for the RTS line
 					SERD_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERD_CTS_BIT - the bit number for the CTS line

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serDflowcontrolOn()
{
	drtscts = 1;
	//set flow control ISR functions
	d_checkctsfunc = spd_checkcts_fc;
	d_rtsoff = spd_rtsoff_fc;
	d_rtson = spd_rtson_fc;
	serDrtsLo = (int)(DINBUFSIZE * 0.2);
	serDrtsHi = (int)(DINBUFSIZE * 0.8);
	// turn on RTS if buffer is below 80%
	if (serDrdUsed() < serDrtsHi)
	{
		(*d_rtson)();
	}
}

/*** Beginheader serDflowcontrolOff */
void serDflowcontrolOff();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serDflowcontrolOff();

DESCRIPTION:   Turns off hardware flow control for channel D.
               This function is non-reentrant.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serDflowcontrolOff()
{
	drtscts = 0;
}

/*** Beginheader serDparity */
void serDparity(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDparity                   <RS232.LIB>

SYNTAX:		   void serDparity(int state);

DESCRIPTION:   Sets parity type for channel D. This function is non-reentrant.

PARAMETER1:		A bit mask for selecting parity mode
					PARAM_EPARITY	0x01
					PARAM_OPARITY	0x02
					PARAM_2STOP 	0x03
					PARAM_NOPARITY 0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serDparity(int state)
{
	if (state)
	{
		if (state == PARAM_OPARITY)
		{
			dtwostop = 0;
	 		dparity = 1;
			dparitytype = 0;
		}
		else if (state == PARAM_EPARITY)
		{
			dtwostop = 0;
			dparity = 1;
			dparitytype = 1;
		}
		else
		{
			dtwostop = 1;
		}
	}
	else
	{
		dtwostop = 0;
		dparity = 0;
	}
	if(dsevenbit && !dparity && !dtwostop)
	{
		BitWrPortI(SDCR, &SDCRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SDCR, &SDCRShadow, 0, 2);
	}
}

/*** Beginheader serDdatabits */
void serDdatabits(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDdatabits                   <RS232.LIB>

SYNTAX:		   void serDdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel D.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
					PARAM_7BIT	0x01
					PARAM_8BIT	0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serDdatabits(int state)
{
	if (state == PARAM_7BIT)
	{
		dsevenbit = 1;
	}
	else
	{
		dsevenbit = 0;
	}
	if(dsevenbit && !dparity && !dtwostop)
	{
		BitWrPortI(SDCR, &SDCRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SDCR, &SDCRShadow, 0, 2);
	}
}

/*** Beginheader serDrdFlush */
void serDrdFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDrdFlush                  <RS232.LIB>

SYNTAX:		   void serDrdFlush();

DESCRIPTION:   Flushes the serial port D input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serDrdFlush()
{
	cbuf_flush(spd_icbuf);
}

/*** Beginheader serDwrFlush */
void serDwrFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDwrFlush                  <RS232.LIB>

SYNTAX:		   void serDwrFlush();

DESCRIPTION:   Flushes the serial port D transmit buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serDwrFlush()
{
	cbuf_flush(spd_ocbuf);
}

/*** Beginheader serDrdFree */
int serDrdFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDrdFree                   <RS232.LIB>

SYNTAX:		   int serDrdFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port D input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the D input buffer
END DESCRIPTION **********************************************************/

nodebug int serDrdFree()
{
	return (int)cbuf_free(spd_icbuf);
}

/*** Beginheader serDwrFree */
int serDwrFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDwrFree                   <RS232.LIB>

SYNTAX:		   int serDwrFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port D transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the D transmit buffer
END DESCRIPTION **********************************************************/

nodebug int serDwrFree()
{
	return (int)cbuf_free(spd_ocbuf);
}

/*** Beginheader serDrdUsed */
int serDrdUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDrdUsed                   <RS232.LIB>

SYNTAX:		   int serDrdUsed();

DESCRIPTION:   Returns the number of characters in the D input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the D input buffer
END DESCRIPTION **********************************************************/

nodebug int serDrdUsed()
{
	return (int)cbuf_used(spd_icbuf);
}

/*** Beginheader serDwrUsed */
int serDwrUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDwrUsed                   <RS232.LIB>

SYNTAX:		   int serDwrUsed();

DESCRIPTION:   Returns the number of characters in the D output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the D output buffer
END DESCRIPTION **********************************************************/

nodebug int serDwrUsed()
{
	return (int)cbuf_used(spd_ocbuf);
}

/*** Beginheader serDclose */
void serDclose();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serDclose                   <RS232.LIB>

SYNTAX:		   void serDclose();

DESCRIPTION:   Disables the D serial port. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm xmem

serDclose::
    ld 	a, 0xc9
    ipset 1
#if _USER
c	 SetVectIntern(SERD_OFS/0x10, spd_dummyfunc);
#else
    ld	(INTVEC_BASE + SERD_OFS), a		; ret in first byte of spdisr_start
#endif

    ld    a,0x00        ; disable interrupts for port
    ld    (SDCRShadow),a
;ioi ld    (SDCR),a
	IOWRITE_A(SDCR)
    ld    a,(PCFRShadow)
    res	 DDRIVE_TXD, a    ;return to normal output
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ipres
    lret

#endasm

/*** Beginheader serDrtsLo, serDrtsHi, serDopen, serDgetError,
     spd_icbuf, spd_ocbuf */
extern int serDrtsLo;
extern int serDrtsHi;
int serDopen(long baud);
char serDgetError();
void spd_init();
root void spd_starttx();
root void dDisable();
root void dEnable();
root void spd_dummyfunc();
extern char spd_icbuf[];
extern char spd_ocbuf[];
extern char drtscts;
extern char dparity;
extern char dparitytype;
extern char dsevenbit;
extern char dtwostop;
//pointers to flow control functions
extern int (*d_checkctsfunc)();
extern void (*d_rtsoff)();
extern void (*d_rtson)();
#define DDRIVE_TXD 0
extern char dlongstop;
extern char doverrun;
extern char dparityerror;
extern char doverflow;
/*** endheader */

#undef DINBUFOK

#ifndef DINBUFSIZE
#define DINBUFSIZE 31
#warnt "DINBUFSIZE undefined, defaulting to 31"
#endif

#if (DINBUFSIZE & (DINBUFSIZE+1)) == 0
#define DINBUFOK 1
#endif

#ifndef DINBUFOK
#undef DINBUFSIZE
#define DINBUFSIZE 31
#warnt "DINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef DOUTBUFOK

#ifndef DOUTBUFSIZE
#define DOUTBUFSIZE 31
#warnt "DOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (DOUTBUFSIZE & (DOUTBUFSIZE+1)) == 0
#define DOUTBUFOK 1
#endif

#ifndef DOUTBUFOK
#undef DOUTBUFSIZE
#define DOUTBUFSIZE 31
#warnt "DOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char spd_icbuf[DINBUFSIZE+9];
char spd_ocbuf[DOUTBUFSIZE+9];

int  serDrtsLo;
int  serDrtsHi;
char dlongstop;
char doverrun;
char doverflow;
char dparityerror;

char drtscts;
char dparity;
char dparitytype;
char dsevenbit;
char dtwostop;
int (*d_checkctsfunc)();
void (*d_rtsoff)();
void (*d_rtson)();

/* START FUNCTION DESCRIPTION ********************************************
serDopen                   <RS232.LIB>

SYNTAX:		   int serDopen(long baud);

DESCRIPTION:   Opens the D serial port.
               This function is non-reentrant.

PARAMETER1:    baud : bits per second of data transfer

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

RELATED WORDS: serDgetc, serDgetc, serDpeek,
               serDputs, serDwrite,
               cof_serDgetc, cof_serDgets, cof_serDread,
               cof_serDputc, cof_serDputs, cof_serDwrite
               serDclose

END DESCRIPTION **********************************************************/

nodebug int serDopen(long baud)
{
   static long divisor, ta1div;
   static float baudratio;
	static unsigned long t;

   ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	WrPortI(TACR, &TACRShadow, TACRShadow | 0x80);  // set 'use port A' bit
	}
	else
	{
   	WrPortI(TACR, &TACRShadow, TACRShadow & ~0x80); // clear bit
	}

	drtscts = 0;
	dsevenbit = 0;
	dparity = 0;
	dparitytype = 0;
	dtwostop = 0;
	dlongstop = 0;
	dparityerror = 0;
	doverrun = 0;
	doverflow = 0;
	//use the dummy versions of the flow control functions
	//all they do is return. They are placeholders in case flow control
	//enabled
	d_checkctsfunc = spd_dummyfunc;
	d_rtsoff = spd_dummyfunc;
	d_rtson = spd_dummyfunc;
	WrPortI(TAT7R, &TAT7RShadow, (char)divisor);
   cbuf_init(spd_icbuf,DINBUFSIZE);
   cbuf_init(spd_ocbuf,DOUTBUFSIZE);

   spd_init();
   t = MS_TIMER;
   // let baud timer time out before using port
   while (MS_TIMER - t < 1000 / (baud / 10)) ;
   cbuf_getch(spd_icbuf);
   cbuf_getch(spd_icbuf);
   baudratio = ((RS232_BASEFREQ*freq_divider) /
   	(32 * ((divisor & 0xff) + 1) + 0.5)) / (float)(baud * (ta1div + 1));
   return (baudratio > 0.95 && baudratio < 1.05);
}


/* START FUNCTION DESCRIPTION ********************************************
serDgetError                   <RS232.LIB>

SYNTAX:		   char serDgetError();

DESCRIPTION:   Returns the error flags byte for serial channel D
					This can then be compared against error bitmasks to determine
					what errors occured. Additionally, any bits set in the returned
					error flags will be automatically cleared. This function is
               non-reentrant.

					Error bitmasks:
						SER_PARITY_ERROR	0x01
						SER_OVERRUN_ERROR 0x02
						SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

END DESCRIPTION **********************************************************/

nodebug char serDgetError()
{
	static char error_flags;

	error_flags = 0;
	if	(doverrun)
	{
		error_flags |= SER_OVERRUN_ERROR;
		doverrun = 0;
	}
	if (dparityerror)
	{
		error_flags |= SER_PARITY_ERROR;
		dparityerror = 0;
	}
	if (doverflow)
	{
		error_flags |= SER_OVERFLOW_ERROR;
		doverflow = 0;
	}
	return error_flags;
}

#asm root

;
; interrupt routine to be copied into interrupt table
;

spdisr_start::
    call	 spd_isr       ; 19
    ret                 ; 8

spd_dummyfunc::
	ret
#endasm

#asm xmem
;
; spd_init
;

spd_init::
#if _USER
	 ipset 1
c	 SetVectIntern(SERD_OFS/0x10, spdisr_start);
#else
	 ld de, INTVEC_BASE + SERD_OFS
	 ld hl, spdisr_start
    ld    bc,0x0010     ; copy 16 bytes from spdisr_start into interrupt table
    ipset 1

	#if __SEPARATE_INST_DATA__
	    call inst2data_ldir
	#else
	    ldir
	#endif
#endif

    ld	 a, (PCDRShadow)
    set	 DDRIVE_TXD, a    ;Tx should initially be idle high
    ld	 (PCDRShadow), a
;ioi ld	 (PCDR), a
	IOWRITE_A(PCDR)
    ld    a,(PCFRShadow)
    set	 DDRIVE_TXD, a    ;Tx should initially be idle high
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ld    a,0x01        ; enable interrupts for port
    ld    (SDCRShadow),a
;ioi ld    (SDCR),a
	IOWRITE_A(SDCR)
    ipres
    lret
#endasm

#asm root
spd_starttx::				; called by C put routines to start up interrupt
								; loop, if tx is idle
	 push	 af				; cbuf_getch inside of spd_txload uses most of
	 							; the registers
	 push	 bc
	 push	 de
	 push	 hl
	 ipset 1

;ioi ld	 a, (SDSR)
	IOREAD_A(SDSR)
	 bit	 2, a
	 jr	 nz, spd_starttx_exit	; if tx is busy then it will catch
	 										; is in the buffer
	 ld	 a, (drtscts)
	 or	 a
	 jr	 z, spd_starttx_load

	 call  spd_checkcts
	 bool	 hl
	 jr	 nz, spd_starttx_dummy

spd_starttx_load:
	 call	 dEnable
	 call	 spd_txload
	 jr	 spd_starttx_exit

spd_starttx_dummy:
	 call	 dDisable
	 ld	 a, 23
;ioi ld	 (SDDR), a
	IOWRITE_A(SDDR)

spd_starttx_exit:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

dDisable::
	 ld    a,(PCDRShadow)
    set   DDRIVE_TXD,a	  ;make sure Tx is high(idle)
    ld    (PCDRShadow),a
;ioi ld    (PCDR),a
	IOWRITE_A(PCDR)
    ld    a,(PCFRShadow)
    res   DDRIVE_TXD,a
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ret


dEnable::
    ld    a,(PCFRShadow)
    set   DDRIVE_TXD,a
    ld    (PCFRShadow),a
;ioi ld    (PCFR),a
	IOWRITE_A(PCFR)
    ret


spd_checkcts::				;hl will be non-zero if CTS is high, uses register a
	 ld	hl, (d_checkctsfunc)
	 jp	(hl)

;
; spd_txload
;

spd_txload::
	 ld	 a, (dlongstop)	;check if we are in a long stop
	 or	 a
	 jp	 nz, spd_txload_exit		;don't load a byte if we have a long stop

    ld    hl,spd_ocbuf  ; 6,	retrieve character from circular buffer
    push  hl            ; 10
    lcall  cbuf_getch    ; 12+...
    add	 sp, 2
    bit   7,h           ; 4,	was there a character?
    jp    nz,spd_txload_exit

	 ld	 a, (dtwostop)
	 or	 a
	 jp	 nz, spd_txload_2stop

	 ld	 a, (dparity)	;check to see if we need to add a parity bit
	 or	 a
	 jp	 z, spd_txload_sendbyte
	 ld	 a, (dsevenbit) ;are we doing 7 or 8 bit data?
	 or	 a
	 jr	 nz, spd_txload_7bitparity
spd_txload_8bitparity:
	 push	 hl	;save the byte value
	 ld	 a, (dparitytype)
	 ld	 h, a
	 lcall ser8_getparity
	 bool  hl
	 pop	 hl
	 jr	 z, spd_txload_9bitlow

#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
spd_txload_9bithigh:
	 ld	 a, L
;ioi ld	 (SDLR), a
	IOWRITE_A(SDLR)
	 jr	 spd_txload_exit
#else
spd_txload_9bithigh:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, spd_txload_setlongstop
	 ld	 a, L
;ioi ld	 (SDLR), a
	IOWRITE_A(SDLR)
	 jr	 spd_txload_exit

spd_txload_setlongstop:
	 ld	 a, 0x01
	 ld	 (dlongstop), a	;set the long stop flag
	 jp	 spd_txload_sendbyte
#endif

spd_txload_9bitlow:
	 ld	 a, L
;ioi ld	 (SDAR), a			;load byte into alternate register
	IOWRITE_A(SDAR)
	 jr	 spd_txload_exit

spd_txload_7bitparity:
	 ld	 a, (dparitytype)
	 ld	 h, a
	 lcall ser7_setparity
	 jp	 spd_txload_sendbyte

spd_txload_2stop:
	 ld	 a, (dsevenbit)
	 or	 a
	 jr	 z, spd_txload_9bithigh
	 ld	 a, L
	 or	 0x80
	 ld	 L, a
spd_txload_sendbyte:
    ld	 a, L
;ioi ld	 (SDDR), a
	IOWRITE_A(SDDR)
spd_txload_exit:
	 ret
#endasm

/*** BeginHeader spd_isr */
root void spd_isr();
/*** EndHeader */

#asm
;
; spd_isr
;

spd_isr::
	push	af					; 7, 	restore registers needed by isr
	push	bc					; 7
	push	de					; 7
	push	hl					; 7

;ioi ld	 a,(SDSR)			; 11,	interrupt source rx or tx
	IOREAD_A(SDSR)
#if (_USER)
	;acknowledge interrupt immediately for RabbitSys
	IOWRITE_A(SDSR)
#endif
	 ld    c,a
	 rla						; 2
	 jp	 c,spd_rx			; 5

spd_tx:
    bit   2,c           ; Tx busy? bit 2 shifted via rla
    jr    nz,spd_txbusy
spd_txidle:             ; Tx idle, safe for enable/disable transition
	 ld	 a, (dlongstop)
	 or	 a
	 jr	 nz, spd_dolongstop	;handle request for a loooong (2 byte) stop bit

	 ld 	 a, (drtscts)
	 or	 a
    jr	 z, spd_trytosend ;try one more time to load a byte
	 call  spd_checkcts
	 bool	 hl
	 jr	 nz, spd_disabletx

spd_trytosend:
	 call	 dEnable
	 call	 spd_txload				;CTS is on, so try to load a normal byte
	 jr	 spd_donomore

spd_dolongstop:
	 xor	 a
	 ld	 (dlongstop), a		;clear out the long stop flag
spd_disabletx:
	 call  dDisable
	 ld	 a, 42
;ioi ld	 (SDDR), a				; load 42 into SADR as a dummy byte,
	IOWRITE_A(SDDR)
										; to keep the interrupt loop going
	 jr	 spd_donomore

spd_txbusy:
    ld    a,(PCFRShadow)		; check to make sure tx is enabled
    bit   DDRIVE_TXD,a			; if not, dummy character still needs to
    									; clear out
    jr    z, spd_donomore
	 ld 	 a, (drtscts)			; are we using CTS?
	 or	 a
    jr	 z, spd_txallgood
	 call  spd_checkcts
	 bool	 hl
	 jr	 nz, spd_donomore		; CTS is off, don't fill SBDR
spd_txallgood:
	 call	 spd_txload				; will load a good byte, it there is one
	 									; to be loaded
spd_donomore:
;ioi ld    (SDSR),a      ; 10,	clear interrupt source
#if !(_USER)
	IOWRITE_A(SDSR)
#endif
    ipres               ; 4
    pop   hl            ; 7, 	restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

spd_rx:
;ioi ld    a,(SDDR)      ; 11,	receive the character
	IOREAD_A(SDDR)
    bool  hl            ; 2,	place character on circular buffer
    ld    l,a           ; 2,		throw it away if no room
	 ld	 b,a				;save for later possible parity check
	 ld	 a, (dsevenbit)
	 or	 a
	 jr	 z, spd_rxcontinue
	 ld	 a, L
	 and	 0x7f
	 ld	 L, a				;mask out MSB for 7 bit data
spd_rxcontinue:
	 push	 bc				;save byte copy and status register copy
    push  hl            ; 10
    ld    hl,spd_icbuf  ; 6
    push  hl            ; 10
    lcall  cbuf_putch	   ; 12+...
    add   sp,4          ; 4
	 bool	 hl
	 jr	 nz, spd_checkoverrun
	 ld	 a, 0x01
	 ld	 (doverflow), a	;no room in input buffer
spd_checkoverrun:
	 pop	 bc
    bit	 5, c				;test for receiver overrun
    jr	 z, spd_checkparity
    ld	 a, 0x01
    ld	 (doverrun), a

spd_checkparity:
	 ld	 a, (dparity)
	 or	 a								; see if we need to check parity of
	 										; incoming byte
	 jr	 z, spd_rx_flowcontrol
	 ld	 a, (dsevenbit)
	 or	 a
	 jr	 nz, spd_check7bit
spd_check8bit:
	 ld	 l, b
	 ld	 a, (dparitytype)
	 ld	 h, a
	 lcall ser8_getparity
	 bool  hl
	 jr	 z, spd_check9low
spd_check9high:						; 9th parity bit should be high,
											; otherwise we have a parity error
	 bit	 6, c							; C reg should still have a snapshot of
	 										; the status register, checking bit 9
	 jr	 z, spd_rx_flowcontrol	; no 9th bit detected (9th bit high),
	 										; so we are OK
	 ld	 a, 0x01
	 ld	 (dparityerror), a				;signal a parity error
	 jr	 spd_rx_flowcontrol
spd_check9low:
	 bit	 6, c
	 jr	 nz, spd_rx_flowcontrol	; 9th bit detected (9th bit low),
	 										; which is what we expect
	 ld	 a, 0x01
	 ld	 (dparityerror), a
	 jr	 spd_rx_flowcontrol
spd_check7bit:
	 ld	 l, b
	 ld	 a, (dparitytype)
	 ld	 h, a
	 lcall ser7_checkparity
	 bool	 hl
	 jr	 nz, spd_rx_flowcontrol
	 ld	 a, 0x01
	 ld	 (dparityerror), a

spd_rx_flowcontrol:
    ld    a,(drtscts)
    or    a
    jr    z,spd_rx0
    ld    hl,spd_icbuf  ;
    push  hl            ;
    lcall  cbuf_used     ;
    add   sp,2          ;
    ld    d,h
    ld    e,l
    ld    b,d
    ld    c,e           ; copy number bytes used to bc
    ld    hl,(serDrtsHi);
    ld    a,d           ;
    cp    h             ;
    jr    c,spd_rx0     ;
    ld    a,e           ;
    cp    l             ;
    jr    c,spd_rx0     ;
spd_overHi:					; turn off the RTS line
	 ld	 hl, spd_rx0
	 push	 hl				;set return address
	 ld	 hl, (d_rtsoff)
	 jp	 (hl)
spd_rx0:
    ipres               ; 4
    pop   hl            ; 7,  restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

#endasm

//************************************************************************
//****************************** PORT E **********************************
//************************************************************************

/*** Beginheader serEgetc */
int  serEgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEgetc                     <RS232.LIB>

SYNTAX:	      int serEgetc();

DESCRIPTION:   Get next available character from serial port E read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	success: the next character in the low byte, 0 in the high byte
               failure: the integer -1

END DESCRIPTION **********************************************************/

nodebug int serEgetc()
{
   static int n;

   if (cbuf_rdlock(spe_icbuf))
   {
      n = cbuf_getch(spe_icbuf);
      if (ertscts && cbuf_used(spe_icbuf) <= serErtsLo)
      {
      	(*e_rtson)();
      }
      cbuf_rdunlock(spe_icbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_RXC, 'E', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_E
	   if (n >= 0) printf(RS232_RXC, 'E', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = -1;
   }
   return n;
}

/*** Beginheader serEread */
int  serEread(void *data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEread                   <RS232.LIB>

SYNTAX:		   int serEread(void *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from serial port E or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port E
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port E

END DESCRIPTION **********************************************************/

nodebug int serEread(void *data, int length, unsigned long tmout)
{
   static int  n, nread, timedOut;
   static char *p;
   static unsigned long chtm;

   p = (char *)data;
   nread = timedOut = 0;

   if (cbuf_rdlock(spe_icbuf))
   {
      chtm = MS_TIMER;
      while (nread < length && !timedOut)
      {
      	// once in, finish or timeout
         if ((n = cbuf_get(spe_icbuf, p + nread, length - nread)) > 0)
         {
      		if (ertscts && cbuf_used(spe_icbuf) <= serErtsLo)
      		{
      			(*e_rtson)();
      		}
            chtm = MS_TIMER;
            nread += n;
         }
         else
         {
            if (nread)
            {
               if (MS_TIMER - chtm >= tmout)
               {
                  timedOut = 1;
               }
            }
            else
            {
               break;   // just break out of while if
               			// we have not yet begun to read data
            }
         }
      }
	   cbuf_rdunlock(spe_icbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-E");
#else
#ifdef RS232_MONITOR_E
	_RS232_echo(p, nread, "RX-E");
#endif
#endif
   return nread;
}

/*** Beginheader serEpeek */
int serEpeek();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEpeek                   <RS232.LIB>

SYNTAX:		   int serEpeek();

DESCRIPTION:   returns the 1st character of the data in the E input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not
END DESCRIPTION **********************************************************/

nodebug int serEpeek()
{
  return (int)cbuf_peek(spe_icbuf);
}

/*** Beginheader serEputc */
int serEputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEputc                     <RS232.LIB>

SYNTAX:	      int serEputc(char c);

DESCRIPTION:   Write a character to serial port E write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port E write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

END DESCRIPTION **********************************************************/

nodebug int serEputc(int c)
{
   static int n;

   if (cbuf_wrlock(spe_ocbuf))
   {
      n = cbuf_putch(spe_ocbuf, c);
      if (n)
      {
      	spe_starttx();
		}
      cbuf_wrunlock(spe_ocbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_TXC, 'E', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_E
	   if (n >= 0) printf(RS232_TXC, 'E', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = 0;
   }
   return n;
}

/*** Beginheader serEputs */
int serEputs(char *s);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEputs                     <RS232.LIB>

SYNTAX:     	int serEputs(char* s);

DESCRIPTION:   Calls serEwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port E.

END DESCRIPTION **********************************************************/

nodebug int serEputs(char *s)
{
   return serEwrite(s, strlen(s));
}

/*** Beginheader serEwrite */
int serEwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEwrite                   <RS232.LIB>

SYNTAX:		   int serEwrite(void *data, int length);

DESCRIPTION:   Transmits length bytes to serial port E.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port E
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port E.

END DESCRIPTION **********************************************************/

nodebug int serEwrite(void *data, int length)
{
   static int bytesleft;
   static char *p;

   p = (char *)data;
   bytesleft = length;
   if (cbuf_wrlock(spe_ocbuf))
   {
      while (bytesleft)
      {
         bytesleft -= cbuf_put(spe_ocbuf, p+(length-bytesleft), bytesleft);
         spe_starttx();
      }
      cbuf_wrunlock(spe_ocbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, length - bytesleft, "TX-E");
#else
#ifdef RS232_MONITOR_E
	_RS232_echo(p, length - bytesleft, "TX-E");
#endif
#endif
   return length - bytesleft;
}

/*** Beginheader cof_serEgetc */
scofunc int cof_serEgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serEgetc                   <RS232.LIB>

SYNTAX:		   int cof_serEgetc();

DESCRIPTION:   Yields to other tasks until a character is read from port E.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port E

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serEgetc()
{
	static int c;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spe_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spe_icbuf));
	havelock=1;

	waitfor((c=cbuf_getch(spe_icbuf)) != -1);

   if (ertscts && cbuf_used(spe_icbuf) <= serErtsLo)
   {
   	(*e_rtson)();
   }

	cbuf_rdunlock(spe_icbuf);
#ifdef RS232_MONITOR
   if (c >= 0) printf(RS232_RXC, 'E', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_E
   if (c >= 0) printf(RS232_RXC, 'E', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
	return c;
}

/*** Beginheader cof_serEgets */
scofunc int cof_serEgets(char *s, int max, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serEgets                   <RS232.LIB>

SYNTAX:		   int cof_serEgets(char *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port E until a null terminator, carriage
					return or linefeed is read, max characters are read, or until
					tmout milliseconds transpires between characters after the
					first one is read. It yields to other tasks for as long as
					the input buffer is locked or whenever the buffer becomes
					empty as characters are read. s will always be null terminated
					upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serEgets(char *s, int max, unsigned long tmout)
{
   static int  c, started, timedOut;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spe_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spe_icbuf));
   havelock=1;

   p = s;
   c = started = timedOut = 0;

   while (c != RS232_CR && p-s < max && !timedOut)
   {
      if ((c = cbuf_getch(spe_icbuf)) != -1)
      {
         switch (c)
         {
            case  8: if (p > s) --p; break;
            case  0:
            case RS232_LF: c = RS232_CR;
            case RS232_CR: break;
            default: *p++ = c; break;
         }

   		if (ertscts && cbuf_used(spe_icbuf) <= serErtsLo)
   		{
   			(*e_rtson)();
   		}

         if (!started) started = 1;
         chtm = MS_TIMER;  // timeout starts anew
      }
      else
      {
         if (started && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   *p=0;  // null terminate whether timed out, max length, or normal
	cbuf_rdunlock(spe_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(s, p - s, "RX-E");
#else
#ifdef RS232_MONITOR_E
	_RS232_echo(s, p - s, "RX-E");
#endif
#endif
   return !timedOut; //
}

/*** Beginheader cof_serEread */
scofunc int cof_serEread(void* data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serEread                   <RS232.LIB>

SYNTAX:		   int cof_serEread(void* data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port E or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serEread(void* data, int length, unsigned long tmout)
{
   static int nread, timedOut;
   static int n;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spe_icbuf);
	}

   p = (char *)data;
	havelock=0;
	waitfor(cbuf_rdlock(spe_icbuf));
   havelock=1;

   n = nread = timedOut = 0;
   chtm = MS_TIMER;
   while(nread < length && !timedOut)
   {
      if ((n = cbuf_get(spe_icbuf, p + nread, length - nread)) > 0)
      {
         nread += n;
   		if (ertscts && cbuf_used(spe_icbuf) <= serErtsLo)
   		{
   			(*e_rtson)();
   		}
         if(nread < length)
         {
            yield;
            chtm = MS_TIMER;      // timeout starts anew
         }
      }
      else
      {
         if (nread && (MS_TIMER - chtm) >= tmout)
         {
         	timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   cbuf_rdunlock(spe_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-E");
#else
#ifdef RS232_MONITOR_E
	_RS232_echo(p, nread, "RX-E");
#endif
#endif
   return nread;
}

/*** Beginheader cof_serEputc */
scofunc void cof_serEputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serEputc                   <RS232.LIB>

SYNTAX:		   void cof_serEputc(int c);

DESCRIPTION:   Writes a character to the E port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serEputc(int c)
{
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spe_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spe_ocbuf));
   havelock=1;

	waitfor(cbuf_putch(spe_ocbuf,c));

	spe_starttx();
	cbuf_wrunlock(spe_ocbuf);
#ifdef RS232_MONITOR
	if (c >= 0) printf(RS232_TXC, 'E', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_E
	if (c >= 0) printf(RS232_TXC, 'E', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
}

/*** Beginheader cof_serEputs */
scofunc void cof_serEputs(char *str);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serEputs                   <RS232.LIB>

SYNTAX:		   void cof_serEputs(char *str);

DESCRIPTION:   Writes a null terminated string to the E port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serEputs(char *str)
{
	static int bytesleft,length;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spe_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spe_ocbuf));
   havelock=1;

	bytesleft=length=strlen(str);

	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spe_ocbuf,str+(length-bytesleft),bytesleft);
		spe_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spe_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(str, length, "TX-E");
#else
#ifdef RS232_MONITOR_E
	_RS232_echo(str, length, "TX-E");
#endif
#endif
}

/*** Beginheader cof_serEwrite */
scofunc void cof_serEwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serEwrite                   <RS232.LIB>

SYNTAX:		   void cof_serEwrite(void *data, int length);

DESCRIPTION:   Writes length bytes to the E port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serEwrite(void *data, int length)
{
	static int bytesleft;
   static char *v;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spe_ocbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spe_ocbuf));
   havelock=1;

   v = (char *)data;
	bytesleft=length;
	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spe_ocbuf,v+(length-bytesleft),bytesleft);
		spe_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spe_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(v, length, "TX-E");
#else
#ifdef RS232_MONITOR_E
	_RS232_echo(v, length, "TX-E");
#endif
#endif
}

/*** Beginheader serEflowcontrolOn */
void serEflowcontrolOn();
/*** endheader */

//defaults for flow control RTS/CTS
#ifndef SERE_RTS_PORT
#define SERE_RTS_PORT PBDR
#warnt "SERE_RTS_PORT not defined: defaulting to PBDR"
#endif

#ifndef SERE_RTS_SHADOW
#define SERE_RTS_SHADOW PBDRShadow
#warnt "SERE_RTS_SHADOW not defined: defaulting to PBDRShadow"
#endif

#ifndef SERE_RTS_BIT
#define SERE_RTS_BIT 6
#warnt "SERE_RTS_BIT not defined: defaulting to 6"
#endif

#ifndef SERE_CTS_PORT
#define SERE_CTS_PORT PBDR
#warnt "SERE_CTS_PORT not defined: defaulting to PBDR"
#endif

#ifndef SERE_CTS_BIT
#define SERE_CTS_BIT 6
#warnt "SERE_CTS_BIT not defined: defaulting to 6"
#endif

#asm root
spe_checkcts_fc::
	 bool	hl
;ioi ld 	a, (SERE_CTS_PORT)
	IOREAD_A(SERE_CTS_PORT)
	 and	1 << SERE_CTS_BIT
	 ld	L, a
	 ret

spe_rtsoff_fc::
	 ld	 a, (SERE_RTS_SHADOW)
	 set	 SERE_RTS_BIT, a		;set RTS high (inactive)
	 ld	 (SERE_RTS_SHADOW), a
;ioi ld	 (SERE_RTS_PORT), a
	IOWRITE_A(SERE_RTS_PORT)
	 ret

spe_rtson_fc::
	 ld	 a, (SERE_RTS_SHADOW)
	 res   SERE_RTS_BIT, a		;set RTS low (active)
	 ld	 (SERE_RTS_SHADOW), a
;ioi ld	 (SERE_RTS_PORT), a
	IOWRITE_A(SERE_RTS_PORT)
	 ret

#endasm

/* START FUNCTION DESCRIPTION ********************************************
serEflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serEflowcontrolOn();

DESCRIPTION:   Turns on hardware flow control for channel E. This enables two
					digital lines that handle flow control, CTS(clear to send)
					and RTS(ready to send).
					CTS is an input that will be pulled active low by the other
					system when it is ready to receive data. The RTS signal
					is an output that the system uses to indicate that it is
					ready to receive data. It is driven low when data can be
					received.
					If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERE_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERE_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERE_RTS_BIT - the bit number for the RTS line
 					SERE_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERE_CTS_BIT - the bit number for the CTS line

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serEflowcontrolOn()
{
	ertscts = 1;
	//set flow control ISR functions
	e_checkctsfunc = spe_checkcts_fc;
	e_rtsoff = spe_rtsoff_fc;
	e_rtson = spe_rtson_fc;
	serErtsLo = (int)(EINBUFSIZE * 0.2);
	serErtsHi = (int)(EINBUFSIZE * 0.8);
	// turn on RTS if buffer is below 80%
	if (serErdUsed() < serErtsHi) (*e_rtson)();
}

/*** Beginheader serEflowcontrolOff */
void serEflowcontrolOff();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serEflowcontrolOff();

DESCRIPTION:   Turns off hardware flow control for channel E.
               This function is non-reentrant.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serEflowcontrolOff()
{
	ertscts = 0;
}

/*** Beginheader serEparity */
void serEparity(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEparity                   <RS232.LIB>

SYNTAX:		   void serEparity(int state);

DESCRIPTION:   Sets parity type for channel E. This function is non-reentrant.

PARAMETER1:		A bit mask for selecting parity mode
					PARAM_EPARITY	0x01
					PARAM_OPARITY	0x02
					PARAM_2STOP 	0x03
					PARAM_NOPARITY 0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serEparity(int state)
{
	if (state) {
		if (state == PARAM_OPARITY)
		{
			eparity = 1;
			etwostop = 0;
			eparitytype = 0;
		}
		else if (state == PARAM_EPARITY)
		{
			eparity = 1;
			etwostop = 0;
			eparitytype = 1;
		}
		else
		{
			etwostop = 1;
			eparity = 0;
		}
	}
	else
	{
		eparity = 0;
		etwostop = 0;
	}
	if(esevenbit && !eparity && !etwostop)
	{
		BitWrPortI(SECR, &SECRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SECR, &SECRShadow, 0, 2);
	}
}

/*** Beginheader serEdatabits */
void serEdatabits(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEdatabits                   <RS232.LIB>

SYNTAX:		   void serEdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel E.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
					PARAM_7BIT	0x01
					PARAM_8BIT	0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serEdatabits(int state)
{
	if (state == PARAM_7BIT)
	{
		esevenbit = 1;
	}
	else
	{
		esevenbit = 0;
	}
	if(esevenbit && !eparity && !etwostop)
	{
		BitWrPortI(SECR, &SECRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SECR, &SECRShadow, 0, 2);
	}
}

/*** Beginheader serErdFree */
int serErdFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serErdFree                   <RS232.LIB>

SYNTAX:		   int serErdFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port E input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the E input buffer
END DESCRIPTION **********************************************************/

nodebug int serErdFree()
{
	return (int)cbuf_free(spe_icbuf);
}

/*** Beginheader serEwrFree */
int serEwrFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEwrFree                   <RS232.LIB>

SYNTAX:		   int serEwrFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port E transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the E transmit buffer
END DESCRIPTION **********************************************************/

nodebug int serEwrFree()
{
	return (int)cbuf_free(spe_ocbuf);
}

/*** Beginheader serErdUsed */
int serErdUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serErdUsed                   <RS232.LIB>

SYNTAX:		   int serErdUsed();

DESCRIPTION:   Returns the number of characters in the E input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the E input buffer
END DESCRIPTION **********************************************************/

nodebug int serErdUsed()
{
	return (int)cbuf_used(spe_icbuf);
}

/*** Beginheader serEwrUsed */
int serEwrUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEwrUsed                   <RS232.LIB>

SYNTAX:		   int serEwrUsed();

DESCRIPTION:   Returns the number of characters in the E output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the E output buffer
END DESCRIPTION **********************************************************/

nodebug int serEwrUsed()
{
	return (int)cbuf_used(spe_ocbuf);
}

/*** Beginheader serErdFlush */
void serErdFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serErdFlush                  <RS232.LIB>

SYNTAX:		   void serErdFlush();

DESCRIPTION:   Flushes the serial port E input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serErdFlush()
{
	cbuf_flush(spe_icbuf);
}

/*** Beginheader serEwrFlush */
void serEwrFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEwrFlush                  <RS232.LIB>

SYNTAX:		   void serEwrFlush();

DESCRIPTION:   Flushes the serial port E transmit buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serEwrFlush()
{
	cbuf_flush(spe_ocbuf);
}

/*** Beginheader serEclose */
void serEclose();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serEclose                   <RS232.LIB>

SYNTAX:		   void serEclose();

DESCRIPTION:   Disables the E serial port. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm xmem

serEclose::
    ld    a,0xc9        ; ret in first byte
    ipset 1
#if _USER
c	 SetVectIntern(SERE_OFS/0x10, spe_dummyfunc);
#else
    ld	(INTVEC_BASE + SERE_OFS), a		; ret in first byte of speisr_start
#endif

    ld    a,0x00        ; disable interrupts for port
	 ld    (SECRShadow),a
;ioi ld    (SECR),a
	IOWRITE_A(SECR)
    ld    a,(PGFRShadow)	;set PG6 to normal output
    res	 EDRIVE_TXD, a
    ld    (PGFRShadow),a
;ioi ld    (PGFR),a
	IOWRITE_A(PGFR)
    ipres
    lret

#endasm

/*** Beginheader serErtsLo, serErtsHi, serEopen, serEgetError,
     spe_icbuf, spe_ocbuf */
extern int serErtsLo;
extern int serErtsHi;
int serEopen(long baud);
char serEgetError();
void spe_init();
root void spe_starttx();
root void eDisable();
root void eEnable();
root void spe_isr();
root void spe_dummyfunc();
extern char spe_icbuf[];
extern char spe_ocbuf[];
extern char ertscts;
extern char eparity;
extern char eparitytype;
extern char esevenbit;
extern char etwostop;
//pointers to flow control functions
extern int (*e_checkctsfunc)();
extern void (*e_rtsoff)();
extern void (*e_rtson)();
extern char eparityerror;
extern char eoverrun;
extern char eoverflow;

#define EDRIVE_TXD 6

/*** endheader */

#undef EINBUFOK

#ifndef EINBUFSIZE
#define EINBUFSIZE 31
#warnt "EINBUFSIZE undefined, defaulting to 31"
#endif

#if (EINBUFSIZE & (EINBUFSIZE+1)) == 0
#define EINBUFOK 1
#endif

#ifndef EINBUFOK
#undef EINBUFSIZE
#define EINBUFSIZE 31
#warnt "EINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef EOUTBUFOK

#ifndef EOUTBUFSIZE
#define EOUTBUFSIZE 31
#warnt "EOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (EOUTBUFSIZE & (EOUTBUFSIZE+1)) == 0
#define EOUTBUFOK 1
#endif

#ifndef EOUTBUFOK
#undef EOUTBUFSIZE
#define EOUTBUFSIZE 31
#warnt "EOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif


char spe_icbuf[EINBUFSIZE+9];
char spe_ocbuf[EOUTBUFSIZE+9];

char ertscts;
char eparity;
char eparitytype;
char esevenbit;
char etwostop;
int (*e_checkctsfunc)();
void (*e_rtsoff)();
void (*e_rtson)();

int  serErtsLo;
int  serErtsHi;
char eparityerror;
char eoverrun;
char eoverflow;

/* START FUNCTION DESCRIPTION ********************************************
serEopen                   <RS232.LIB>

SYNTAX:		   int serEopen(long baud);

DESCRIPTION:   Opens the E serial port.
               This function is non-reentrant.

PARAMETER1:    baud : bits per second of data transfer

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

RELATED WORDS: serEgetc, serEgetc, serEpeek,
               serEputs, serEwrite,
               cof_serEgetc, cof_serEgets, cof_serEread,
               cof_serEputc, cof_serEputs, cof_serEwrite
               serEclose

END DESCRIPTION **********************************************************/

nodebug int serEopen(long baud)
{
   static long divisor, ta1div;
   static float baudratio;
	static unsigned long t;

   ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	WrPortI(TACR, &TACRShadow, TACRShadow | 0x04);
	}
	else
	{
   	WrPortI(TACR, &TACRShadow, TACRShadow & ~0x04); // clear bit
	}

	ertscts = 0;
	esevenbit = 0;
	eparity = 0;
	eparitytype = 0;
	etwostop = 0;
	eparityerror = 0;
	eoverrun = 0;
	eoverflow = 0;
	//use the dummy versions of the flow control functions
	//all they do is return. They are placeholders in case flow control
	//enabled
	e_checkctsfunc = spe_dummyfunc;
	e_rtsoff = spe_dummyfunc;
	e_rtson = spe_dummyfunc;
	WrPortI(TAT2R, &TAT2RShadow, (char)divisor);
   cbuf_init(spe_icbuf,EINBUFSIZE);
   cbuf_init(spe_ocbuf,EOUTBUFSIZE);

   spe_init();
   t = MS_TIMER;
   // let baud timer time out before using port
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   cbuf_getch(spe_icbuf);
   cbuf_getch(spe_icbuf);
   baudratio = ((RS232_BASEFREQ*freq_divider) /
   	(32 * ((divisor & 0xff) + 1) + 0.5)) / (float)(baud * (ta1div + 1));
   return (baudratio > 0.95 && baudratio < 1.05);
}

/* START FUNCTION DESCRIPTION ********************************************
serEgetError                   <RS232.LIB>

SYNTAX:		   char serEgetError();

DESCRIPTION:   Returns the error flags byte for serial channel E
					This can then be compared against error bitmasks to determine
					what errors occured. Additionally, any bits set in the returned
					error flags will be automatically cleared. This function is
               non-reentrant.

					Error bitmasks:
						SER_PARITY_ERROR	0x01
						SER_OVERRUN_ERROR 0x02
						SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

END DESCRIPTION **********************************************************/

nodebug char serEgetError()
{
	static char error_flags;

	error_flags = 0;
	if	(eoverrun)
	{
		error_flags |= SER_OVERRUN_ERROR;
		eoverrun = 0;
	}
	if (eparityerror)
	{
		error_flags |= SER_PARITY_ERROR;
		eparityerror = 0;
	}
	if (eoverflow)
	{
		error_flags |= SER_OVERFLOW_ERROR;
		eoverflow = 0;
	}
	return error_flags;
}

#asm root

;
; interrupt routine to be copied into interrupt table
;

speisr_start::
    call  spe_isr       ; 19
    ret                 ; 8

spe_dummyfunc::
	ret
#endasm

#asm xmem
;
; spe_init
;

spe_init::
#if _USER
	 ipset 1
c	 SetVectIntern(SERE_OFS/0x10, speisr_start);
#else
    ld	 de, INTVEC_BASE + SERE_OFS
    ld    hl,speisr_start
    ld    bc,0x0010     ; copy 16 bytes from speisr_start into interrupt table
    ipset 1

	#if __SEPARATE_INST_DATA__
	    call inst2data_ldir
	#else
	    ldir
	#endif
#endif

    ld	 a, (PGDRShadow)
    set	 EDRIVE_TXD, a    ;Tx should initially be idle high
    ld	 (PGDRShadow), a
;ioi ld	 (PGDR), a
	IOWRITE_A(PGDR)

    ld    a,(PGFRShadow)	;set PG6 to serial out
    set	 EDRIVE_TXD, a
    ld    (PGFRShadow),a
;ioi ld    (PGFR),a
	IOWRITE_A(PGFR)

    ld    a,(PGDCRShadow)	;set PG6 to be push-pull
    res	 EDRIVE_TXD, a
    ld    (PGDCRShadow),a
;ioi ld    (PGDCR),a
	IOWRITE_A(PGDCR)

    ld    a,(PGDDRShadow)	;set PG6 to be output
    set	 EDRIVE_TXD, a
    ld    (PGDDRShadow),a
;ioi ld    (PGDDR),a
	IOWRITE_A(PGDDR)

    ld    a,0x01
    ld    (SECRShadow),a
;ioi ld    (SECR),a       ; enable interrupts, use parallel port D
	IOWRITE_A(SECR)
								 ; for serial port B
    ipres
    lret
#endasm

#asm root
spe_starttx::				;called by C put routines to start up interrupt loop,
								; if tx is idle
	 push	 af				; cbuf_getch inside of spe_txload uses most of the
	 							; registers
	 push	 bc
	 push	 de
	 push	 hl
	 ipset 1

;ioi ld	 a, (SESR)
	IOREAD_A(SESR)
	 bit	 3, a
	 jr	 nz, spe_starttx_exit	; if tx is busy then it will catch whatever
	 										; is in the buffer
	 ld	 a, (ertscts)
	 or	 a
	 jr	 z, spe_starttx_load

	 call  spe_checkcts
	 bool	 hl
	 jr	 nz, spe_starttx_dummy

spe_starttx_load:
	 call	 eEnable
	 call	 spe_txload
	 jr	 spe_starttx_exit

spe_starttx_dummy:
	 call	 eDisable
	 ld	 a, 23
;ioi ld	 (SEDR), a
	IOWRITE_A(SEDR)

spe_starttx_exit:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

eDisable::
	 ld    a,(PGDRShadow)
    set   EDRIVE_TXD,a	  ;make sure Tx is high(idle)
    ld    (PGDRShadow),a
;ioi ld    (PGDR),a
	IOWRITE_A(PGDR)
    ld    a,(PGFRShadow)
    res   EDRIVE_TXD,a
    ld    (PGFRShadow),a
;ioi ld    (PGFR),a
	IOWRITE_A(PGFR)
    ret


eEnable::
    ld    a,(PGFRShadow)
    set   EDRIVE_TXD,a
    ld    (PGFRShadow),a
;ioi ld    (PGFR),a
	IOWRITE_A(PGFR)
    ret


spe_checkcts:				;hl will be non-zero if CTS is high, uses register a
	 ld	hl, (e_checkctsfunc)
	 jp	(hl)


spe_txload:
    ld    hl,spe_ocbuf  ; 6,	retrieve character from circular buffer
    push  hl            ; 10
    lcall  cbuf_getch    ; 12+...
    add	 sp, 2
    bit   7,h           ; 4,	was there a character?
    jp    nz,spe_txload_exit

	 ld	 a, (etwostop)
	 or	 a
	 jp	 nz, spe_txload_2stop

	 ld	 a, (eparity)	;check to see if we need to add a parity bit
	 or	 a
	 jp	 z, spe_txload_sendbyte
	 ld	 a, (esevenbit) ;are we doing 7 or 8 bit data?
	 or	 a
	 jr	 nz, spe_txload_7bitparity
spe_txload_8bitparity:
	 push	 hl	;save the byte value
	 ld	 a, (eparitytype)
	 ld	 h, a
	 lcall	 ser8_getparity
	 bool  hl
	 pop	 hl
	 jr	 z, spe_txload_9bitlow
spe_txload_9bithigh:
	 ld	 a, L
;ioi ld	 (SELR), a
	IOWRITE_A(SELR)
	 jr	 spe_txload_exit

spe_txload_9bitlow:
	 ld	 a, L
;ioi ld	 (SEAR), a			;load byte into alternate register
	IOWRITE_A(SEAR)
	 jr	 spe_txload_exit

spe_txload_7bitparity:
	 ld	 a, (eparitytype)
	 ld	 h, a
	 lcall  ser7_setparity
	 jp	 spe_txload_sendbyte

spe_txload_2stop:
	 ld	 a, (esevenbit)
	 or	 a
	 jr	 z, spe_txload_9bithigh
	 ld	 a, L
	 or	 0x80
	 ld	 L, a
spe_txload_sendbyte:
    ld	 a, L
;ioi ld	 (SEDR), a
	IOWRITE_A(SEDR)
spe_txload_exit:
	 ret


;
; spe_isr
;

spe_isr::
	push	af					; 7, 	restore registers needed by isr
	push	bc					; 7
	push	de					; 7
	push	hl					; 7

;ioi ld	 a,(SESR)			; 11,	interrupt source rx or tx
	IOREAD_A(SESR)
#if (_USER)
	;acknowledge interrupt immediately for RabbitSys
	IOWRITE_A(SESR)
#endif
 	 ld	 c, a
	 rla						; 2
	 jp	 c,spe_rx			; 5

spe_tx:
    bit   2,c           ; Tx busy? bit 2 shifted via rla
    jr    nz,spe_txbusy
spe_txidle:             ; Tx idle, safe for enable/disable transie
	 ld 	 a, (ertscts)
	 or	 a
    jr	 z, spe_trytosend ;try one more time to load a byte
	 call  spe_checkcts
	 bool	 hl
	 jr	 nz, spe_disabletx

spe_trytosend:
	 call	 eEnable
	 call	 spe_txload				;CTS is on, so try to load a normal byte
	 jr	 spe_donomore

spe_disabletx:
	 call  eDisable
	 ld	 a, 42
;ioi ld	 (SEDR), a				; load 42 in; if not, dummy character still needs to
	IOWRITE_A(SEDR)
										; to keep the interrupt loop going
	 jr	 spe_donomore

spe_txbusy:
    ld    a,(PGFRShadow)		; check to make sure tx is enabled
    bit   EDRIVE_TXD,a			; if not, dummy character still needs to
    									; clear out
    jr    z, spe_donomore
	 ld 	 a, (ertscts)			; are we using CTS?
	 or	 a
    jr	 z, spe_txallgood
	 call  spe_checkcts
	 bool	 hl
	 jr	 nz, spe_donomore		; CTS is off, don't fill SEDR
spe_txallgood:
	 call	 spe_txload				; will load a good byte, it there is one to
	 									; be loaded
spe_donomore:
;ioi ld    (SESR),a      ; 10,	clear interrupt source
#if !(_USER)
	IOWRITE_A(SESR)
#endif
    ipres               ; 4
    pop   hl            ; 7, 	restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret        			; 13

spe_rx:
;ioi ld    a,(SEDR)      ; 11,	receive the character
	IOREAD_A(SEDR)
    bool  hl            ; 2,	place character on circular buffer
    ld    l,a           ; 2,		throw it away if no room
 	 ld	 b,a				; save for later possible parity check
	 ld	 a, (esevenbit)
	 or	 a
	 jr	 z, spe_rxcontinue
	 ld	 a, L
	 and	 0x7f
	 ld	 L, a				;mask out MSB for 7 bit data
spe_rxcontinue:
	 push	 bc				; save byte copy and status register copy
    push  hl            ; 10
    ld    hl,spe_icbuf  ; 6
    push  hl            ; 10
    lcall  cbuf_putch	   ; 12+...
    add   sp,4          ; 4
    bool	 hl
    jr	 nz, spe_checkoverrun
    ld	 a, 0x01
    ld	 (eoverflow), a
spe_checkoverrun:
    pop	 bc
    bit	 5, c				;test for receiver overrun
    jr	 z, spe_checkparity
    ld	 a, 0x01
    ld	 (eoverrun), a

spe_checkparity:
	 ld	 a, (eparity)
	 or	 a								; see if we need to check parity of
	 										; incoming byte
	 jr	 z, spe_rx_flowcontrol
	 ld	 a, (esevenbit)
	 or	 a
	 jr	 nz, spe_check7bit
spe_check8bit:
	 ld	 l, b
	 ld	 a, (eparitytype)
	 ld	 h, a
	 lcall	 ser8_getparity
	 bool  hl
	 jr	 z, spe_check9low
spe_check9high:						; 9th parity bit should be high,
											; otherwise we have a parity error
	 bit	 6, c							; C reg should still have a snapshot of
	 										; the status register, checking bit 9
	 jr	 z, spe_rx_flowcontrol	; no 9th bit detected (9th bit high),
	 										; so we are OK
	 or	 a, 0x01
	 ld	 (eparityerror), a		;signal a parity error
	 jr	 spe_rx_flowcontrol
spe_check9low:
	 bit	 6, c
	 jr	 nz, spe_rx_flowcontrol	; 9th bit detected (9th bit low),
	 										; which is what we expect
	 or	 a, 0x01
	 ld	 (eparityerror), a
	 jr	 spe_rx_flowcontrol
spe_check7bit:
	 ld	 l, b
	 ld	 a, (eparitytype)
	 ld	 h, a
	 call	 ser7_checkparity
	 bool	 hl
	 jr	 nz, spe_rx_flowcontrol
	 or	 a, 0x01
	 ld	 (eparityerror), a

spe_rx_flowcontrol:
    ld    a,(ertscts)
    or    a
    jr    z,spe_rx0
    ld    hl,spe_icbuf  ;
    push  hl            ;
    lcall  cbuf_used     ;
    add   sp,2          ;
    ld    d,h
    ld    e,l
    ld    b,d
    ld    c,e           ; copy number bytes used to bc
    ld    hl,(serErtsHi);
    ld    a,d           ;
    cp    h             ;
    jr    c,spe_rx0     ;
    ld    a,e           ;
    cp    l             ;
    jr    c,spe_rx0     ;
spe_overHi:					; turn off the RTS line
	 ld	 hl, spe_rx0
	 push	 hl				;set return address
	 ld	 hl, (e_rtsoff)
	 jp	 (hl)
spe_rx0:
    ipres               ; 4
    pop   hl            ; 7,  restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

#endasm

//************************************************************************
//****************************** PORT F **********************************
//************************************************************************

/*** Beginheader serFgetc */
int  serFgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFgetc                     <RS232.LIB>

SYNTAX:	      int serFgetc();

DESCRIPTION:   Get next available character from serial port F read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	success: the next character in the low byte, 0 in the high byte
               failure: the integer -1

END DESCRIPTION **********************************************************/

nodebug int serFgetc()
{
   static int n;

   if (cbuf_rdlock(spf_icbuf))
   {
      n = cbuf_getch(spf_icbuf);
      if (frtscts && cbuf_used(spf_icbuf) <= serFrtsLo)
      {
      	(*f_rtson)();
      }
      cbuf_rdunlock(spf_icbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_RXC, 'F', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_F
	   if (n >= 0) printf(RS232_RXC, 'F', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = -1;
   }
   return n;
}

/*** Beginheader serFread */
int  serFread(void *data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFread                   <RS232.LIB>

SYNTAX:		   int serFread(void *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from serial port F or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port F
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port F

END DESCRIPTION **********************************************************/

nodebug int serFread(void *data, int length, unsigned long tmout)
{
   static int  n, nread, timedOut;
   static char *p;
   static unsigned long chtm;

   p = (char *)data;
   nread = timedOut = 0;

   if (cbuf_rdlock(spf_icbuf))
   {
      chtm = MS_TIMER;
      while (nread < length && !timedOut)
      {
      	// once in, finish or timeout
         if ((n = cbuf_get(spf_icbuf, p + nread, length - nread)) > 0)
         {
      		if (frtscts && cbuf_used(spf_icbuf) <= serFrtsLo)
      		{
      			(*f_rtson)();
      		}
            chtm = MS_TIMER;
            nread += n;
         }
         else
         {
            if (nread)
            {
               if (MS_TIMER - chtm >= tmout)
               {
                  timedOut = 1;
               }
            }
            else
            {
               break;   // just break out of while if
               			// we have not yet begun to read data
            }
         }
      }
	   cbuf_rdunlock(spf_icbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-F");
#else
#ifdef RS232_MONITOR_F
	_RS232_echo(p, nread, "RX-F");
#endif
#endif
   return nread;
}

/*** Beginheader serFpeek */
int serFpeek();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFpeek                   <RS232.LIB>

SYNTAX:		   int serFpeek();

DESCRIPTION:   returns the 1st character of the data in the F input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not
END DESCRIPTION **********************************************************/

nodebug int serFpeek()
{
  return (int)cbuf_peek(spf_icbuf);
}

/*** Beginheader serFputc */
int serFputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFputc                     <RS232.LIB>

SYNTAX:	      int serFputc(char c);

DESCRIPTION:   Write a character to serial port F write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port F write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

END DESCRIPTION **********************************************************/

nodebug int serFputc(int c)
{
   static int n;

   if (cbuf_wrlock(spf_ocbuf))
   {
      n = cbuf_putch(spf_ocbuf, c);
      if (n)
      {
      	spf_starttx();
		}
      cbuf_wrunlock(spf_ocbuf);
#ifdef RS232_MONITOR
	   if (n >= 0) printf(RS232_TXC, 'F', n, ((n < ' ' || n > '~') ? '.' : n));
#else
#ifdef RS232_MONITOR_F
	   if (n >= 0) printf(RS232_TXC, 'F', n, ((n < ' ' || n > '~') ? '.' : n));
#endif
#endif
   }
   else
   {
      n = 0;
   }
   return n;
}

/*** Beginheader serFputs */
int serFputs(char *s);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFputs                     <RS232.LIB>

SYNTAX:     	int serFputs(char* s);

DESCRIPTION:   Calls serFwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port F.

END DESCRIPTION **********************************************************/

nodebug int serFputs(char *s)
{
   return serFwrite(s, strlen(s));
}

/*** Beginheader serFwrite */
int serFwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFwrite                   <RS232.LIB>

SYNTAX:		   int serFwrite(void *data, int length);

DESCRIPTION:   Transmits length bytes to serial port F.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port F
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port F.

END DESCRIPTION **********************************************************/

nodebug
int serFwrite(void *data, int length)
{
   static int bytesleft;
   static char *p;

   p = (char *)data;
   bytesleft = length;
   if (cbuf_wrlock(spf_ocbuf))
   {
      while (bytesleft)
      {
         bytesleft -= cbuf_put(spf_ocbuf, p+(length-bytesleft), bytesleft);
         spf_starttx();
      }
      cbuf_wrunlock(spf_ocbuf);
   }
#ifdef RS232_MONITOR
	_RS232_echo(p, length - bytesleft, "TX-F");
#else
#ifdef RS232_MONITOR_F
	_RS232_echo(p, length - bytesleft, "TX-F");
#endif
#endif
   return length - bytesleft;
}

/*** Beginheader cof_serFgetc */
scofunc int cof_serFgetc();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serFgetc                   <RS232.LIB>

SYNTAX:		   int cof_serFgetc();

DESCRIPTION:   Yields to other tasks until a character is read from port F.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port F

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serFgetc()
{
	static int c;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spf_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spf_icbuf));
	havelock=1;

	waitfor((c=cbuf_getch(spf_icbuf)) != -1);

   if (frtscts && cbuf_used(spf_icbuf) <= serFrtsLo)
   {
   	(*f_rtson)();
   }

	cbuf_rdunlock(spf_icbuf);
#ifdef RS232_MONITOR
   if (c >= 0) printf(RS232_RXC, 'F', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_F
   if (c >= 0) printf(RS232_RXC, 'F', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
	return c;
}

/*** Beginheader cof_serFgets */
scofunc int cof_serFgets(char *s, int max, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serFgets                   <RS232.LIB>

SYNTAX:		   int cof_serFgets(char *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port F until a null terminator, carriage
					return or linefeed is read, max characters are read, or until
					tmout milliseconds transpires between characters after the
					first one is read. It yields to other tasks for as long as
					the input buffer is locked or whenever the buffer becomes
					empty as characters are read. s will always be null terminated
					upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serFgets(char *s, int max, unsigned long tmout)
{
   static int  c, started, timedOut;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spf_icbuf);
	}

	havelock=0;
	waitfor(cbuf_rdlock(spf_icbuf));
   havelock=1;

   p = s;
   c = started = timedOut = 0;

   while (c != RS232_CR && p-s < max && !timedOut)
   {
      if ((c = cbuf_getch(spf_icbuf)) != -1)
      {
         switch (c)
         {
            case  8: if (p > s) --p; break;
            case  0:
            case RS232_LF: c = RS232_CR;
            case RS232_CR: break;
            default: *p++ = c; break;
         }

   		if (frtscts && cbuf_used(spf_icbuf) <= serFrtsLo)
   		{
   			(*f_rtson)();
   		}

         if (!started) started = 1;
         chtm = MS_TIMER;  // timeout starts anew
      }
      else
      {
         if (started && (MS_TIMER - chtm) >= tmout)
         {
            timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   *p=0;  // null terminate whether timed out, max length, or normal
	cbuf_rdunlock(spf_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(s, p - s, "RX-F");
#else
#ifdef RS232_MONITOR_F
	_RS232_echo(s, p - s, "RX-F");
#endif
#endif
   return !timedOut; //
}

/*** Beginheader cof_serFread */
scofunc int cof_serFread(void* data, int length, unsigned long tmout);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serFread                   <RS232.LIB>

SYNTAX:		   int cof_serFread(void* data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port F or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_serFread(void* data, int length, unsigned long tmout)
{
   static int nread, timedOut;
   static int n;
   static char *p;
   static unsigned long chtm;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_rdunlock(spf_icbuf);
	}

   p = (char *)data;
	havelock=0;
	waitfor(cbuf_rdlock(spf_icbuf));
   havelock=1;

   n = nread = timedOut = 0;
   chtm = MS_TIMER;
   while(nread < length && !timedOut)
   {
      if ((n = cbuf_get(spf_icbuf, p + nread, length - nread)) > 0)
      {
         nread += n;
   		if (frtscts && cbuf_used(spf_icbuf) <= serFrtsLo)
   		{
   			(*f_rtson)();
   		}
         if(nread < length)
         {
            yield;
            chtm = MS_TIMER;      // timeout starts anew
         }
      }
      else
      {
         if (nread && (MS_TIMER - chtm) >= tmout)
         {
         	timedOut = 1;
         }
         else
         {
            yield;
         }
      }
   }
   cbuf_rdunlock(spf_icbuf);
#ifdef RS232_MONITOR
	_RS232_echo(p, nread, "RX-F");
#else
#ifdef RS232_MONITOR_F
	_RS232_echo(p, nread, "RX-F");
#endif
#endif
   return nread;
}

/*** Beginheader cof_serFputc */
scofunc void cof_serFputc(int c);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serFputc                   <RS232.LIB>

SYNTAX:		   void cof_serFputc(int c);

DESCRIPTION:   Writes a character to the F port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serFputc(int c)
{
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spf_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spf_ocbuf));
   havelock=1;

	waitfor(cbuf_putch(spf_ocbuf,c));

	spf_starttx();
	cbuf_wrunlock(spf_ocbuf);
#ifdef RS232_MONITOR
	if (c >= 0) printf(RS232_TXC, 'F', c, ((c < ' ' || c > '~') ? '.' : c));
#else
#ifdef RS232_MONITOR_F
	if (c >= 0) printf(RS232_TXC, 'F', c, ((c < ' ' || c > '~') ? '.' : c));
#endif
#endif
}

/*** Beginheader cof_serFputs */
scofunc void cof_serFputs(char *str);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serFputs                   <RS232.LIB>

SYNTAX:		   void cof_serFputs(char *str);

DESCRIPTION:   Writes a null terminated string to the F port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serFputs(char *str)
{
	static int bytesleft,length;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spf_icbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spf_ocbuf));
   havelock=1;

	bytesleft=length=strlen(str);

	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spf_ocbuf,str+(length-bytesleft),bytesleft);
		spf_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spf_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(str, length, "TX-F");
#else
#ifdef RS232_MONITOR_F
	_RS232_echo(str, length, "TX-F");
#endif
#endif
}

/*** Beginheader cof_serFwrite */
scofunc void cof_serFwrite(void *data, int length);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serFwrite                   <RS232.LIB>

SYNTAX:		   void cof_serFwrite(void *data, int length);

DESCRIPTION:   Writes length bytes to the F port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_serFwrite(void *data, int length)
{
	static int bytesleft;
   static char *v;
	static int havelock;

	abandon
	{
		if(havelock) cbuf_wrunlock(spf_ocbuf);
	}

	havelock=0;
	waitfor(cbuf_wrlock(spf_ocbuf));
   havelock=1;

   v = (char *)data;
	bytesleft=length;
	while(bytesleft>0)
	{
		bytesleft-=cbuf_put(spf_ocbuf,v+(length-bytesleft),bytesleft);
		spf_starttx();
		if(bytesleft) yield;
	}

	cbuf_wrunlock(spf_ocbuf);
#ifdef RS232_MONITOR
	_RS232_echo(v, length, "TX-F");
#else
#ifdef RS232_MONITOR_F
	_RS232_echo(v, length, "TX-F");
#endif
#endif
}

/*** Beginheader serFflowcontrolOn */
void serFflowcontrolOn();
/*** endheader */

//defaults for flow control RTS/CTS
#ifndef SERF_RTS_PORT
#define SERF_RTS_PORT PBDR
#warnt "SERF_RTS_PORT not defined: defaulting to PBDR"
#endif

#ifndef SERF_RTS_SHADOW
#define SERF_RTS_SHADOW PBDRShadow
#warnt "SERF_RTS_SHADOW not defined: defaulting to PBDRShadow"
#endif

#ifndef SERF_RTS_BIT
#define SERF_RTS_BIT 6
#warnt "SERF_RTS_BIT not defined: defaulting to 6"
#endif

#ifndef SERF_CTS_PORT
#define SERF_CTS_PORT PBDR
#warnt "SERF_CTS_PORT not defined: defaulting to PBDR"
#endif

#ifndef SERF_CTS_BIT
#define SERF_CTS_BIT 6
#warnt "SERF_CTS_BIT not defined: defaulting to 6"
#endif

#asm root
spf_checkcts_fc::
	 bool	hl
;ioi ld 	a, (SERF_CTS_PORT)
	IOREAD_A(SERF_CTS_PORT)
	 and	1 << SERF_CTS_BIT
	 ld	L, a
	 ret

spf_rtsoff_fc::
	 ld	 a, (SERF_RTS_SHADOW)
	 set	 SERF_RTS_BIT, a		;set RTS high (inactive)
	 ld	 (SERF_RTS_SHADOW), a
;ioi ld	 (SERF_RTS_PORT), a
	IOWRITE_A(SERF_RTS_PORT)
	 ret

spf_rtson_fc::
	 ld	 a, (SERF_RTS_SHADOW)
	 res   SERF_RTS_BIT, a		;set RTS low (active)
	 ld	 (SERF_RTS_SHADOW), a
;ioi ld	 (SERF_RTS_PORT), a
	IOWRITE_A(SERF_RTS_PORT)
	 ret

#endasm

/* START FUNCTION DESCRIPTION ********************************************
serFflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serFflowcontrolOn();

DESCRIPTION:   Turns on hardware flow control for channel F. This enables two
					digital lines that handle flow control, CTS(clear to send)
					and RTS(ready to send).
					CTS is an input that will be pulled active low by the other
					system when it is ready to receive data. The RTS signal
					is an output that the system uses to indicate that it is
					ready to receive data. It is driven low when data can be
					received.
					If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERF_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERF_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERF_RTS_BIT - the bit number for the RTS line
 					SERF_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERF_CTS_BIT - the bit number for the CTS line

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serFflowcontrolOn()
{
	frtscts = 1;
	//set flow control ISR functions
	f_checkctsfunc = spf_checkcts_fc;
	f_rtsoff = spf_rtsoff_fc;
	f_rtson = spf_rtson_fc;
	serFrtsLo = (int)(FINBUFSIZE * 0.2);
	serFrtsHi = (int)(FINBUFSIZE * 0.8);
	// turn on RTS if buffer is below 80%
	if (serFrdUsed() < serFrtsHi) (*f_rtson)();
}

/*** Beginheader serFflowcontrolOff */
void serFflowcontrolOff();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serFflowcontrolOff();

DESCRIPTION:   Turns off hardware flow control for channel F.
               This function is non-reentrant.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serFflowcontrolOff()
{
	frtscts = 0;
}

/*** Beginheader serFparity */
void serFparity(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFparity                   <RS232.LIB>

SYNTAX:		   void serFparity(int state);

DESCRIPTION:   Sets parity type for channel F. This function is non-reentrant.

PARAMETER1:		A bit mask for selecting parity mode
					PARAM_EPARITY	0x01
					PARAM_OPARITY	0x02
					PARAM_2STOP 	0x03
					PARAM_NOPARITY 0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serFparity(int state)
{
	if (state) {
		if (state == PARAM_OPARITY)
		{
			fparity = 1;
			ftwostop = 0;
			fparitytype = 0;
		}
		else if (state == PARAM_EPARITY)
		{
			fparity = 1;
			ftwostop = 0;
			fparitytype = 1;
		}
		else
		{
			ftwostop = 1;
			fparity = 0;
		}
	}
	else
	{
		fparity = 0;
		ftwostop = 0;
	}
	if(fsevenbit && !fparity && !ftwostop)
	{
		BitWrPortI(SFCR, &SFCRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SFCR, &SFCRShadow, 0, 2);
	}
}

/*** Beginheader serFdatabits */
void serFdatabits(int state);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFdatabits                   <RS232.LIB>

SYNTAX:		   void serFdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel F.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
					PARAM_7BIT	0x01
					PARAM_8BIT	0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

nodebug void serFdatabits(int state)
{
	if (state == PARAM_7BIT)
	{
		fsevenbit = 1;
	}
	else
	{
		fsevenbit = 0;
	}
	if(fsevenbit && !fparity && !ftwostop)
	{
		BitWrPortI(SFCR, &SFCRShadow, 1, 2);
	}
	else
	{
		BitWrPortI(SFCR, &SFCRShadow, 0, 2);
	}
}

/*** Beginheader serFrdFree */
int serFrdFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFrdFree                   <RS232.LIB>

SYNTAX:		   int serFrdFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port F input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the F input buffer
END DESCRIPTION **********************************************************/

nodebug int serFrdFree()
{
	return (int)cbuf_free(spf_icbuf);
}

/*** Beginheader serFwrFree */
int serFwrFree();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFwrFree                   <RS232.LIB>

SYNTAX:		   int serFwrFree();

DESCRIPTION:   Returns the number of characters of unused data space in the
               port F transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the F transmit buffer
END DESCRIPTION **********************************************************/

nodebug int serFwrFree()
{
	return (int)cbuf_free(spf_ocbuf);
}

/*** Beginheader serFrdUsed */
int serFrdUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFrdUsed                   <RS232.LIB>

SYNTAX:		   int serFrdUsed();

DESCRIPTION:   Returns the number of characters in the F input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the F input buffer
END DESCRIPTION **********************************************************/

nodebug int serFrdUsed()
{
	return (int)cbuf_used(spf_icbuf);
}

/*** Beginheader serFwrUsed */
int serFwrUsed();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFwrUsed                   <RS232.LIB>

SYNTAX:		   int serFwrUsed();

DESCRIPTION:   Returns the number of characters in the F output buffer.
               This function is non-reentrant.

PARAMETEutput buffer

RETURN VALUE:	the number of characters currently in the F output buffer
END DESCRIPTION **********************************************************/

nodebug int serFwrUsed()
{
	return (int)cbuf_used(spf_ocbuf);
}

/*** Beginheader serFrdFlush */
void serFrdFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFrdFlush                  <RS232.LIB>

SYNTAX:		   void serFrdFlush();

DESCRIPTION:   Flushes the serial port F input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

nodebug void serFrdFlush()
{
	cbuf_flush(spf_icbuf);
}

/*** Beginheader serFwrFlush */
void serFwrFlush();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFwrFlush                  <RS232.LIB>

SYNTAX:		   void serFwrFlush();

DESCRIPTION:   Flushes the serial port F transmit buffer.
               This fsables the F serial port. This function is non-reentrant.
This function is non-reentrant.
his function is non-reentrant.
reentrant.
eentrant.
END DESCRIPTION **********************************************************/

nodebug void serFwrFlush()
{
	cbuf_flush(spf_ocbuf);
}

/*** Beginheader serFclose */
void serFclose();
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
serFclose                   <RS232.LIB>

SYNTAX:		   void serFclose();

DESCRIPTION:   Disables the F serial port. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm xmem

serFclose::
    ld    a,0xc9        ; ret in first byte
    ipset 1
#if _USER
c	 SetVectIntern(SERF_OFS/0x10, spf_dummyfunc);
#else
    ld	(INTVEC_BASE + SERF_OFS), a		; ret in first byte of spfisr_start
#endif

    ld    a,0x00        ; disable interrupts for port
	 ld    (SFCRShadow),a
;ioi ld    (SFCR),a
	IOWRITE_A(SFCR)
    ld    a,(PGFRShadow)	;set PG2 to normal output
    res	 FDRIVE_TXD, a
    ld    (PGFRShadow),a
;ioi ld    (PGFR),a
	IOWRITE_A(PGFR)
    ipres
    lret

#endasm

/*** Beginheader serFrtsLo, serFrtsHi, serFopen, serFgetError,
     spf_icbuf, spf_ocbuf */
extern int serFrtsLo;
extern int serFrtsHi;
int serFopen(long baud);
char serFgetError();
void spf_init();
root void spf_starttx();
root void fDisable();
root void fEnable();
root void spf_isr();
root void spf_dummyfunc();
extern char spf_icbuf[];
extern char spf_ocbuf[];
extern char frtscts;
extern char fparity;
extern char fparitytype;
extern char fsevenbit;
extern char ftwostop;
//pointers to flow control functions
extern int (*f_checkctsfunc)();
extern void (*f_rtsoff)();
extern void (*f_rtson)();
extern char fparityerror;
extern char foverrun;
extern char serf_overflow;		//foverflow already exists\

#define FDRIVE_TXD 2

/*** endheader */

#undef FINBUFOK

#ifndef FINBUFSIZE
#define FINBUFSIZE 31
#warnt "FINBUFSIZE undefined, defaulting to 31"
#endif

#if (FINBUFSIZE & (FINBUFSIZE+1)) == 0
#define FINBUFOK 1
#endif

#ifndef FINBUFOK
#undef FINBUFSIZE
#define FINBUFSIZE 31
#warnt "FINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef FOUTBUFOK

#ifndef FOUTBUFSIZE
#define FOUTBUFSIZE 31
#warnt "FOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (FOUTBUFSIZE & (FOUTBUFSIZE+1)) == 0
#define FOUTBUFOK 1
#endif

#ifndef FOUTBUFOK
#undef FOUTBUFSIZE
#define FOUTBUFSIZE 31
#warnt "FOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char spf_icbuf[FINBUFSIZE+9];
char spf_ocbuf[FOUTBUFSIZE+9];

char frtscts;
char fparity;
char fparitytype;
char fsevenbit;
char ftwostop;
int (*f_checkctsfunc)();
void (*f_rtsoff)();
void (*f_rtson)();

int  serFrtsLo;
int  serFrtsHi;
char fparityerror;
char foverrun;
char serf_overflow;		//foverflow already exists

/* START FUNCTION DESCRIPTION ********************************************
serFopen                   <RS232.LIB>

SYNTAX:		   int serFopen(long baud);

DESCRIPTION:   Opens the F serial port.
               This function is non-reentrant.

PARAMETER1:    baud : bits per second of data transfer

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

RELATED WORDS: serFgetc, serFgetc, serFpeek,
               serFputs, serFwrite,
               cof_serFgetc, cof_serFgets, cof_serFread,
               cof_serFputc, cof_serFputs, cof_serFwrite
               serFclose

END DESCRIPTION **********************************************************/

nodebug int serFopen(long baud)
{
   static long divisor, ta1div;
   static float baudratio;
	static unsigned long t;

   ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	WrPortI(TACR, &TACRShadow, TACRShadow | 0x08);
	}
	else
	{
   	WrPortI(TACR, &TACRShadow, TACRShadow & ~0x08); // clear bit
	}

	frtscts = 0;
	fsevenbit = 0;
	fparity = 0;
	fparitytype = 0;
	ftwostop = 0;
	fparityerror = 0;
	foverrun = 0;
	serf_overflow = 0;
	//use the dummy versions of the flow control functions
	//all they do is return. They are placeholders in case flow control
	//enabled
	f_checkctsfunc = spf_dummyfunc;
	f_rtsoff = spf_dummyfunc;
	f_rtson = spf_dummyfunc;
	WrPortI(TAT3R, &TAT3RShadow, (char)divisor);
   cbuf_init(spf_icbuf,FINBUFSIZE);
   cbuf_init(spf_ocbuf,FOUTBUFSIZE);

   spf_init();
   t = MS_TIMER;
   // let baud timer time out before using port
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   cbuf_getch(spf_icbuf);
   cbuf_getch(spf_icbuf);
   baudratio = ((RS232_BASEFREQ*freq_divider) /
   	(32 * ((divisor & 0xff) + 1) + 0.5)) / (float)(baud * (ta1div + 1));
   return (baudratio > 0.95 && baudratio < 1.05);
}

/* START FUNCTION DESCRIPTION ********************************************
serFgetError                   <RS232.LIB>

SYNTAX:		   char serFgetError();

DESCRIPTION:   Returns the error flags byte for serial channel F
					This can then be compared against error bitmasks to determine
					what errors occured. Additionally, any bits set in the returned
					error flags will be automatically cleared. This function is
               non-reentrant.

					Error bitmasks:
						SER_PARITY_ERROR	0x01
						SER_OVERRUN_ERROR 0x02
						SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

END DESCRIPTION **********************************************************/

nodebug char serFgetError()
{
	static char error_flags;

	error_flags = 0;
	if	(foverrun)
	{
		error_flags |= SER_OVERRUN_ERROR;
		foverrun = 0;
	}
	if (fparityerror)
	{
		error_flags |= SER_PARITY_ERROR;
		fparityerror = 0;
	}
	if (serf_overflow)
	{
		error_flags |= SER_OVERFLOW_ERROR;
		serf_overflow = 0;
	}

	return error_flags;
}

#asm root

;
; interrupt routine to be copied into interrupt table
;

spfisr_start::
    call  spf_isr       ; 19
    ret                 ; 8

spf_dummyfunc::
	ret
#endasm

#asm xmem
;
; spf_init
;

spf_init::
#if _USER
	 ipset 1
c	 SetVectIntern(SERF_OFS/0x10, spfisr_start);
#else
    ld	 de, INTVEC_BASE + SERF_OFS
    ld    hl,spfisr_start
    ld    bc,0x0010     ; copy 16 bytes from spfisr_start into interrupt table
    ipset 1

	#if __SEPARATE_INST_DATA__
	    call inst2data_ldir
	#else
	    ldir
	#endif
#endif
    ld	 a, (PGDRShadow)
    set	 FDRIVE_TXD, a    ;Tx should initially be idle high
    ld	 (PGDRShadow), a
;ioi ld	 (PGDR), a
	IOWRITE_A(PGDR)

    ld    a,(PGFRShadow)	;set PG2 to serial out
    set	 FDRIVE_TXD, a
    ld    (PGFRShadow),a
;ioi ld    (PGFR),a
	IOWRITE_A(PGFR)
    ld    a,(PGDCRShadow)	;set PG2 to be push-pull
    res	 FDRIVE_TXD, a
    ld    (PGDCRShadow),a
;ioi ld    (PGDCR),a
	IOWRITE_A(PGDCR)

    ld    a,(PGDDRShadow)	;set PG2 to be output
    set	 FDRIVE_TXD, a
    ld    (PGDDRShadow),a
;ioi ld    (PGDDR),a
	IOWRITE_A(PGDDR)

    ld    a,0x01
    ld    (SFCRShadow),a
;ioi ld    (SFCR),a
	IOWRITE_A(SFCR)
    ipres
    lret
#endasm

#asm root
spf_starttx::				;called by C put routines to start up interrupt loop,
								; if tx is idle
	 push	 af				; cbuf_getch inside of spf_txload uses most of the
	 							; registers
	 push	 bc
	 push	 de
	 push	 hl
	 ipset 1

;ioi ld	 a, (SFSR)
	IOREAD_A(SFSR)
	 bit	 3, a
	 jr	 nz, spf_starttx_exit	; if tx is busy then it will catch whatever
	 										; is in the buffer
	 ld	 a, (frtscts)
	 or	 a
	 jr	 z, spf_starttx_load

	 call  spf_checkcts
	 bool	 hl
	 jr	 nz, spf_starttx_dummy

spf_starttx_load:
	 call	 fEnable
	 call	 spf_txload
	 jr	 spf_starttx_exit

spf_starttx_dummy:
	 call	 fDisable
	 ld	 a, 23
;ioi ld	 (SFDR), a
	IOWRITE_A(SFDR)

spf_starttx_exit:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

fDisable::
	 ld    a,(PGDRShadow)
    set   FDRIVE_TXD,a	  ;make sure Tx is high(idle)
    ld    (PGDRShadow),a
;ioi ld    (PGDR),a
	IOWRITE_A(PGDR)
    ld    a,(PGFRShadow)
    res   FDRIVE_TXD,a
    ld    (PGFRShadow),a
;ioi ld    (PGFR),a
	IOWRITE_A(PGFR)
    ret


fEnable::
    ld    a,(PGFRShadow)
    set   FDRIVE_TXD,a
    ld    (PGFRShadow),a
;ioi ld    (PGFR),a
	IOWRITE_A(PGFR)
    ret


spf_checkcts:				;hl will be non-zero if CTS is high, uses register a
	 ld	hl, (f_checkctsfunc)
	 jp	(hl)


spf_txload:
    ld    hl,spf_ocbuf  ; 6,	retrieve character from circular buffer
    push  hl            ; 10
    lcall  cbuf_getch    ; 12+...
    add	 sp, 2
    bit   7,h           ; 4,	was there a character?
    jp    nz,spf_txload_exit

	 ld	 a, (ftwostop)
	 or	 a
	 jp	 nz, spf_txload_2stop

	 ld	 a, (fparity)	;check to see if we need to add a parity bit
	 or	 a
	 jp	 z, spf_txload_sendbyte
	 ld	 a, (fsevenbit) ;are we doing 7 or 8 bit data?
	 or	 a
	 jp	 nz, spf_txload_7bitparity
spf_txload_8bitparity:
	 push	 hl	;save the byte value
	 ld	 a, (fparitytype)
	 ld	 h, a
	 lcall	 ser8_getparity
	 bool  hl
	 pop	 hl
	 jr	 z, spf_txload_9bitlow
spf_txload_9bithigh:
	 ld	 a, L
;ioi ld	 (SFLR), a
	IOWRITE_A(SFLR)
	 jr	 spf_txload_exit

spf_txload_9bitlow:
	 ld	 a, L
;ioi ld	 (SFAR), a			;load byte into alternate register
	IOWRITE_A(SFAR)
	 jr	 spf_txload_exit

spf_txload_7bitparity:
	 ld	 a, (fparitytype)
	 ld	 h, a
	 lcall  ser7_setparity
	 jp	 spf_txload_sendbyte

spf_txload_2stop:
	 ld	 a, (fsevenbit)
	 or	 a
	 jr	 z, spf_txload_9bithigh
	 ld	 a, L
	 or	 0x80
	 ld	 L, a
spf_txload_sendbyte:
    ld	 a, L
;ioi ld	 (SFDR), a
	IOWRITE_A(SFDR)
spf_txload_exit:
	 ret



;
; spf_isr
;

spf_isr::
	push	af					; 7, 	restore registers needed by isr
	push	bc					; 7
	push	de					; 7
	push	hl					; 7

;ioi ld	 a,(SFSR)			; 11,	interrupt source rx or tx
	IOREAD_A(SFSR)
#if (_USER)
	;acknowledge interrupt immediately for RabbitSys
	IOWRITE_A(SFSR)
#endif
	 ld    c,a
	 rla						; 2
	 jp	 c,spf_rx			; 5

spf_tx:
    bit   2,c           ; Tx busy? bit 2 shifted via rla
    jr    nz,spf_txbusy
spf_txidle:             ; Tx idle, safe for enable/disable transition
	 ld 	 a, (frtscts)
	 or	 a
    jr	 z, spf_trytosend ;try one more time to load a byte
	 call  spf_checkcts
	 bool	 hl
	 jr	 nz, spf_disabletx

spf_trytosend:
	 call	 fEnable
	 call	 spf_txload				;CTS is on, so try to load a normal byte
	 jr	 spf_donomore

spf_disabletx:
	 call  fDisable
	 ld	 a, 42
;ioi ld	 (SFDR), a				; load 42 into SADR as a dummy byte,
	IOWRITE_A(SFDR)
										; to keep the interrupt loop going
	 jr	 spf_donomore

spf_txbusy:
    ld    a,(PGFRShadow)		; check to make sure tx is enabled
    bit   FDRIVE_TXD,a			; if not, dummy character still needs to
    									; clear out
    jr    z, spf_donomore
	 ld 	 a, (frtscts)			; are we using CTS?
	 or	 a
    jr	 z, spf_txallgood
	 call  spf_checkcts
	 bool	 hl
	 jr	 nz, spf_donomore		; CTS is off, don't fill SBDR
spf_txallgood:
	 call	 spf_txload				; will load a good byte, it there is one to
	 									; be loaded
spf_donomore:
;ioi ld    (SFSR),a      ; 10,	clear interrupt source
#if !(_USER)
	IOWRITE_A(SFSR)
#endif
    ipres               ; 4
    pop   hl            ; 7, 	restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13


spf_rx:
;ioi ld    a,(SFDR)      ; 11,	receive the character
	IOREAD_A(SFDR)
    bool  hl            ; 2,	place character on circular buffer
    ld    l,a           ; 2,		throw it away if no room
 	 ld	 b,a				; save for later possible parity check
	 ld	 a, (fsevenbit)
	 or	 a
	 jr	 z, spf_rxcontinue
	 ld	 a, L
	 and	 0x7f
	 ld	 L, a				;mask out MSB for 7 bit data
spf_rxcontinue:
	 push	 bc				; save byte copy and status register copy
    push  hl            ; 10
    ld    hl,spf_icbuf  ; 6
    push  hl            ; 10
    lcall  cbuf_putch	   ; 12+...
    add   sp,4          ; 4
	 bool	 hl
	 jr	 nz, spf_checkoverrun
	 ld	 a, 0x01
	 ld	 (serf_overflow), a
spf_checkoverrun:
    pop	 bc
    bit	 5, c				;test for receiver overrun
    jr	 z, spf_checkparity
    ld	 a, 0x01
    ld	 (foverrun), a

spf_checkparity:
	 ld	 a, (fparity)
	 or	 a								; see if we need to check parity of
	 										; incoming byte
	 jr	 z, spf_rx_flowcontrol
	 ld	 a, (fsevenbit)
	 or	 a
	 jr	 nz, spf_check7bit
spf_check8bit:
	 ld	 l, b
	 ld	 a, (fparitytype)
	 ld	 h, a
	 lcall	 ser8_getparity
	 bool  hl
	 jr	 z, spf_check9low
spf_check9high:						; 9th parity bit should be high,
											; otherwise we have a parity error
	 bit	 6, c							; C reg should still have a snapshot of
	 										; the status register, checking bit 9
	 jr	 z, spf_rx_flowcontrol	; no 9th bit detected (9th bit high),
	 										; so we are OK
	 or	 a, 0x01
	 ld	 (fparityerror), a		;signal a parity error
	 jr	 spf_rx_flowcontrol
spf_check9low:
	 bit	 6, c
	 jr	 nz, spf_rx_flowcontrol	; 9th bit detected (9th bit low),
	 										; which is what we expect
	 or	 a, 0x01
	 ld	 (fparityerror), a
	 jr	 spf_rx_flowcontrol
spf_check7bit:
	 ld	 l, b
	 ld	 a, (fparitytype)
	 ld	 h, a
	 call	 ser7_checkparity
	 bool	 hl
	 jr	 nz, spf_rx_flowcontrol
	 or	 a, 0x01
	 ld	 (fparityerror), a

spf_rx_flowcontrol:
    ld    a,(frtscts)
    or    a
    jr    z,spf_rx0
    ld    hl,spf_icbuf  ;
    push  hl            ;
    lcall  cbuf_used     ;
    add   sp,2          ;
    ld    d,h
    ld    e,l
    ld    b,d
    ld    c,e           ; copy number bytes used to bc
    ld    hl,(serFrtsHi);
    ld    a,d           ;
    cp    h             ;
    jr    c,spf_rx0     ;
    ld    a,e           ;
    cp    l             ;
    jr    c,spf_rx0     ;
spf_overHi:					; turn off the RTS line
	 ld	 hl, spf_rx0
	 push	 hl				;set return address
	 ld	 hl, (f_rtsoff)
	 jp	 (hl)
spf_rx0:
    ipres               ; 4
    pop   hl            ; 7,  restore registers needed by isr
    pop   de            ; 7
    pop   bc            ; 7
    pop   af            ; 7
    ret                 ; 13

#endasm

//************************************************************************
//************************* Parity Check *********************************
//************************************************************************

/*** Beginheader serSetParity, serCheckParity,
	ser8_getparity, ser7_setparity, ser7_checkparity, ser_paritytable */
char serSetParity(char tx_byte, char parity);
int serCheckParity(char rx_byte, char parity);
xmem void ser8_getparity();		//asm calls, don't use in C
xmem void ser7_setparity();
xmem void ser7_checkparity();
extern char ser_paritytable[];
/*** endheader */

//need to initialize parity table, table contains a value of 0x80 if there
// are an even number of bits
// this is the correct mask for setting 8th bit for odd parity with 7bit data
root char ser_paritytable[256];

//no need to actually call this
nodebug void ser_setupparitytable() {

	static int i;
	static int j;
	static int count;
	#GLOBAL_INIT
	{
		for (i = 0;i < 256;i++)
		{
			count = 0;
			for (j = 0;j < 8;j++)
			{
				if (i & (1 << j)) count++;
			}
			if (count%2 == 0)
			{
				//even number of bits
				ser_paritytable[i] = 0x80;
			}
			else
			{
				ser_paritytable[i] = 0;
			}
		}
	}
}


#asm xmem

; returns parity bit for an 8bit data byte (9bit byte)
; assumes byte is in L, parity flag is in H - 0 for odd, 1 for even
; returns parity bit in hl
; trashes A register
ser8_getparity::
	 push	 de
	 push  ix
	 xor	 a
	 ld	 d, a		;clear high byte of de
	 ld	 e, L		;de now has byte value (table offset)
	 ld	 L, a		;clear out L, so we can do a bool test on the
	 					;parity flag later
	 ld	 ix, ser_paritytable
	 add	 ix, de
	 ld	 a, (ix)
	 bool  hl
	 jr	 z, ser8_getparity_odd
ser8_getparity_even:
	 xor	0x80		;invert mask bit
	 ld	L, a
	 bool hl
	 pop 	ix
	 pop 	de
	 lret
ser8_getparity_odd:
	 ld	 L, a
	 bool	 hl
	 pop	 ix
	 pop	 de
	 lret


; sets the parity bit for a 7bit character
; assumes character in L, parity flag in H - 0 for odd, 1 for even
; returns parity fixed byte in L
; trashes A register
ser7_setparity::
	 push	 de
	 push	 ix
	 ld	 a, L
	 and	 0x7f		;strip high bit
	 ld	 L, a		;put back into hl
	 ld	 e, a
	 xor	 a
	 ld	 d, a		;de now holds the byte value (table offset)
	 ld 	 ix, ser_paritytable
	 add	 ix, de
	 ld	 a, h
	 or	 a
	 jr	 z, ser7_setparity_odd
ser7_setparity_even:
	 ld	 a, (ix)
	 or	 a			;test if we got a nonzero mask
	 jr	 z, ser7_setparity_setbit
	 ;correct byte is already in L register so just return
	 pop	 ix
	 pop	 de
	 lret
ser7_setparity_odd:
	 ld	 a, (ix)
	 or	 a
	 jr	 nz, ser7_setparity_setbit
	 pop	 ix
	 pop	 de
	 lret
ser7_setparity_setbit:
	 ld	 a, L
	 or	 0x80
	 ld	 L, a
	 pop	 ix
	 pop	 de
	 lret

;checks if the parity for a byte with 7 data bits is correct
;L contains the byte to check, H holds the parity type flag -
;0 for odd, 1 for even
;returns true on hl if parity is correct
; trashes A register
ser7_checkparity::
	 push	 de
	 push	 ix
	 ld	 a, L
	 and	 0x7f		;drop parity bit
	 ld	 e, a
	 xor	 a
	 ld	 d, a		;de contains byte value (table offset)
	 ld	 ix, ser_paritytable
	 add	 ix, de	;ix is ready for table read
	 ld	 a, h
	 or	 a			;test parity flag
	 jr	 z, ser7_checkparity_odd
ser7_checkparity_even:
	 ld	 a, (ix)
	 xor	 L			;test mask against original byte
	 and	 0x80
	 bool  hl
	 ld	 L, a		;L is nonzero if mask bit and parity bit were opposite
	 					; (true for even parity)
	 bool	 hl
	 pop	 ix
	 pop	 de
	 lret
ser7_checkparity_odd:
	 ld	 a, (ix)
	 xor	 L			;test mask against original byte
	 xor	 0x80	   ;invert high bit
	 and	 0x80		;mask all but high bit
	 bool  hl
	 ld	 L, a 	;L is nonzero if mask bit and parity bit are equal
	 					; (true for odd parity)
	 bool  hl
	 pop	 ix
	 pop	 de
	 lret

#endasm

/* START FUNCTION DESCRIPTION ********************************************
serSetParity                  <RS232.LIB>

SYNTAX:		   char serSetParity(char tx_byte, char parity);

DESCRIPTION:   returns an 8bit version of the input byte with the high bit set
					for correct parity

PARAMETER1:    tx_byte : the original 7bit character without a parity bit
PARAMETER2:    parity: This can be one of two character values
							  'E' - even parity, returned character will have
							   	even number of set bits
							  'O' - odd parity, returned character will have
							  		odd number of set bits

RETURN VALUE:	The tx_byte with its high bit set for correct parity

END DESCRIPTION **********************************************************/

nodebug char serSetParity(char tx_byte, char parity)
{
	tx_byte = tx_byte & 0x7f;
	if (parity == 'O')
	{
		// table has masks for setting odd parity directly
		return (tx_byte | ser_paritytable[tx_byte]);
	}
	else if (parity == 'E')
	{
		// set bit, then clear if necessary
		return (tx_byte | 0x80) & ~(ser_paritytable[tx_byte]);
	}
	else
	{
		// bad parity type character, what do we do???
		return 0;
	}
}

/* START FUNCTION DESCRIPTION ********************************************
serCheckParity                  <RS232.LIB>

SYNTAX:		   int serCheckParity(char rx_byte, char parity);

DESCRIPTION:   returns true if parity of rx_byte matches the parity type given
					for the sake of speed, this function does not check for
					invalid parity types

PARAMETER1:    rx_byte : character for which parity bit will be checked
PARAMETER2:    parity: This can be one of two character values
							  'E' - even parity, returns true if even number of
							   	set bits
							  'O' - odd parity, returns true if odd number of
							   	set bits

RETURN VALUE:	1 if parity is correct
					0 if parity is not correct

END DESCRIPTION **********************************************************/

nodebug int serCheckParity(char rx_byte, char parity)
{
	if ( (rx_byte & 0x80) ^ (ser_paritytable[rx_byte & 0x7f]) )
	{
		//high bit does not match parity table mask
		if (parity == 'E')
		{
			return 1;
		}
		else
		{
			//assuming parity == 'O'
			return 0;
		}
	}
	else
	{
		if (parity == 'O')
		{
			return 1;
		}
		else
		{
			return 0; //assumes parity == 'E'
		}
	}
}


/*** BeginHeader */

#endif

/*** EndHeader */

