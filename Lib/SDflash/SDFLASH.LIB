/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/************************************************************************
SDFLASH.LIB

Library for interfacing to SD flash memory devices on an SPI bus.

The functions are:

sdspi_initDevice
sdspi_read_sector
sdspi_write_sector
sdspi_WriteContinue
sdspi_notbusy
sdspi_print_cid
sdspi_print_dev
sdspi_getSectorCount
sdspi_isWriting
sdspi_reset_card
sdspi_get_status_reg
sdspi_init_card
sdspi_process_command
sdspi_get_csd
sdspi_get_scr
sdspi_get_cid
sdspi_set_block_length
sdspi_debounce
sdspi_setLED

Revision History:	Rev 1.0 Initial Release

*************************************************************************/

/*** BeginHeader */

#ifndef __SDFLASH_LIB__
#define __SDFLASH_LIB__

/*
_XMEM_XLAT is a macro to jump to the assembly routine _xmem_xlat from non-root
code
*/
// Expects A to contain the relevant XPC value;
// HL contains a logical address in 0xE000-0xEFFF range of the data to translate,
// B contains number of bytes to translate (1 <= B <= 255, or 0 for 256 bytes),
// DE' points to a 256-byte translation table in root memory.
// On return, AF and HL' trashed; B set to zero, HL points to first byte after
// translated section.  Other regs preserved.
#define _XMEM_XLAT	db 0xCF $ dw _xmem_xlat $ db 0

// Number of SD sockets available, NOT the number of supported devices.
// All standard SD memory cards are supported.
// Every SD socket must have a static sd_dev_interface structure with
// information on how the socket is connected to the processor.
// Reading of the CDS from the card is used to fill in the table entry
// values rather than a constant look-up table.
#define SDFLASH_MAX_DEVS 1

#define SDFLASH_SDHC 1

#ifdef SDFLASH_DEBUG
#define _sdflash_nodebug debug
#else
#define _sdflash_nodebug nodebug
#endif

#ifndef errno
#use "ErrNo.lib"
#endif

// Uncomment to place 512 byte CRC16 table in RAM
#define SD_CRC16_TABLE_IN_FLASH

/*** EndHeader */


/*** BeginHeader sdspi_initDevice ****************************/

   //*** SD HW Definitions
   #define SD_CD_PORT           PDDR
   #define SD_CD_PORT_FR        PDFR
   #define SD_CD_PORT_FRSHADOW  &PDFRShadow
   #define SD_CD_PORT_DDR       PDDDR
   #define SD_CD_PORT_DDRSHADOW &PDDDRShadow
   #define SD_CD_PIN            2

   // No Write Protect input
   #define SD_WP_PORT           0
   #define SD_WP_PORT_FR        0
   #define SD_WP_PORT_FRSHADOW  NULL
   #define SD_WP_PORT_DDR       0
   #define SD_WP_PORT_DDRSHADOW NULL
   #define SD_WP_PIN            0

   // CS for the BL2600Q, RCM39xx uses the BUFFEN pin and requires
   // specialized initialization
   #define SD_CS_PORT           GOCR
   #define SD_CS_PORT_DRSHADOW  &GOCRShadow
   #define SD_CS_PORT_DDR       0
   #define SD_CS_PORT_FR        0
   #define SD_CS_PORT_FRSHADOW  NULL
   #define SD_CS_PORT_DDRSHADOW NULL
   #define SD_CS_PORT_DCR       0
   #define SD_CS_PORT_DCRSHADOW NULL
   #define SD_CS_PIN            0
   #define SD_CS_PORT_OD        1   // Use OD for disable state on GOCR

   #define SD_TX_PORT_DR        PCDR
   #define SD_TX_PORT_DRSHADOW  &PCDRShadow
   #define SD_TX_PORT_FR        PCFR
   #define SD_TX_PORT_FRSHADOW  &PCFRShadow
   #define SD_TX_PORT_DDR       0
   #define SD_TX_PORT_DDRSHADOW NULL
   #define SD_TX_PORT_DCR       0
   #define SD_TX_PORT_DCRSHADOW NULL
   #define SD_TX_PIN            4
   #define SD_TX_PORT_OD        0

   #define SD_PWR_PORT_DR        0     // Power pin not used on BL2600Q, RCM39xx
   #define SD_PWR_PORT_DRSHADOW  NULL
   #define SD_PWR_PORT_FR        0
   #define SD_PWR_PORT_FRSHADOW  NULL
   #define SD_PWR_PORT_DDR       0
   #define SD_PWR_PORT_DDRSHADOW NULL
   #define SD_PWR_PORT_DCR       0
   #define SD_PWR_PORT_DCRSHADOW NULL
   #define SD_PWR_PIN            0
   #define SD_PWR_PORT_OD        0
   #define SD_PWR_PORT_ON        1

   #define SD_LED_PORT_DR        0      // LED Not on BL2600Q, RCM39xx boards
   #define SD_LED_PORT_DRSHADOW  NULL
   #define SD_LED_PORT_FR        0
   #define SD_LED_PORT_FRSHADOW  NULL
   #define SD_LED_PORT_DDR       0
   #define SD_LED_PORT_DDRSHADOW NULL
   #define SD_LED_PORT_DCR       0
   #define SD_LED_PORT_DCRSHADOW NULL
   #define SD_LED_PIN            0
   #define SD_LED_PORT_OD        0
   #define SD_LED_PORT_ON        0

   #define SD_RX_PORT_DR         PCDR
   #define SD_RX_PORT_FR         PCFR
   #define SD_RX_PORT_FRSHADOW   &PCFRShadow
   #define SD_RX_PORT_DDR        0
   #define SD_RX_PORT_DDRSHADOW  NULL
   #define SD_RX_PIN             5

   #define SD_CLK_PORT_DR        PBDR
   #define SD_CLK_PORT_FR        0
   #define SD_CLK_PORT_FRSHADOW  NULL
   #define SD_CLK_PORT_DDR       PBDDR
   #define SD_CLK_PORT_DDRSHADOW &PBDDRShadow
   #define SD_CLK_PORT_DCR       0
   #define SD_CLK_PORT_DCRSHADOW NULL
   #define SD_CLK_PIN            0
   #define SD_CLK_PORT_OD        0     // Open drain control

   #define SD_SPI_TACRSHADOW &TACRShadow
   #define SD_SPI_SERPORT SBDR
   #define SD_SPI_TCREG TACR
   #define SD_SPI_TCRSHADOW &TACRShadow
   #define SD_SPI_TCRVALUE 0

   #define SD_SPI_SERSHADOW &SBERShadow
   #define SD_SPI_SERVALUE SD_SPI_CLOCK_MODE

   #define SD_SPI_SCRSHADOW &SBCRShadow
   #define SD_SPI_SCRVALUE SD_SPI_CONTROL_VALUE

   #define SD_SPI_DIVREG TAT5R
   #define SD_SPI_DIVREGSHADOW &TAT5RShadow
   #define SD_SPI_DIVISOR 0

   #define SD_ENABLECS(DI) BitWrPortI(DI->csport,DI->csportdrShadow,0,DI->cspin)
   #define SD_DISABLECS(DI) BitWrPortI(DI->csport,DI->csportdrShadow,1,DI->cspin)
   #define SD_ENABLEPOW(DI) BitWrPortI(DI->pwrport,DI->pwrportdrShadow,DI->pwron,DI->pwrpin)
   #define SD_DISABLEPOW(DI) BitWrPortI(DI->pwrport,DI->pwrportdrShadow,DI->pwron^1,DI->pwrpin)

   //SD serial port register offsets
   #define SD_AR_OFFSET 1
   #define SD_SR_OFFSET 3
   #define SD_CR_OFFSET 4
   #define SD_ER_OFFSET 5
   #define SD_SPI_CONTROL_VALUE 0x0c
   #define SD_SPI_TXMASK 0x80
   #define SD_SPI_RXMASK 0x40
   #define SD_SPI_CLOCK_MODE 0

/*
 * SPI bus timing requirements for SD devices
 */
#define NCS_MIN     0
#define NCR_MAX     8
#define NRC_MIN     1
#define NWR_MIN     1
#define NEC_MIN     0
#define NDS_MIN     0
#define NBR_MAX     1
#define NCX_MAX     8

/*
 * Data packet sizes and buffer offsets
 */
#define COMMAND_BYTE_COUNT       6   // All SPI commands sent as 48 bits
#define R1_BYTE_COUNT            1   // R1 responses are 1 byte
#define R2_BYTE_COUNT            2   // R2 responses are 2 bytes
#define R3_BYTE_COUNT            5   // R3 (READ_OCR) responses are 5 bytes
#define R7_BYTE_COUNT            5   // R7 (SEND_IF_COND) responses are 5 bytes

// largest response that doesn't include a data block
#define MAX_RESPONSE_COUNT       R7_BYTE_COUNT

/* CSD = 16 bytes data, 1 byte start block and 2 bytes for 16 bit CRC */
#define CSD_BYTE_COUNT           19
#define BLOCK_SIZE               512L
/* DATA BLOCK = 512 bytes data, 1 byte start block and 2 bytes for 16 bit CRC */
#define DATA_BLOCK_SIZE          (BLOCK_SIZE + 3)
#define DATA_RESPONSE_BYTE_COUNT 1
#define READ_CSD_BUFFER_SIZE     (R2_BYTE_COUNT + CSD_BYTE_COUNT)
#define READ_BLOCK_BUFFER_SIZE   (R2_BYTE_COUNT + DATA_BLOCK_SIZE)
#define READ_SCR_BUFFER_SIZE     (R2_BYTE_COUNT + SCR_BYTE_COUNT)
#define SCR_BYTE_COUNT           11

/*
 * SD commands supported
 */
#define CMD0        0    // GO_IDLE_STATE
#define CMD1        1    // (deprecated command related to MMC)
#define CMD8        8    // SEND_IF_COND
#define CMD9        9    // SEND_CSD
#define CMD10       10   // SEND_CID
#define CMD13       13   // SEND_STATUS
#define CMD16       16   // SET_BLOCKLEN
#define CMD17       17   // READ_SINGLE_BLOCK
#define CMD24       24   // WRITE_BLOCK
#define CMD32       32   // ERASE_WR_BLK_START
#define CMD33       33   // ERASE_WR_BLK_END
#define CMD38       38   // ERASE
#define CMD55       55   // APP_CMD
#define CMD58       58   // READ_OCR
#define CMD59       59   // CRC_ON_OFF

// Re-use CMD_START flag for application commands (ACMDs) to automate sending CMD55 first
#define ACMD51      (CMD_START + 51)   // SEND_SCR
#define ACMD41      (CMD_START + 41)   // SD_SEND_OP_COND
#define ACMD42      (CMD_START + 42)   // SET_CLR_CARD_DETECT

/*
 * Command retry count
 */
#define CMD0_RETRIES               2000
#define CMD1_RETRIES               5000
#define BUSY_RETRIES               5400

// number of milliseconds allowed before timeout
#define REPLY_TIMEOUT_MS           2

/*
 * Command R1 (one byte command response) error codes
 */
#define R1_IDLE_STATE              0x01
#define R1_ERASE_RESET             0x02
#define R1_ILLEGAL_COMMAND         0x04
#define R1_CRC_ERROR               0x08
#define R1_ERASE_SEQUENCE_ERROR    0x10
#define R1_ADDRESS_ERROR           0x20
#define R1_PARAMETER_ERROR         0x40

/*
 * Command R2 (two byte command response) error code for second byte
 */
#define R2_CARD_LOCKED             0x01
#define R2_WRITE_PROTECT_ERASE     0x02
#define R2_GENERAL_ERROR           0x04
#define R2_CC_ERROR                0x08
#define R2_CARD_ECC_FAILED         0x10
#define R2_WRITE_PROTECT_VIOLATION 0x20
#define R2_ERASE_PARAM             0x40
#define R2_OUT_OF_RANGE            0x80

/*
 * Bitmasks for command, response and data
 */
#define CMD_START                  0x40
#define CMD_END                    0x01
#define CMD_MASK_UPPER_BYTES       0xFF
#define CMD_INDEX_OFFSET           NCS_MIN
#define CMD_ARGUMENT_OFFSET        NCS_MIN + 1
#define CMD_CRC_INDEX              NCS_MIN + 5
#define CMD_NCR_OFFSET             NCS_MIN + COMMAND_BYTE_COUNT
#define R1_MASK_LOW_BITS           0x80
#define DATALINE_HIGH              0xFF
#define DATALINE_LOW               0x00
#define READ_WRITE_START_BLOCK     0xFE
#define READ_DATA_ERROR            0x0F
#define WRITE_RESPONSE_BITMASK     0x1F
#define WRITE_DATA_ACCEPTED        0x05
#define WRITE_DATA_CRC_ERROR       0x09
#define WRITE_DATA_WRITE_ERROR     0x0D
#define DATAOUT_LINE_HIGH          0xFFFFFFFF
#define MASKOUT_31_LOWER_BITS      0x80000000

/*
 * CSD block byte offsets
 */
#define CSD_BLOCK_OFFSET_0            0
#define CSD_BLOCK_OFFSET_1            1
#define CSD_BLOCK_OFFSET_2            2
#define CSD_BLOCK_OFFSET_3            3
#define CSD_BLOCK_OFFSET_4            4
#define CSD_BLOCK_OFFSET_5            5
#define CSD_BLOCK_OFFSET_6            6
#define CSD_BLOCK_OFFSET_7            7
#define CSD_BLOCK_OFFSET_8            8
#define CSD_BLOCK_OFFSET_9            9
#define CSD_BLOCK_OFFSET_10           10
#define CSD_BLOCK_OFFSET_11           11
#define CSD_BLOCK_OFFSET_12           12
#define CSD_BLOCK_OFFSET_13           13
#define CSD_BLOCK_OFFSET_14           14
#define CSD_BLOCK_OFFSET_15           15

/*
 * SCR block byte offsets
 */
#define SCR_BLOCK_OFFSET_0            0
#define SCR_BLOCK_OFFSET_1            1

/*
 * Serial port status register bitmasks
 */
#define SERIAL_STATUS_RXFDB           0x00300000
#define SERIAL_STATUS_RRDY            0x00000800
#define SERIAL_STATUS_RBC             0x00000200
#define SERIAL_STATUS_TRDY            0x00000008
#define SERIAL_STATUS_RXFDB_OFFSET    20

/*
 * Timeout values for SPI device responses in seconds
 */
#define WAIT_SERIAL_READ_TIMEOUT          1
#define WAIT_NOT_BUSY_TIMEOUT             1
#define WAIT_CMD_REPLY_TIMEOUT            1
#define WAIT_WRITE_DATA_REPLY_TIMEOUT     1

#ifdef SD_CRC16_TABLE_IN_FLASH
 extern const unsigned short crc_table[256]; /* for optimal ccitt crc16 calc. */
#else
 extern unsigned short crc_table[256]; /* for optimal ccitt crc16 calculation */
#endif

extern char rx_buffer[READ_BLOCK_BUFFER_SIZE];

// Non-zero if card in, 0 if no card
#define SD_cardDetect(dev) (RdPortI(dev->SDintf->cdport)&(1<<dev->SDintf->cdpin))

#define CSD_IS_SDHC(csd) (csd->CSD_STR == SD_CSD_STR_V2)
#define SD_IS_SDHC(sd)   (sd->CSD.CSD_STR == SD_CSD_STR_V2)


typedef struct sd_csd_type
{
   unsigned char init_ok;
   unsigned char CSD_STR;
   	#define SD_CSD_STR_V1 0x00
   	#define SD_CSD_STR_V2 0x01
   unsigned char TAAC;
   unsigned char NSAC;
   unsigned char TRANSPEED;
   unsigned int  CCC;
   unsigned char R_BL_LEN;
   unsigned char DSR_IMP;
   unsigned int  CSIZE;
   unsigned char C_SIZE_M;
   unsigned char ERASE_BLK_EN;
   unsigned char DEF_ECC;
   unsigned char R2W_FACT;
   unsigned char WR_BL_LEN;
   unsigned char WR_BL_PAR;
   unsigned char COPY;
   unsigned char P_WR_PROT;
   unsigned char T_WR_PROT;
   unsigned char CRC7;
} SD_CSD_TYPE;

typedef struct sd_scr_type
{
   char init_ok;
   char SCR_STRUCTURE;
   char SD_SPEC;
   char DATA_STAT_AFTER_ERASE;
   char SD_SECURITY;
   char SD_BUS_WIDTHS;
} SD_SCR_TYPE;

typedef struct sd_cid_type
{
   unsigned char MID;       // manufacturer ID
   char          OID[2];    // 2-character OEM ID
   char          PNM[5];    // 5-character product name
   unsigned char PRV;       // product revision
   unsigned long PSN;       // 32-bit product serial number
   unsigned int  MDT;       // manufacturing date
   unsigned char CRC7;      // CRC7 checksum
} SD_CID_TYPE;

typedef struct {
   // Chip select PxDR reg, pin number, control registers
   int  csport;    char *csportdrShadow;
   char cspin;
   int  csportddr; char *csportddrShadow;
   int  csportfr;  char *csportfrShadow;
   int  csportdcr; char *csportdcrShadow;
   char csod;

   // CLK line PxDR reg, pin number, control registers
   int  clkport;
   char clkpin;
   int  clkportddr; char *clkportddrShadow;
   int  clkportfr;  char *clkportfrShadow;
   int  clkportdcr; char *clkportdcrShadow;
   char clkod;

   // Card Detect port PxDR reg, pin number, control registers
   int  cdport;
   char cdpin;
   int  cdportddr; char *cdportddrShadow;
   int  cdportfr;  char *cdportfrShadow;

   // Write Protect port PxDR, pin number, control registers
   int  wpport;
   char wppin;
   int  wpportddr; char *wpportddrShadow;
   int  wpportfr;  char *wpportfrShadow;

   // TX port PxDR, pin number, control registers
   int  txport;
   char txpin;
   int  txportddr; char *txportddrShadow;
   int  txportfr;  char *txportfrShadow;
   int  txportdcr; char *txportdcrShadow;
   char txod;

   // RX port PxDR, pin number, control registers
   int  rxport;
   char rxpin;
   int  rxportddr;   char *rxportddrShadow;
   int  rxportfr;    char *rxportfrShadow;

   // PWR port PxDR, pin number, control registers
   int  pwrport;    char *pwrportdrShadow;
   char pwrpin;
   int  pwrportddr; char *pwrportddrShadow;
   int  pwrportfr;  char *pwrportfrShadow;
   int  pwrportdcr; char *pwrportdcrShadow;
   char pwrod;      char pwron;

   // LED port PxDR, pin number, control registers
   int  ledport;    char *ledportdrShadow;
   char ledpin;
   int  ledportddr; char *ledportddrShadow;
   int  ledportfr;  char *ledportfrShadow;
   int  ledportdcr; char *ledportdcrShadow;
   char ledod;      char ledon;

   // Serial port SxDR, use parallel port D flag
   char spdr;
   char *sperShadow;
   char sperValue;
   char *spcrShadow;
   char spcrValue;

   char spdivreg;
   char *spdivregShadow;
   char divisor;

   char sptcr;
   char *sptcrShadow;
   char sptcrValue;

} sd_dev_interface;

typedef struct
{
   int port;
   char *shadow;
   char pin;
} sd_cspin;

typedef struct sd_device_st
{
   struct sd_device_st *next;  // next element in linked list
   long sectors;               // # of usable 512 byte sectors on the SD card
   unsigned int pagesize;      // size (in bytes) of pages in flash device
   int pagebitshift;           // # of 'don't care' bits following page addr.
   int write_state;            // state for write timeout (used by FAT)
   unsigned long write_sector; // current sector being written (used by FAT)
   char *bptr;                 // pointer to current write source buffer
   unsigned int read_timeout_ms;   // Computed data timeout value
   unsigned int write_timeout_ms;  // Computed data timeout value
   sd_cspin cspin;             // Structure with Pin for Chip Select info
   int port;                   // Base address for the SD card's SPI port
   sd_dev_interface *SDintf;   // Pointer to sd_dev_interface structure
   SD_CSD_TYPE CSD;            // Structure for holding CSD parameters
   SD_SCR_TYPE SCR;            // Structure for holding SCR parameters
} sd_device;

typedef struct sd_cmd_reply
{
   unsigned int cmd;
   long argument;
   unsigned int reply;
   unsigned int reply_size;
   unsigned int data_size;
   char * data_buffer;
   char reply_buffer[MAX_RESPONSE_COUNT];
} SD_CMD_REPLY;

int sdspi_initDevice(int indx, sd_dev_interface *sd_dev);

const sd_dev_interface SD_dev0 = {

      // Chip select PxDR reg, pin number, control registers
       (int)SD_CS_PORT,     SD_CS_PORT_DRSHADOW,
      (char)SD_CS_PIN,
       (int)SD_CS_PORT_DDR, SD_CS_PORT_DDRSHADOW,
       (int)SD_CS_PORT_FR,  SD_CS_PORT_FRSHADOW,
       (int)SD_CS_PORT_DCR, SD_CS_PORT_DCRSHADOW,
      (char)SD_CS_PORT_OD,

      // CLK line PxDR reg, pin number, control registers
       (int)SD_CLK_PORT_DR,
      (char)SD_CLK_PIN,
       (int)SD_CLK_PORT_DDR, SD_CLK_PORT_DDRSHADOW,
       (int)SD_CLK_PORT_FR,  SD_CLK_PORT_FRSHADOW,
       (int)SD_CLK_PORT_DCR, SD_CLK_PORT_DCRSHADOW,
      (char)SD_CLK_PORT_OD,

      // Card Detect port PxDR reg, pin number, control registers
       (int)SD_CD_PORT,
      (char)SD_CD_PIN,
       (int)SD_CD_PORT_DDR, SD_CD_PORT_DDRSHADOW,
       (int)SD_CD_PORT_FR,  SD_CD_PORT_FRSHADOW,

      // Write Protect port PxDR, pin number, control registers
       (int)SD_WP_PORT,
      (char)SD_WP_PIN,
       (int)SD_WP_PORT_DDR, SD_WP_PORT_DDRSHADOW,
       (int)SD_WP_PORT_FR,  SD_WP_PORT_FRSHADOW,

      // TX port PxDR, pin number, control registers
       (int)SD_TX_PORT_DR,
      (char)SD_TX_PIN,
       (int)SD_TX_PORT_DDR, SD_TX_PORT_DDRSHADOW,
       (int)SD_TX_PORT_FR,  SD_TX_PORT_FRSHADOW,
       (int)SD_TX_PORT_DCR, SD_TX_PORT_DCRSHADOW,
      (char)SD_TX_PORT_OD,

      // RX port PxDR, pin number, control registers
       (int)SD_RX_PORT_DR,
      (char)SD_RX_PIN,
       (int)SD_RX_PORT_DDR, SD_RX_PORT_DDRSHADOW,
       (int)SD_RX_PORT_FR,  SD_RX_PORT_FRSHADOW,

      // PWR port PxDR, pin number, control registers
       (int)SD_PWR_PORT_DR,  SD_PWR_PORT_DRSHADOW,
      (char)SD_PWR_PIN,
       (int)SD_PWR_PORT_DDR, SD_PWR_PORT_DDRSHADOW,
       (int)SD_PWR_PORT_FR,  SD_PWR_PORT_FRSHADOW,
       (int)SD_PWR_PORT_DCR, SD_PWR_PORT_DCRSHADOW,
      (char)SD_PWR_PORT_OD,  SD_PWR_PORT_ON,

      // LED port PxDR, pin number, control registers
       (int)SD_LED_PORT_DR,  SD_LED_PORT_DRSHADOW,
      (char)SD_LED_PIN,
       (int)SD_LED_PORT_DDR, SD_LED_PORT_DDRSHADOW,
       (int)SD_LED_PORT_FR,  SD_LED_PORT_FRSHADOW,
       (int)SD_LED_PORT_DCR, SD_LED_PORT_DCRSHADOW,
      (char)SD_LED_PORT_OD,  SD_LED_PORT_ON,

      // Serial port SxDR, use parallel port D flag
      (char)SD_SPI_SERPORT,

      SD_SPI_SERSHADOW,
      (char)SD_SPI_SERVALUE,

      SD_SPI_SCRSHADOW,
      (char)SD_SPI_SCRVALUE,

      (char)SD_SPI_DIVREG,
      SD_SPI_DIVREGSHADOW,
      (char)SD_SPI_DIVISOR,

      (char)SD_SPI_TCREG,
      SD_SPI_TCRSHADOW,
      (char)SD_SPI_TCRVALUE
};

// Define SPI line share semaphore functions
//  as NULL if there is no sharing
#ifndef _SPI_SD_LINES_SHARED_
#define  _SPIgetSemaphore(X)  0
#define  _SPIfreeSemaphore(X) 0
#endif

sd_device SD[SDFLASH_MAX_DEVS];

/*** EndHeader */

char rx_buffer[READ_BLOCK_BUFFER_SIZE];

// for optimal ccitt crc16 calculation
#ifndef SD_CRC16_TABLE_IN_FLASH
unsigned short crc_table[256];
#else
const unsigned short crc_table[256]=
 {	0x0000,0x1021,0x2042,0x3063,0x4084,0x50A5,0x60C6,0x70E7,
	0x8108,0x9129,0xA14A,0xB16B,0xC18C,0xD1AD,0xE1CE,0xF1EF,
	0x1231,0x0210,0x3273,0x2252,0x52B5,0x4294,0x72F7,0x62D6,
	0x9339,0x8318,0xB37B,0xA35A,0xD3BD,0xC39C,0xF3FF,0xE3DE,
	0x2462,0x3443,0x0420,0x1401,0x64E6,0x74C7,0x44A4,0x5485,
	0xA56A,0xB54B,0x8528,0x9509,0xE5EE,0xF5CF,0xC5AC,0xD58D,
	0x3653,0x2672,0x1611,0x0630,0x76D7,0x66F6,0x5695,0x46B4,
	0xB75B,0xA77A,0x9719,0x8738,0xF7DF,0xE7FE,0xD79D,0xC7BC,
	0x48C4,0x58E5,0x6886,0x78A7,0x0840,0x1861,0x2802,0x3823,
	0xC9CC,0xD9ED,0xE98E,0xF9AF,0x8948,0x9969,0xA90A,0xB92B,
	0x5AF5,0x4AD4,0x7AB7,0x6A96,0x1A71,0x0A50,0x3A33,0x2A12,
	0xDBFD,0xCBDC,0xFBBF,0xEB9E,0x9B79,0x8B58,0xBB3B,0xAB1A,
	0x6CA6,0x7C87,0x4CE4,0x5CC5,0x2C22,0x3C03,0x0C60,0x1C41,
	0xEDAE,0xFD8F,0xCDEC,0xDDCD,0xAD2A,0xBD0B,0x8D68,0x9D49,
	0x7E97,0x6EB6,0x5ED5,0x4EF4,0x3E13,0x2E32,0x1E51,0x0E70,
	0xFF9F,0xEFBE,0xDFDD,0xCFFC,0xBF1B,0xAF3A,0x9F59,0x8F78,
	0x9188,0x81A9,0xB1CA,0xA1EB,0xD10C,0xC12D,0xF14E,0xE16F,
	0x1080,0x00A1,0x30C2,0x20E3,0x5004,0x4025,0x7046,0x6067,
	0x83B9,0x9398,0xA3FB,0xB3DA,0xC33D,0xD31C,0xE37F,0xF35E,
	0x02B1,0x1290,0x22F3,0x32D2,0x4235,0x5214,0x6277,0x7256,
	0xB5EA,0xA5CB,0x95A8,0x8589,0xF56E,0xE54F,0xD52C,0xC50D,
	0x34E2,0x24C3,0x14A0,0x0481,0x7466,0x6447,0x5424,0x4405,
	0xA7DB,0xB7FA,0x8799,0x97B8,0xE75F,0xF77E,0xC71D,0xD73C,
	0x26D3,0x36F2,0x0691,0x16B0,0x6657,0x7676,0x4615,0x5634,
	0xD94C,0xC96D,0xF90E,0xE92F,0x99C8,0x89E9,0xB98A,0xA9AB,
	0x5844,0x4865,0x7806,0x6827,0x18C0,0x08E1,0x3882,0x28A3,
	0xCB7D,0xDB5C,0xEB3F,0xFB1E,0x8BF9,0x9BD8,0xABBB,0xBB9A,
	0x4A75,0x5A54,0x6A37,0x7A16,0x0AF1,0x1AD0,0x2AB3,0x3A92,
	0xFD2E,0xED0F,0xDD6C,0xCD4D,0xBDAA,0xAD8B,0x9DE8,0x8DC9,
	0x7C26,0x6C07,0x5C64,0x4C45,0x3CA2,0x2C83,0x1CE0,0x0CC1,
	0xEF1F,0xFF3E,0xCF5D,0xDF7C,0xAF9B,0xBFBA,0x8FD9,0x9FF8,
	0x6E17,0x7E36,0x4E55,0x5E74,0x2E93,0x3EB2,0x0ED1,0x1EF0
  };
#endif

// Internal function to create CRC table if not included in flash
_sdflash_nodebug
unsigned short _sdspi_crc_ccitt(unsigned short crc, unsigned char c)
{
    long a;

    crc = crc ^ ((unsigned short) c << 8);

    for( a = 0; a < 8; a++ )
    {
        if( crc & 0x8000 )
            crc = (crc << 1) ^ 0x1021;
        else
            crc = crc << 1;
    }
    return crc;
}

/* START FUNCTION DESCRIPTION ********************************************
sdspi_initDevice               <SDFLASH.LIB>

SYNTAX: int sdspi_initDevice(int indx, sd_dev_interface *sd_dev)

DESCRIPTION:	Initializes the SD card pointed to by sd_dev and adds
               information about the cards interface to the SD device
               array in the position pointed to by indx.  Sets up the
               default block size of 512 bytes used by sector read/write
               functions.  This should be called before any calls to
               other sdspi functions.

PARAMETER1:		indx   - index into the SD device array to add the card.
PARAMETER2:		sd_dev - pointer to sd_dev_interface for the SD card.

RETURN VALUE:   0                 Success
               -EIO               I/O Error
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       SPI port busy

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_initDevice(int indx, sd_dev_interface *sd_dev)
{
	unsigned long t;
   int rc, status, retry;
   sd_device *sd;
#GLOBAL_INIT{
   memset(SD,0,sizeof(SD));
}
   if (indx >= SDFLASH_MAX_DEVS || sd_dev == NULL || sd_dev->txport < PCDR
        || sd_dev->txport > PEDR || (sd_dev->txport & 15) != 0) {
     return -EINVAL;
   }

   // Initialize port timer
   WrPortI(sd_dev->spdr + SD_CR_OFFSET, sd_dev->spcrShadow, sd_dev->spcrValue);
   WrPortI(sd_dev->spdr + SD_ER_OFFSET, sd_dev->sperShadow, sd_dev->sperValue);
   WrPortI(sd_dev->sptcr, sd_dev->sptcrShadow,
              *sd_dev->sptcrShadow | sd_dev->sptcrValue);
   WrPortI(sd_dev->spdivreg, sd_dev->spdivregShadow, sd_dev->divisor);

   sd = &SD[indx];
   sd->SDintf = sd_dev;
   sd->port = sd_dev->spdr;
   sd->cspin.port = sd_dev->csport;
   sd->cspin.shadow = sd_dev->csportdrShadow;
   sd->cspin.pin =  sd_dev->cspin;

   sd->write_state = 0;      // Used by FAT, just set to zero
   sd->write_sector = 0;
   // set default read/write timeouts for SDHC cards, updated 
   // for SD cards after reading CSD.
   sd->read_timeout_ms = 100;
   sd->write_timeout_ms = 250;

   // Initial disabling of Chip Select
   if(sd_dev->csport == GOCR) {
     // GOCR port requires bit 1 be set to give manual control of BUFFEN
     WrPortI(GOCR, &GOCRShadow, GOCRShadow | 2 | sd_dev->csod);
   }
   else {
     SD_DISABLECS(sd_dev);
   }

   // **** Set up chip select
   if(sd_dev->csportfr)
     BitWrPortI(sd_dev->csportfr, sd_dev->csportfrShadow,
                0, sd_dev->cspin);
   if(sd_dev->csportddr)
     BitWrPortI(sd_dev->csportddr, sd_dev->csportddrShadow,
                1, sd_dev->cspin);
   if(sd_dev->csportdcr)
     BitWrPortI(sd_dev->csportdcr, sd_dev->csportdcrShadow,
                 sd_dev->csod, sd_dev->cspin );

   if(sd_dev->pwrportfr)
      BitWrPortI(sd_dev->pwrportfr, sd_dev->pwrportfrShadow,
                1, sd_dev->pwrpin );
   if(sd_dev->pwrportddr)
      BitWrPortI(sd_dev->pwrportddr, sd_dev->pwrportddrShadow,
                1, sd_dev->pwrpin );
   if(sd_dev->pwrportdcr)
      BitWrPortI(sd_dev->pwrportdcr, sd_dev->pwrportdcrShadow,
                sd_dev->pwrod, sd_dev->pwrpin );
   if(sd_dev->pwrport)
      SD_ENABLEPOW(sd_dev);  // Turn on power if controllable by pin

   // **** Set up serial CLK line
   if(sd_dev->clkportfr)
     BitWrPortI(sd_dev->clkportfr, sd_dev->clkportfrShadow,
                1, sd_dev->clkpin );
   if(sd_dev->clkportddr)
     BitWrPortI(sd_dev->clkportddr, sd_dev->clkportddrShadow,
                1, sd_dev->clkpin );
   if(sd_dev->clkportdcr)
     BitWrPortI (sd_dev->clkportdcr, sd_dev->clkportdcrShadow,
                sd_dev->clkod, sd_dev->clkpin );

   // **** Set up card detect
   if(sd_dev->cdportfr)
     BitWrPortI(sd_dev->cdportfr, sd_dev->cdportfrShadow,
                 0, sd_dev->cdpin );
   if(sd_dev->cdportddr)
     BitWrPortI(sd_dev->cdportddr, sd_dev->cdportddrShadow,
                 0, sd_dev->cdpin );

   // **** Set up write protect
   if(sd_dev->wpportfr)
      BitWrPortI(sd_dev->wpportfr,  sd_dev->wpportfrShadow,
                0, sd_dev->wppin );
   if(sd_dev->wpportddr)
      BitWrPortI(sd_dev->wpportddr,  sd_dev->wpportddrShadow,
                0, sd_dev->wppin );

   // *** Set up serial port
	BitWrPortI(sd_dev->sptcr, sd_dev->sptcrShadow, 0, 5);
   WrPortI(sd_dev->spdivreg, sd_dev->spdivregShadow, sd_dev->divisor);

   WrPortI(sd_dev->spdr+SD_CR_OFFSET, sd_dev->spcrShadow, sd_dev->spcrValue);
   WrPortI(sd_dev->spdr+SD_ER_OFFSET, sd_dev->sperShadow, sd_dev->sperValue);

   if(sd_dev->txportfr)
      BitWrPortI(sd_dev->txportfr, sd_dev->txportfrShadow,
                1, sd_dev->txpin );
   if(sd_dev->txportddr)
      BitWrPortI(sd_dev->txportddr, sd_dev->txportddrShadow,
                1, sd_dev->txpin );
   if(sd_dev->txportdcr)
      BitWrPortI(sd_dev->txportdcr, sd_dev->txportdcrShadow,
                sd_dev->txod, sd_dev->txpin );

   if(sd_dev->rxportfr)
      BitWrPortI(sd_dev->rxportfr, sd_dev->rxportfrShadow,
                0, sd_dev->rxpin );
   if(sd_dev->rxportddr)
      BitWrPortI(sd_dev->rxportddr, sd_dev->rxportddrShadow,
                0, sd_dev->rxpin );

   if(sd_dev->ledportfr)
      BitWrPortI(sd_dev->ledportfr, sd_dev->ledportfrShadow,
                1, sd_dev->ledpin );
   if(sd_dev->ledportddr)
      BitWrPortI(sd_dev->ledportddr, sd_dev->ledportddrShadow,
                1, sd_dev->ledpin );
   if(sd_dev->ledportdcr)
      BitWrPortI(sd_dev->ledportdcr, sd_dev->ledportdcrShadow,
                sd_dev->ledod, sd_dev->ledpin );
   if(sd_dev->ledport)
      BitWrPortI(sd_dev->ledport, sd_dev->ledportdrShadow,
                sd_dev->ledon ? 0:1, sd_dev->ledpin );

   t = MS_TIMER;
   // let baud timer time out before using port
   while (MS_TIMER - t < 10) ;

   rc = 0;

#ifndef SD_CRC16_TABLE_IN_FLASH
   // Create the CCITT crc16 table to speed future CRC calculations
   for ( j = 0; j < 256; j++ ){
      crc_table[j] = _sdspi_crc_ccitt(0, (unsigned char)j );
   }
#endif

#ifdef SDFLASH_VERBOSE
   printf("%s: calling %s()\n", "sdspi_initDevice", "sdspi_reset_card");
#endif
   if(rc = sdspi_reset_card(sd))
   {
	    return rc;
   }

   // All commands following the card reset have single level retry
   // on an I/O error condition.  SD cards seem prone to these after
   // being reset.
   #define _RETRY(CMD) \
   	for (retry = 2; retry && (rc = CMD) == -EIO; --retry); if (rc) return rc;

#ifdef SDFLASH_VERBOSE
   printf("%s: calling %s()\n", "sdspi_initDevice", "sdspi_init_card");
#endif
   _RETRY(sdspi_init_card(sd))

#ifdef SDFLASH_VERBOSE
   printf("%s: calling %s()\n", "sdspi_initDevice", "sdspi_get_csd");
#endif
   _RETRY(sdspi_get_csd(sd))

#ifdef SDFLASH_VERBOSE
   printf("%s: calling %s()\n", "sdspi_initDevice", "sdspi_get_scr");
#endif
   _RETRY(sdspi_get_scr(sd))

   if (sd->CSD.R_BL_LEN != 9) {
      // try to change block length if not already 512
#ifdef SDFLASH_VERBOSE
      printf("%s: calling %s()\n", "sdspi_initDevice", "sdspi_set_block_length");
#endif
      _RETRY(sdspi_set_block_length(sd, 512))
   }
   
#ifdef SDFLASH_VERBOSE
   printf("%s: calling %s()\n", "sdspi_initDevice", "sdspi_get_status_reg");
#endif
   _RETRY(sdspi_get_status_reg(sd, &status))

   sd->next = NULL;

   return rc;
}


/*** BeginHeader sdspi_print_dev */
void sdspi_print_dev(sd_device *dev);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sdspi_print_dev                <SDFLASH.LIB>

SYNTAX: void sdspi_print_dev(sd_device *dev)

DESCRIPTION:	Prints parameters from the SD device structure.

PARAMETER2:		dev - pointer to sd_device structure of the SD card.

RETURN VALUE:  None

END DESCRIPTION **********************************************************/
_sdflash_nodebug
void sdspi_print_dev(sd_device *dev)
{
	printf("sd_device address: 0x%x\n", (unsigned int)dev );
   printf("\tnext: 0x%x\n", (unsigned int)(dev->next) );
   printf("\tsectors: %ld\n", dev->sectors);
   printf("\tpagesize: %d\n", dev->pagesize);
   printf("\tpagebitshift: %d\n", dev->pagebitshift);
   printf("\twrite_state: %d\n", dev->write_state);
   printf("\twrite_sector: %lu\n", dev->write_sector);
   printf("\tcs_pin:\n");
   printf("\t  port: 0x%x\n", dev->cspin.port);
   printf("\t  shadow: 0x%x\n", (unsigned int)(dev->cspin.shadow) );
   printf("\t  pin: 0x%x\n", dev->cspin.pin);
}

/*** BeginHeader sdspi_getSectorCount */
long sdspi_getSectorCount(sd_device *dev);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sdspi_getSectorCount                 <SDFLASH.LIB>

SYNTAX: long sdspi_getSectorCount(sd_device *dev);

DESCRIPTION:	Return number of usable 512 byte sectors on an SD card.

PARAMETER1:		dev - pointer to sd_device struct for initialized flash
						device

RETURN VALUE:  number of sectors

END DESCRIPTION **********************************************************/

_sdflash_nodebug
long sdspi_getSectorCount(sd_device *dev)
{
	return dev->sectors;
}


/*** BeginHeader sdspi_isWriting */
int sdspi_isWriting(sd_device *dev);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sdspi_isWriting                 <SDFLASH.LIB>

SYNTAX: int sdspi_isWriting(sd_device *dev)

DESCRIPTION:   Returns 1 if the SD  card is busy writing a sector

PARAMETER1:		dev - pointer to initialized sd_device structure for
						 the flash chip

RETURN VALUE:  1 busy
					0 ready, not currently writing

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_isWriting(sd_device *dev)
{
   return (sdspi_notbusy(dev->port) ? 0 : 1);
}

/*** BeginHeader sdspi_init_reply ***/
void sdspi_init_reply(SD_CMD_REPLY *reply, int command);
/*** EndHeader */
_sdflash_nodebug
void sdspi_init_reply(SD_CMD_REPLY *reply, int command)
{
    memset(reply, 0, sizeof *reply);
    
    reply->cmd = command;
    reply->reply_size = R1_BYTE_COUNT;
    reply->data_buffer = rx_buffer;
}

/*** Beginheader sdspi_reset_card ***/
int sdspi_reset_card(sd_device *sd);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_reset_card               <SDFLASH.LIB>

SYNTAX: int sdspi_reset_card(sd_device *sd)

DESCRIPTION:	Resets the SD card pointed to by sd.  Function executes
               protocol command 0 to force the card to Idle mode. This
               command is sent multiple times to reset the SD card.

PARAMETER1: sd          Pointer to sd_device structure for the SD card.

RETURN VALUE:    0                Success
               -EIO               I/O Error
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_reset_card(sd_device *sd)
{
    int result, j;
    unsigned long t;
    SD_CMD_REPLY cmd_reply;

    if (!SD_cardDetect(sd)) {
#ifdef SDFLASH_VERBOSE
    printf("%s: no SD card to reset\n", "sdspi_reset_card");
#endif
       return -ENOMEDIUM;
    }
#ifdef SDFLASH_VERBOSE
    printf("%s: attempting reset\n", "sdspi_reset_card");
#endif

    result = 0;


    // Delay before sending Idle command
    t = MS_TIMER;
    // let baud timer time out before using port
    while (MS_TIMER - t < 1) ;

    // Send Go to Idle mode command (reset)
    sdspi_init_reply(&cmd_reply, CMD0);
    
    for (j = 0; j < CMD0_RETRIES; j++)
    {
#ifdef SDFLASH_VERBOSE
      printf("*");
#endif
      if (result = sdspi_process_command(sd, &cmd_reply, 2))
      {
        if (result == -ESHAREDBUSY)
        {
          break;
        }

        if (result != -EAGAIN)
        {
#ifdef SDFLASH_VERBOSE
          printf("%s: Process command failed.\n", "sdspi_reset_card");
#endif
          break;
        }
      }
      else
      {
        if (cmd_reply.reply == R1_IDLE_STATE)
          break;
      }
    }

    if (j >= CMD0_RETRIES)
    {
#ifdef SDFLASH_VERBOSE
       printf("%s: %s() retried %d times, but could not reset SD card\n",
                "sdspi_reset_card", "sdspi_process_command", CMD0_RETRIES);
#endif
       result = -EIO;
    }

#ifdef SDFLASH_VERBOSE
        printf("\n");
#endif
    return result;
}

/*** Beginheader sdspi_sendingAP ***/
int sdspi_sendingAP(sd_device *sd);
/*** endheader ***/
#fatal "sdspi_sendingAP functionality incorporated into sdspi_process_command()"


/*** Beginheader sdspi_get_status_reg ***/
int sdspi_get_status_reg(sd_device *sd, int * status);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_get_status_reg           <SDFLASH.LIB>

SYNTAX: int sdspi_get_status_reg(sd_device *sd, int * status)

DESCRIPTION: This function is called to execute protocol command 13 to
             retrieve the status register value of the SD card.

PARAMETER1: sd       Pointer to the device structure for the SD card.
PARAMETER2: status   Pointer to variable that returns the status.

RETURN VALUE:     0               Success, Card status placed in status
               -EIO               I/O Error
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_get_status_reg(sd_device *sd, int * status)
{
    int result;
    SD_CMD_REPLY cmd_reply;

    sdspi_init_reply(&cmd_reply, CMD13);
    cmd_reply.reply_size = R2_BYTE_COUNT;

    result = sdspi_process_command(sd, &cmd_reply, 1);
    if (result == 0)
    {
        *status = cmd_reply.reply;
    }
    return result;
}


/*** BeginHeader sdspi_init_card */
int sdspi_init_card(sd_device *sd);
/*** EndHeader */
#define CMD8_VOLTAGE_SUPPLIED 0x0100  // 2.7V to 3.6V
#define CMD8_CHECK_PATTERN    0xA5

#define ACMD41_HCS_BIT        0x40000000

/* START FUNCTION DESCRIPTION ********************************************
sdspi_init_card                <SDFLASH.LIB>

SYNTAX: int sdspi_init_card(sd_device *sd)

DESCRIPTION:  Initializes the SD card pointed to by sd.  Function
              executes protocol command 1 which clears HCS bit and
              activates the cards initialization sequence.

PARAMETER1: sd          Pointer to sd_device structure for the SD card.

RETURN VALUE:     0               Success
               -EIO               I/O Error
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/
_sdflash_nodebug
int sdspi_init_card(sd_device *sd)
{
    int result, j;
    int cmd8_success;
    SD_CMD_REPLY cmd_reply;

#ifdef SDFLASH_VERBOSE
    printf("%s: attempting init\n", "sdspi_init_card");
#endif

    result = 0;
    
    sdspi_init_reply(&cmd_reply, CMD8);
    cmd_reply.argument = CMD8_VOLTAGE_SUPPLIED | CMD8_CHECK_PATTERN;
    cmd_reply.reply_size = R7_BYTE_COUNT;
    if (result = sdspi_process_command(sd, &cmd_reply, 1))
    {
        return result;
    }
    else
    {
        if (cmd_reply.reply & R1_ILLEGAL_COMMAND) {
            cmd8_success = FALSE;
        }
        else if (! (cmd_reply.reply & ~R1_IDLE_STATE)) {
            cmd8_success = (cmd_reply.reply_buffer[4] == CMD8_CHECK_PATTERN);
        }
        else  // some error bit other than ILLEGAL_COMMAND or IDLE_STATE set
        {
            return -EIO;
        }
    }
    
    for (j = 0; j < 2000; j++)
    {
#ifdef SDFLASH_VERBOSE
        printf("*");
#endif
        sdspi_init_reply(&cmd_reply, ACMD41);
#if SDFLASH_SDHC
        cmd_reply.argument = cmd8_success ? ACMD41_HCS_BIT : 0;
#else
        cmd_reply.argument = 0;
#endif
        if (result = sdspi_process_command(sd, &cmd_reply, 1))
        {
#ifdef SDFLASH_VERBOSE
            printf("%s: %s failed, error %d\n", "sdspi_init_card",
                        "sdspi_process_command", result);
#endif
            return result;
        }
        else
        {
            if (cmd_reply.reply)
            {
                if (cmd_reply.reply != R1_IDLE_STATE)
                {
#ifdef SDFLASH_VERBOSE
                    printf("%s: command response error %d\n",
                                "sdspi_init_card", cmd_reply.reply);
#endif
                    return -EIO;
                }
            }
            else
               break;
        }
    }

#ifdef SDFLASH_VERBOSE
        printf("\n");
#endif

    return result;
}


/*** BeginHeader crc16_calc */
unsigned crc16_calc(void *data, unsigned length, unsigned current);
/*** EndHeader */
// Dynamic C 10 has a shared crc16_calc().  Mimic its API for SDFLASH.LIB
// in Dynamic C 9.
_sdflash_nodebug
unsigned crc16_calc(void *data, unsigned length, unsigned current)
{
	unsigned char *bytes;
	
	bytes = data;
	while (length--) {
		current = (current << 8) ^ crc_table[(current >> 8) ^ *bytes++];
	}
	return current;
}


/*** BeginHeader mem_dump */
// Copied from Dynamic C 10.  Used for verbose debug output.
void mem_dump(void *pblock, word len);
/*** EndHeader */
_sdflash_nodebug
void mem_dump(void *pblock, word len)
{
	auto char buf[67];
   auto word i, j, k, l, m;
   auto char *block;

   block = pblock;
   i = 0;
   for (j = 0; j < len; j += 16) {
	   memset(buf, ' ', sizeof(buf)-1);
	   buf[sizeof(buf)-1] = 0;
		k = len - j;
      if (k > 16)
      	k = 16;
	   for(i = j, l = 0, m = 0; l < k; ++i, ++l, m += 3) {
	      sprintf(buf+m,"%02X", block[i]);
         buf[m+2] = ' ';
         if (block[i] >= ' ' && block[i] < 0x7F)
         	buf[50+l] = block[i];
	      if((i & 15) == 15) {
	         printf("%s\n", buf);
	      }
	   }
   }
   if (i & 15)
   	printf("%s\n", buf);
}


/*** Beginheader sdspi_process_command ***/
int sdspi_process_command(sd_device *sd, SD_CMD_REPLY * cmd_reply, int mode);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_process_command          <SDFLASH.LIB>

SYNTAX: int sdspi_process_command(sd_device *sd, SD_CMD_REPLY * cmd_reply,
                                       int mode)

DESCRIPTION: This function sends the command placed in the cmd_reply
             structure and retreives a reply and data (optional) as
             defined in the cmd_reply structure.  Pointers to TX and RX
             buffers are retreived from cmd_reply structure and used
             for command transmission and reply/data reception.  Reply
             is parsed and place in cmd_reply.reply variable.  Errors
             encountered will give a negative return value (below).

             The SPI semaphore will be obtained before the command is
             sent. The mode parameter controls whether the semaphore will
             be released after command execution and reply/data reception.
             If mode is zero, both semaphore and chip select are active
             on a successful return.  An end command sequence and release
             of the semaphore must be handled by caller.

             If mode is not zero, the semaphore will be released before
             returning. In addition, if mode is two then an SD card
             reset is in progress.  This enables the distinguishing of
             certain I/O error conditions that would normally be grouped
             with the -EIO error code and instead returns the -EAGAIN
             error code, indicating reset retries should continue.

PARAMETER1: sd           Pointer to the device structure for the SD card.
PARAMETER2: cmd_reply    Pointer to cmd_reply structure, which contains:
									cmd        - command to be executed
									argument   - arguments for the command
									reply      - storage for command reply
									reply_size - size in bytes of expected reply
									data_size  - size in bytes of expected data
									data_buffer  - pointer to RX buffer for data
									reply_buffer - reply bytes before data block
PARAMETER3: mode         Zero = SPI port semaphore should be retained.
                         One  = If SPI port to be released before return.
                         Two  = Attempting SD card reset, otherwise same as one.
                                 (Enables -EAGAIN return value)

RETURN VALUE:     0               Success
               -EIO               I/O Error
               -EAGAIN            Allowable I/O error during card reset
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_process_command(sd_device *sd, SD_CMD_REPLY * cmd_reply, int mode)
{
    static const unsigned char _cmd55[8] =
        { 0xFF, 0x77, 0x00, 0x00, 0x00, 0x00, 0x65, 0xFF };
    int rc, i, j;
    unsigned short crc7, crc16;
    unsigned char request[8];
    unsigned char r1, r2;

#ifdef SDFLASH_VERBOSE
    if (cmd_reply) {
        printf("%s: %s%u 0x%08lX\n", "sdspi_process_command",
            (cmd_reply->cmd & CMD_START) ? "ACMD" : "CMD",
            (cmd_reply->cmd & ~CMD_START), cmd_reply->argument);
    }
#endif

    if (!sd || !cmd_reply) {
#ifdef SDFLASH_VERBOSE
       printf("%s: invalid parameter.\n", "sdspi_process_command");
#endif
       return -EINVAL;
    }

    if (cmd_reply->reply_size > MAX_RESPONSE_COUNT) {
#ifdef SDFLASH_VERBOSE
       printf("%s: reply size (%u) > %u\n", "sdspi_process_command",
           cmd_reply->reply_size, MAX_RESPONSE_COUNT);
#endif
       return -EINVAL;
    }
    if (!SD_cardDetect(sd)) {
#ifdef SDFLASH_VERBOSE
       printf("%s: No SD card present.\n", "sdspi_process_command");
#endif
       return -ENOMEDIUM;
    }

    request[0] = 0xFF;
    request[1] = CMD_START | cmd_reply->cmd;
    request[2] = (char)(cmd_reply->argument>>24L);
    request[3] = (char)(cmd_reply->argument>>16L);
    request[4] = (char)(cmd_reply->argument>>8L);
    request[5] = (char)(cmd_reply->argument);
    for (crc7 = 0, i = 1; i < 6; i++)
    {
        crc7 = _sd_crc7(crc7, request[i]);
    }
    request[6] = (crc7 << 1) | CMD_END;
    request[7] = 0xFF;
    
    rc = _SPIgetSemaphore(SPI_SD);
    if (rc)
    {   // Semaphore is being held by another device, SPI port is busy
#ifdef SDFLASH_VERBOSE
        printf("%s: _SPIgetSemaphore returned %d\n", "sdspi_process_command", rc);
#endif
        return -ESHAREDBUSY;   // And return error that SPI port is busy
    }

    SD_ENABLECS(sd->SDintf);
    if (cmd_reply->cmd & CMD_START) {
        // send CMD55 prefix for ACMD
        _sdspi_write_block(_cmd55, sizeof(_cmd55), sd->port);
        _sdspi_read_block(&r1, 1, sd->port, REPLY_TIMEOUT_MS);
#ifdef SDFLASH_VERBOSE
        printf("%s:   (CMD55's R1=0x%02X)\n", "sdspi_process_command", r1);
#endif
    }
    _sdspi_write_block(request, 8, sd->port);
    rc = _sdspi_read_block(cmd_reply->reply_buffer, cmd_reply->reply_size,
        sd->port, REPLY_TIMEOUT_MS);
    if (cmd_reply->data_size && rc > 0) {
        rc = _sdspi_read_block(cmd_reply->data_buffer, cmd_reply->data_size,
            sd->port, sd->read_timeout_ms);
        if (rc > 0) {
#ifdef SDFLASH_VERBOSE
            printf("%s: read %u bytes:\n", "sdspi_process_command", rc);
            mem_dump(cmd_reply->data_buffer, rc);
#endif
            if (cmd_reply->data_buffer[0] != READ_WRITE_START_BLOCK) {
#ifdef SDFLASH_VERBOSE
                printf("%s: invalid data block start 0x%x\n",
                           "sdspi_process_command", cmd_reply->data_buffer[0]);
#endif
                return -EIO;
            }

            /* The crc16 for data block, including 2-byte CRC, should be 0. */
            crc16 = crc16_calc(&cmd_reply->data_buffer[1], rc - 1, 0);
            if (crc16) {
#ifdef SDFLASH_VERBOSE
                printf("%s: CRC16 failed 0x%04x\n", "sdspi_process_command", crc16);
#endif
                return -EIO;
            }
        }
    }
    if (mode) {
       _sdspi_end_command(sd);
       _SPIfreeSemaphore(SPI_SD);
    }
   
    if (rc < 0)
    {
#ifdef SDFLASH_VERBOSE
        printf("%s: Error %d sending command\n", "sdspi_process_command", rc);
#endif
       _sdspi_end_command(sd);
       _SPIfreeSemaphore(SPI_SD);
       return (mode == 2 ? -EAGAIN : rc);
    }

    r1 = cmd_reply->reply_buffer[0];
    if (r1 & R1_MASK_LOW_BITS) {
#ifdef SDFLASH_VERBOSE
       printf("%s: Response high bit not 0 (0x%02X)\n", "sdspi_process_command", r1);
#endif
       _sdspi_end_command(sd);
       _SPIfreeSemaphore(SPI_SD);
       return (mode == 2 ? -EAGAIN : -EIO);
    }
    
    if (cmd_reply->reply_size == 2) {
        r2 = cmd_reply->reply_buffer[1];
        cmd_reply->reply = (r1 << 8) | r2;
    } else {
        cmd_reply->reply = r1;
    }

#ifdef SDFLASH_VERBOSE
    printf("%s: reply R1 0x%x ", "sdspi_process_command", r1);
    if (r1 & R1_IDLE_STATE)           printf("IDLE ");
    if (r1 & R1_ERASE_RESET)          printf("ERASE_RST ");
    if (r1 & R1_ILLEGAL_COMMAND)      printf("ILLEGAL_CMD ");
    if (r1 & R1_CRC_ERROR)            printf("CRC_ERR ");
    if (r1 & R1_ERASE_SEQUENCE_ERROR) printf("ERASE_SEQ_ERR ");
    if (r1 & R1_ADDRESS_ERROR)        printf("ADDR_ERR ");
    if (r1 & R1_PARAMETER_ERROR)      printf("PARAM_ERR ");
    printf("\n");
    if (cmd_reply->reply_size == 2) {
        printf("%s: reply R2 0x%x ", "sdspi_process_command", r2);
        if (r2 & R2_CARD_LOCKED)             printf("CARD_LOCK ");
        if (r2 & R2_WRITE_PROTECT_ERASE)     printf("WR_PROT_ERASE ");
        if (r2 & R2_GENERAL_ERROR)           printf("GEN_ERR ");
        if (r2 & R2_CC_ERROR)                printf("CC_ERR ");
        if (r2 & R2_CARD_ECC_FAILED)         printf("CARD_LOCK ");
        if (r2 & R2_WRITE_PROTECT_VIOLATION) printf("WR_PROT_VIOL ");
        if (r2 & R2_ERASE_PARAM)             printf("ERASE_PARAM ");
        if (r2 & R2_OUT_OF_RANGE)            printf("OUT_OF_RANGE ");
        printf("\n");
    } else if (cmd_reply->reply_size > 2) {
        printf("%s: reply data:\n", "sdspi_process_command");
        mem_dump(&cmd_reply->reply_buffer[1], cmd_reply->reply_size - 1);
    }
#endif

    _SPIfreeSemaphore(SPI_SD);
    return 0;
}

/*** Beginheader _sd_crc7 ***/
unsigned short _sd_crc7(unsigned short crc7, unsigned char ch);
/*** endheader ***/

/*************************************************************************
_sd_crc7

SYNTAX: unsigned short _sd_crc7(unsigned short crc, unsigned char c)

DESCRIPTION:   This function computes the CRC7 value for a byte of data.

PARAMETER1:    crc  The accumulator for the previous CRC calculation.
PARAMETER2:    c    The byte of data to calculate the new CRC.

RETURN VALUE:  new CRC value
**************************************************************************/
_sdflash_nodebug
unsigned short _sd_crc7(unsigned short crc7, unsigned char ch)
{
    int i;

    for (i = 0; i < 8; i++)

    {
        if (ch & 0x80)
            crc7 ^= 0x40;
        ch <<= 1;
        if( crc7 & 0x40 )
            crc7 = (crc7 << 1) ^ 0x09;
        else
            crc7 = crc7 << 1;
    }
    return crc7;
}

/*** BeginHeader _sdspi_get_R2_cmd */
int _sdspi_get_R2_cmd(sd_device *sd, SD_CMD_REPLY *cmd_reply);
/*** EndHeader */
_sdflash_nodebug
int _sdspi_get_R2_cmd(sd_device *sd, SD_CMD_REPLY *cmd_reply)
{
    int result;
    int j;
    
    j = 4;
    cmd_reply->data_size = CSD_BYTE_COUNT;
    do {
    	result = sdspi_process_command(sd, cmd_reply, 1);
    } while (!result && cmd_reply->reply && --j);
    if (j == 0) {
       result = -EIO;
    }
    
    return result;
}

/*** BeginHeader sdspi_get_cid */
int sdspi_get_cid(sd_device *sd, SD_CID_TYPE *cid);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sdspi_get_cid               <SDFLASH.LIB>

SYNTAX: int sdspi_get_cid(sd_device *sd, SD_CID_TYPE *cid)

DESCRIPTION: This function is called to execute protocol command 10 to
             retrieve the SD card's Card IDenticiation (CID).  See
             sdspi_print_cid() for information on parsing that structure.

PARAMETER1: sd           The device structure for the SD card.

PARAMETER2: cid          Structure to hold the 16-byte CID

RETURN VALUE:    0                Success
               -EIO               I/O Error
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/
_sdflash_nodebug
int sdspi_get_cid(sd_device *sd, SD_CID_TYPE *cid)
{
    int result;
    SD_CMD_REPLY cmd_reply;
    
    if (cid == NULL) {
        return -EINVAL;
    }
    
    sdspi_init_reply(&cmd_reply, CMD10);
    result = _sdspi_get_R2_cmd(sd, &cmd_reply);
    if (result == 0) {
        memcpy(cid, &cmd_reply.data_buffer[1], 16);
    }
    
    return result;
}

/*** BeginHeader sdspi_print_cid */
void sdspi_print_cid(const SD_CID_TYPE *cid);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sdspi_print_cid                <SDFLASH.LIB>

SYNTAX: void sdspi_print_cid(const SD_CID_TYPE *cid)

DESCRIPTION:	Prints parameters from the SD Card IDentification register.

PARAMETER1:		cid - pointer to SD_CID_TYPE structure loaded by sdspi_get_cid().

RETURN VALUE:  None

END DESCRIPTION **********************************************************/

// byte-swapping functions copied from net.lib
root unsigned long sd_intel(unsigned long);
root unsigned short sd_intel16(unsigned short);

#asm root
sd_intel::
	ex		de,hl
	ld		e,b
	ld		d,c
	ld		b,l
	ld		c,h
	ret

sd_intel16::
	ld		a,l
	ld		l,h
	ld		h,a
	ret	
#endasm

_sdflash_nodebug
void sdspi_print_cid(const SD_CID_TYPE *cid)
{
    unsigned int mdt;
    
    mdt = sd_intel16(cid->MDT);
    printf("Manufacturer:0x%02X  OEM:'%c%c'  Product Name:'%.5s'\n",
        cid->MID, cid->OID[0], cid->OID[1], cid->PNM);
    printf("Product Rev:%X.%X  Serial #:0x%08lX  Mfg Date:%u/%u  CRC7:0x%02X\n",
        cid->PRV >> 4, cid->PRV & 0x0F, sd_intel(cid->PSN),
        mdt & 0x000F, 2000 + ((mdt >> 4) & 0x00FF), cid->CRC7);
}

/* START FUNCTION DESCRIPTION ********************************************
sdspi_get_csd               <SDFLASH.LIB>

SYNTAX: int sdspi_get_csd(sd_device *sd);

DESCRIPTION: This function is called to execute protocol command 9 to
             retrieve the SD card's Card Specific Data (CSD) and store
             it in the respective SD driver configuration object.  The
             CSD data is used to determine the SD card's physical
             storage and timing attributes.

PARAMETER1: sd           The device structure for the SD card.

RETURN VALUE:    0                Success
               -EIO               I/O Error
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/

/*** Beginheader sdspi_get_csd ***/
int sdspi_get_csd(sd_device *sd);
/*** endheader ***/

_sdflash_nodebug
int sdspi_get_csd(sd_device *sd)
{
    // mapping of TAAC values * 10
    static const unsigned char _taac_table[16] = {
       10, 10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80 };
    int result, j, k;
    char *csd_buffer;
    SD_CSD_TYPE  *sd_csd;
    unsigned short x;
    SD_CMD_REPLY cmd_reply;
    unsigned long temp, l;
    char current_byte;

    sd_csd = &sd->CSD;
    memset(sd_csd, 0x0, sizeof(SD_CSD_TYPE));

    sdspi_init_reply(&cmd_reply, CMD9);
    result = _sdspi_get_R2_cmd(sd, &cmd_reply);
    if (result != 0) {
        return result;
    }

    csd_buffer = &cmd_reply.data_buffer[1];
    /* extract the CSD information from the CSD block */
    for (k = 0; k < CSD_BYTE_COUNT - 3; k++)
    {
        current_byte = csd_buffer[k];
        switch (k)
        {
            case CSD_BLOCK_OFFSET_0:    // [127:120]
                sd_csd->CSD_STR = current_byte >> 6;
                break;

            case CSD_BLOCK_OFFSET_1:    // [119:112]
                sd_csd->TAAC = current_byte;
                break;

            case CSD_BLOCK_OFFSET_2:    // [111:104]
                sd_csd->NSAC = current_byte;
#if SDFLASH_SDHC
                if (! CSD_IS_SDHC(sd_csd))
#endif
                {
                    // Calculate timeout in ms
                    x = _taac_table[(sd_csd->TAAC >> 3) & 0xF];
                    // x has value times 10 (correct value for j == 7)
                    for (j = sd_csd->TAAC & 7; x && (j != 7); ++j) {
                        x /= 10;
                    }
                    // Calculate NSAC timeout on conservative 1Mhz clock
                    // NSAC * 100 clocks / 1,000 clocks/msec = NSAC / 10
                    x += sd_csd->NSAC / 10;
                    
                    // minimum timeout of 2ms
                    sd->read_timeout_ms = x < 2 ? 2 : x;
#ifdef SDFLASH_VERBOSE
                    printf("%s: TAAC=0x%02x  NSAC=%u\n", "sdspi_get_csd",
                           sd_csd->TAAC, sd_csd->NSAC);
                    printf("%s: set %s to %u\n", "sdspi_get_csd",
                           "read_timeout_ms", sd->read_timeout_ms);
#endif
                }
                break;

            case CSD_BLOCK_OFFSET_3:    // [103:96]
                sd_csd->TRANSPEED = current_byte;
                break;

            case CSD_BLOCK_OFFSET_4:    // [95:88]
                sd_csd->CCC = current_byte << 4;
                break;

            case CSD_BLOCK_OFFSET_5:    // [87:80]
                sd_csd->CCC |= current_byte >> 4;
                sd_csd->R_BL_LEN = current_byte & 0x0F;
                break;

            case CSD_BLOCK_OFFSET_6:    // [79:72]
                sd_csd->DSR_IMP = (current_byte >> 4) & 0x01;
                sd_csd->CSIZE = (current_byte & 0x3) << 8;
                break;

            case CSD_BLOCK_OFFSET_7:    // [71:64]
                sd_csd->CSIZE |= current_byte;
                sd_csd->CSIZE <<= 2;
                break;

            case CSD_BLOCK_OFFSET_8:    // [63:56]
#if SDFLASH_SDHC
                if (CSD_IS_SDHC(sd_csd)) {
                    sd_csd->CSIZE = current_byte << 8;
                } else
#endif
                {
                    sd_csd->CSIZE |= current_byte >> 6;
                }
                break;

            case CSD_BLOCK_OFFSET_9:    // [55:48]
#if SDFLASH_SDHC
                if (CSD_IS_SDHC(sd_csd)) {
                    sd_csd->CSIZE |= current_byte;
                } else
#endif
                {
                    sd_csd->C_SIZE_M = (current_byte & 0x3) << 1;
                }
                break;

            case CSD_BLOCK_OFFSET_10:   // [47:40]
#if SDFLASH_SDHC
                if (CSD_IS_SDHC(sd_csd)) {
                    sd->sectors = (sd_csd->CSIZE + 1L) << 10;
                } else
#endif
                {
                    sd_csd->C_SIZE_M |= (current_byte >> 7) & 0x1;
                    // Compute the number of 512 byte sectors on the SD card
                    // shift C_SIZE_M + 2 and R_BL_LEN - 9
                    sd->sectors = (sd_csd->CSIZE + 1L) <<
                                  (sd_csd->C_SIZE_M + sd_csd->R_BL_LEN - 7);
                }
                sd_csd->ERASE_BLK_EN = (current_byte >> 6) & 0x1;
                break;

            case CSD_BLOCK_OFFSET_11:   // [39:32]
                break;

            case CSD_BLOCK_OFFSET_12:   // [31:24]
                sd_csd->R2W_FACT = (current_byte >> 2) & 0x07;
                sd_csd->WR_BL_LEN = (current_byte & 0x3) << 2;
#if SDFLASH_SDHC
                if (! CSD_IS_SDHC(sd_csd))
#endif
                {
                    sd->write_timeout_ms = sd->read_timeout_ms * (1 << sd_csd->R2W_FACT);
#ifdef SDFLASH_VERBOSE
                    printf("%s: R2W_FACT=%u (%u)\n", "sdspi_get_csd",
                           sd_csd->R2W_FACT, (1 << sd_csd->R2W_FACT));
                    printf("%s: set %s to %u\n", "sdspi_get_csd",
                           "write_timeout_ms", sd->write_timeout_ms);
#endif
                }
                break;

            case CSD_BLOCK_OFFSET_13:   // [23:16]
  		          sd_csd->WR_BL_LEN |= (current_byte >> 6) & 0x03;
		          sd_csd->WR_BL_PAR = (current_byte >> 5) & 0x01;
                sd->pagebitshift = (int)(sd_csd->WR_BL_LEN);
                sd->pagesize  = (int)(1L << sd_csd->WR_BL_LEN);
                break;

            case CSD_BLOCK_OFFSET_14:   // [15:8]
		          sd_csd->COPY = (current_byte >> 6) & 0x01;
		          sd_csd->P_WR_PROT = (current_byte >> 5) & 0x01;
		          sd_csd->T_WR_PROT = (current_byte >> 4) & 0x01;
                break;

            case CSD_BLOCK_OFFSET_15:   // [7:0]
                sd_csd->CRC7 = current_byte >> 1;
                break;
        }
    }
    sd_csd->init_ok = TRUE;

    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
sdspi_get_scr               <SDFLASH.LIB>

SYNTAX: int sdspi_get_scr(sd_device *sd);

DESCRIPTION: This function executes application specific command 51 to
             retrieve the SD card's Configuration Register (SCR) and
             store it in the respective SD driver configuration object.
             The SCR data is used to identify the SD card's physical
             interface version and security version.  It also contains
             erase state (all 0's or 1's) and supported bus widths.

PARAMETER1: sd           The device structure for the SD card.

RETURN VALUE:     0               Success
               -EIO               I/O Error
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/
/*** Beginheader sdspi_get_scr ***/
int sdspi_get_scr(sd_device *sd);
/*** endheader ***/

_sdflash_nodebug
int sdspi_get_scr(sd_device *sd)
{
    int result, k;
    char *scr_buffer;
    SD_SCR_TYPE  *sd_scr;
    SD_CMD_REPLY cmd_reply;

    sd_scr = &sd->SCR;
    memset(sd_scr, 0x0, sizeof(SD_SCR_TYPE));

    sdspi_init_reply(&cmd_reply, ACMD51);
    cmd_reply.data_size = SCR_BYTE_COUNT;
    result = sdspi_process_command(sd, &cmd_reply, 1);
    
    if (result)
    {
        return result;
    }
    else if (cmd_reply.reply)
    {
#ifdef SDFLASH_VERBOSE
        printf("%s: CRC mismatch error\n", "sdspi_get_scr");
#endif
        return -EIO;
    }

    scr_buffer = &cmd_reply.data_buffer[1];
    /* extract the SCR information from the data block */
    for (k = 0; k < SCR_BYTE_COUNT - 3; k++)
    {
        switch (k)
        {
            case SCR_BLOCK_OFFSET_0:
                sd_scr->SCR_STRUCTURE = (scr_buffer[k]>>4) & 0x0f;
                sd_scr->SD_SPEC = scr_buffer[k] & 0x0f;
                break;

            case SCR_BLOCK_OFFSET_1:
                sd_scr->DATA_STAT_AFTER_ERASE = (scr_buffer[k] & 0x80)>>7;
                // Fill out all bits for convenience
                if(sd_scr->DATA_STAT_AFTER_ERASE)
                    sd_scr->DATA_STAT_AFTER_ERASE = 0xff;
                sd_scr->SD_SECURITY = ((scr_buffer[k]&0x70)>>4) & 0x07;
                sd_scr->SD_BUS_WIDTHS = scr_buffer[k] & 0x0f;
                break;
        }
    }
    sd_scr->init_ok = TRUE;

    return result;
}


/*** Beginheader sdspi_read_sector ***/
int sdspi_read_sector(sd_device *sd, unsigned long sector_number,
                             void * data_buffer);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_read_sector             <SDFLASH.LIB>

SYNTAX: int sdspi_read_sector(sd_device *sd, unsigned long sector_number,
                                    void * data_buffer)

DESCRIPTION: This function is called to execute protocol command 17 to
             read a 512 byte block of data from the SD card.

PARAMETER1: sd             The device structure for the SD card.
PARAMETER2: sector_number  The sector number to read.
PARAMETER3: data_buffer    Pointer to a buffer for the 512 bytes read

RETURN VALUE:    0                Success
               -EIO               I/O Error
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_read_sector(sd_device *sd, unsigned long sector_number,
                             void * data_buffer)
{
    int result;
    SD_CMD_REPLY cmd_reply;

    SD_DISABLECS(sd->SDintf);

    sdspi_init_reply(&cmd_reply, CMD17);
#if SDFLASH_SDHC
    if (SD_IS_SDHC(sd)) {
        cmd_reply.argument = sector_number;
    } else
#endif
    {
        cmd_reply.argument = sector_number * BLOCK_SIZE;
    }
    cmd_reply.data_size = DATA_BLOCK_SIZE;

    if (result = sdspi_process_command(sd, &cmd_reply, 1))
    {
#ifdef SDFLASH_VERBOSE
       printf("%s: %s() failed, error %d\n",
                 "sdspi_read_sector", "sdspi_process_command", result);
#endif
       return result;
    }
    else
    {
        if (cmd_reply.reply)
        {
#ifdef SDFLASH_VERBOSE
            printf("%s: command response error, reply=%02x\n",
                      "sdspi_read_sector", cmd_reply.reply);
#endif
            return -EIO;
        }
    }

    memcpy(data_buffer, &cmd_reply.data_buffer[1], BLOCK_SIZE);

    return 0;
}


/*** Beginheader sdspi_write_sector ***/
int sdspi_write_sector(sd_device *sd, unsigned long sector_number,
                           char * data_buffer);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_write_sector            <SDFLASH.LIB>

SYNTAX: int sdspi_write_sector(sd_device *sd, unsigned long sector_number,
                                char * data_buffer)

DESCRIPTION: This function is called to execute protocol command 24 to
             write a 512 byte block of data to the SD card.

PARAMETER1: sd            The device structure for the SD card.
PARAMETER2: sector_number The sector number to write.
PARAMETER3: data_buffer   Pointer to a buffer of 512 bytes to write.

RETURN VALUE:     0             Success
               -EIO             I/O Error
               -EACCES          Write protected block, no write access
               -EINVAL          Invalid parameter given
               -ENOMEDIUM       No SD card in socket
               -ESHAREDBUSY     Shared SPI port busy
               -EBUSY           SD card is busy with write operation,
                                call sdspi_WriteContinue to complete
                                (Only when SD_NON_BLOCK is defined)

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_write_sector(sd_device *sd, unsigned long  sector_number,
                             char * data_buffer)
{
    int result, j, k, status;
    char * read_data_ptr;
    unsigned short crc16;
    unsigned count;
    char scount;
    SD_CMD_REPLY cmd_reply;

    result = 0;
    read_data_ptr = NULL;

    sdspi_init_reply(&cmd_reply, CMD24);
#if SDFLASH_SDHC
    if (SD_IS_SDHC(sd)) {
        cmd_reply.argument = sector_number;
    } else
#endif
    {
        cmd_reply.argument = sector_number * BLOCK_SIZE;
    }

    if (result = sdspi_process_command(sd, &cmd_reply,0))
    {
#ifdef SDFLASH_VERBOSE
        printf("%s: process command failed.\n", "sdspi_write_sector");
#endif
        _sdspi_end_command(sd);
        _SPIfreeSemaphore(SPI_SD);
        return result;
    }
    else
    {
        if (cmd_reply.reply)
        {
#ifdef SDFLASH_VERBOSE
            printf("%s: command response error (%d).\n",
                      "sdspi_write_sector", cmd_reply.reply);
#endif
            _sdspi_end_command(sd);
            _SPIfreeSemaphore(SPI_SD);
            return -EIO;
        }
    }

    // re-use rx_buffer for our write block
    rx_buffer[0] = READ_WRITE_START_BLOCK;

    // Copy data_buffer to rx_buffer and calculate crc
    memcpy( &rx_buffer[1], data_buffer, 512);
    crc16 = crc16_calc( data_buffer, 512, 0);

    // Last bit of CRC must be set or we get CRC error back from the card
    rx_buffer[514] = (char)crc16 | 1 ;		// LSB | 0x01
    rx_buffer[513] = (char)(crc16>>8);		// MSB

    _sdspi_write_block(rx_buffer, 515, sd->port);
    result = _sdspi_read_block(rx_buffer, 1, sd->port, sd->write_timeout_ms);

    if (result == 1) {
	    rx_buffer[0] |= 0xE0;      // Set don't care bits high for comparing
	    if(rx_buffer[0]==0xEB) {
#ifdef SDFLASH_VERBOSE
           printf("%s: CRC mismatch error.\n", "sdspi_write_sector");
#endif
   	     result = -EIO;
       }
	    else if(rx_buffer[0]==0xED) {
#ifdef SDFLASH_VERBOSE
           printf("%s: Write data error.\n", "sdspi_write_sector");
#endif
   	     result = -EIO;
       }
	    else if(rx_buffer[0]!=0xE5) {
#ifdef SDFLASH_VERBOSE
           printf("%s: Invalid command response error.\n", "sdspi_write_sector");
#endif
   	     result = -EIO;
       }
    }

    if (result < 0) {
       _sdspi_end_command(sd);
       sdspi_get_status_reg(sd, &status);   // Read status to clear the card
       _SPIfreeSemaphore(SPI_SD);
       return result;
    }

#ifdef SD_NON_BLOCK
	 return -EBUSY;
#else
    // Implement timeout for busy response from SD card
    for (count = BUSY_RETRIES; !sdspi_notbusy(sd->port) && count; count--);

    SD_DISABLECS(sd->SDintf);
    SD_ENABLECS(sd->SDintf);
    _sdspi_end_command(sd);
    sd->write_state = 0;
    _SPIfreeSemaphore(SPI_SD);

    if(!count) {
#ifdef SDFLASH_VERBOSE
        printf("%s: Busy response timeout.\n", "sdspi_write_sector");
#endif
        result = -EIO;
    }
    else {
       result = sdspi_get_status_reg(sd, &status);
       if (!result && status) {
          if (status & 0x0023) {
#ifdef SDFLASH_VERBOSE
             printf("%s(%ld): Write protected, access denied.\n",
                            "sdspi_write_sector", sector_number);
#endif
             result = -EACCES;
          }
          else {
#ifdef SDFLASH_VERBOSE
             printf("%s: Write operation failed (0x%04x).\n",
                            "sdspi_write_sector", status);
#endif
             result = -EIO;
          }
       }
    }

    return result;
#endif
}



/*** Beginheader sdspi_WriteContinue ***/
int sdspi_WriteContinue(sd_device *sd);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_WriteContinue         <SDFLASH.LIB>

SYNTAX: int sdspi_WriteContinue(sd_device *sd)

DESCRIPTION: This function completes the previously started write
             command to the SD card when Non-Blocking mode is enabled.
             It looks for the end of the busy signal from the card,
             then strobes the chip select.  This function should be
             called repeatedly until the -EBUSY code is not returned,
             at which point the SPI port is freed.  There is a timeout
             mechanism for the busy signal.  If exceeded, the port is
             freed and the -EIO error code is returned.

PARAMETER1:  sd      The device structure for the SD card.

RETURN VALUE:     0             Success
               -EIO             I/O Error or Timeout
               -EBUSY           SD card is busy with write operation,
                                call sdspi_WriteContinue again

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_WriteContinue(sd_device *sd)
{
    int count, result, status;

    // Wait for write operation to complete
    if (sdspi_notbusy(sd->port)) {
	    SD_DISABLECS(sd->SDintf);
	    SD_ENABLECS(sd->SDintf);
	    _sdspi_end_command(sd);
       sd->write_state = 0;
	    _SPIfreeSemaphore(SPI_SD);

       // Check status response from SD card
       result = sdspi_get_status_reg(sd, &status);
       if (!result && status) {
#ifdef SDFLASH_VERBOSE
          printf("%s: Write operation failed (0x%04x).\n",
                            "sdspi_WriteContinue", status);
#endif
          result = -EIO;
       }
    }
    else {  // SD card still busy, increment write_state as timeout
       if (++sd->write_state > BUSY_RETRIES) {
	    SD_DISABLECS(sd->SDintf);
       sd->write_state = 0;
	    _SPIfreeSemaphore(SPI_SD);
#ifdef SDFLASH_VERBOSE
          printf("%s: Write busy timeout.\n", "sdspi_WriteContinue");
#endif
          result = -EIO;
       }
       else {
          result = -EBUSY;
       }
    }

    return result;
}

/*** Beginheader sdspi_set_block_length ***/
int sdspi_set_block_length(sd_device *sd, int block_length);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_set_block_length         <SDFLASH.LIB>

SYNTAX: int sdspi_set_block_length(sd_device *sd, int block_length)

DESCRIPTION: This function executes protocol command 16 to set the block
             length for the SD card.  The default block length for
             SD cards is 512 bytes.  Please note that sdspi_write_sector
             and sdspi_read_sector work on 512 byte blocks only.  If you
             change the block size, these functions will need to be
             modified, or you will need to execute commands directly
             through sdspi_process_command and internal write block and
             read block functions.

PARAMETER1: sd             The device structure for the SD card.
PARAMETER2: block_length   The block size in bytes for the SD card.

RETURN VALUE:     0               Success
               -EIO               I/O Error
               -EINVAL            Invalid parameter given
               -ENOMEDIUM         No SD card in socket
               -ESHAREDBUSY       Shared SPI port busy

END DESCRIPTION **********************************************************/

_sdflash_nodebug
int sdspi_set_block_length(sd_device *sd, int block_length)
{
    int result;
    SD_CMD_REPLY cmd_reply;

    result = 0;

    sdspi_init_reply(&cmd_reply, CMD16);
    cmd_reply.argument = (long)block_length;

#ifdef SDFLASH_VERBOSE
    printf("%s: calling %s\n", "sdspi_set_block_length", "sdspi_process_command");
#endif
    if (result = sdspi_process_command(sd, &cmd_reply, 1))
    {
       return result;
    }
    else
    {
        if (cmd_reply.reply)
        {
#ifdef SDFLASH_VERBOSE
            printf("%s: command response error (%d)\n", "sdspi_set_block_length",
                      cmd_reply.reply);
#endif
            result = -EIO;
        }
    }

    return result;
}

/*** Beginheader sdspi_debounce ***/
int sdspi_debounce(sd_device *sd);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_debounce                <SDFLASH.LIB>

SYNTAX: int sdspi_debounce(sd_device *sd)

DESCRIPTION: This function waits for and debounces the card insertion
             switch.  When it returns True(1), then a card is fully
             inserted.

PARAMETER1:   sd       The device structure for the SD card.

RETURN VALUE:    1     Success, Card Fully Inserted
                 0     No Card Present

END DESCRIPTION **********************************************************/
_sdflash_nodebug
int sdspi_debounce(sd_device *sd){
  int i, j;

  for (j = 0; j < 20; j++) {
    for (i = 0; !SD_cardDetect(sd) && i<500; i++);
    if (i == 500) return 0;
    for(i = 0; SD_cardDetect(sd) && i<500; i++);
    if (i == 500) return 1;
  }
  return 0;
}


/*** Beginheader sdspi_setLED ***/
void sdspi_setLED(sd_device *sd, char state);
/*** endheader ***/

/* START FUNCTION DESCRIPTION ********************************************
sdspi_setLED                  <SDFLASH.LIB>

SYNTAX: void sdspi_setLED(sd_device *sd, char state)

DESCRIPTION: This function sets the LED for the given SD card based
             on state.  If state is 0, the LED is turned off. If state
             is not zero, the LED is turned on.

             Note that not all core modules have an SD card active LED.
             If a LED has been added on the host board for this purpose,
             this function can be enabled by editing SD_LED_... defines
             at the start of this library to describe the port control.

PARAMETER1: sd        The device structure for the SD card.
PARAMETER2: state     The state to set the LED to:
                            0 = Off & Non-zero = On

RETURN VALUE:    NONE

END DESCRIPTION **********************************************************/
_sdflash_nodebug
void sdspi_setLED(sd_device *sd, char state)
{
   // If LED port defined, set LED to 'state'
   if (sd->SDintf->ledport) {
     BitWrPortI(sd->SDintf->ledport, sd->SDintf->ledportdrShadow,
                (state ? 1 : 0), sd->SDintf->ledpin);
   }
   return;
}


/*** Beginheader sdspi_notbusy ***/
root int sdspi_notbusy(int port);
/*** endheader ***/
/* START FUNCTION DESCRIPTION ********************************************
sdspi_notbusy                 <SDFLASH.LIB>

SYNTAX: int sdspi_notbusy(int port)

DESCRIPTION: This function tests for a busy status from the SD card
             on the port given.  It is assumed that the card is already
             enabled.

PARAMETER1: port      The base address for the SD card's SPI port

RETURN VALUE:    1    The card is not busy, write/erase has ended
                 0    The card is busy, write/erase in progress
END DESCRIPTION **********************************************************/
#asm
sdspi_notbusy::
; set up the registers
    ld   iy, hl
     ; look at up to 32 bytes for end of busy
    ld   b,32
    ld   h,0   ; for return and for testing
BZLoop:
     ; set up RX control value
    ld	a, SD_SPI_CONTROL_VALUE | SD_SPI_RXMASK
ioi ld	(iy + SD_CR_OFFSET), a		; load RX control value - receive the byte

; wait for the receiver to complete
BZWait:
ioi bit  7,(iy + SD_SR_OFFSET)      ; test receiver bit
	 jr	z, BZWait		    	      ; jump if not done yet

    ; get the byte, zero if busy
  	 ioi	ld		L, (iy)	   	      ; get the byte
    bool hl                         ; see if SD card is busy
    jr   nz,BZret                   ; if not busy, jump to exit
    djnz BZLoop                     ; if busy, loop back on repeat counter
BZret:
    ret
#endasm


/*** Beginheader _sdspi_end_command ***/
void _sdspi_end_command(sd_device *sd);
/*** endheader ***/

/*************************************************************************
SYNTAX: void _sdspi_end_command(sd_device *sd)

DESCRIPTION:   Performs an end of command sequence - disabling the chip
					select and clocking out a high line character.  This
					finishes the command and puts the SD output in hi-Z mode.
               Does not get or release the semaphore.

PARAMETER1:		sd - Pointer to an SD device structure
PARAMETER2:		len - number of bytes to transmit ( maximum 64K)
PARAMETER3:		port - Base address of the SPI serial port to use
**************************************************************************/
_sdflash_nodebug
void _sdspi_end_command(sd_device *sd)
{
   SD_DISABLECS(sd->SDintf);
   _sdspi_write_block("\xFF", 1, sd->port);
}


/*** Beginheader _sdspi_write_block ***/
root void _sdspi_write_block(char *buffer, unsigned int len, int port);
/*** endheader ***/

/*************************************************************************
_sdspi_write_block

SYNTAX: void _sdspi_write_block(char *buffer, unsigned int len, int port)

DESCRIPTION:   Transmits a block of data over the SPI port. This
					function blocks until the tranmission completes.
               Chip select and semaphores must be handled before
               calling this function, it only performs a card write.

PARAMETER1:		buffer - An array of bytes to transmit
PARAMETER2:		len - number of bytes to transmit ( maximum 64K)
PARAMETER3:		port - Base address of the SPI serial port to use

**************************************************************************/
_sdflash_nodebug
void _sdspi_write_block(char *buffer, unsigned int len, int port)
{

#asm
; set up the registers
      ex     de,hl            ; save src in de
      ld     de', BitRevTable ; use de' to reverse bytes when written
		ld		 hl, (sp+@SP+len)	; get the number of bytes
      ld     c,L
      ld     b,H
      ld     iy, (sp+@SP+port)
;	de = destination address
;	bc = byte count
;  iy =  serial port register base (SxDR)

_SPIWriteA0:
		ld		a, (de)				; get a byte
      ; reverse bit order before sending  a = BitRevTable[a]
      exx
      bool  hl
      ld    L, a
      add   hl, de
      ld    a, (hl)
      exx		
ioi	ld		(iy), a	      	; 	load it

		ld		a, SD_SPI_CONTROL_VALUE | SD_SPI_TXMASK
ioi	ld		(iy + SD_CR_OFFSET), a		; load TX control value - send the byte

; wait for the buffer to be available
_Tx00:
ioi   bit   2,(iy + SD_SR_OFFSET)  ; test trans bit
		jr		nz, _Tx00		   	  ; jump if not done yet
		inc	de						     ; point to next byte
		dec	bc						     ; update bytes remaining
      ld    a,c
      or    b
		jr		nz, _SPIWriteA0		  ; jump if not done
#endasm
	return;
}


/*** Beginheader _sdspi_read_block ***/
root int _sdspi_read_block(char *buffer, unsigned int len, int port,
                                   unsigned int timeout_ms);
/*** endheader ***/

/*************************************************************************
_sdspi_read_block

SYNTAX: int _sdspi_read_block(char *buffer, unsigned int len, int port,
                                     unsigned int timeout_ms)

DESCRIPTION:   Reads in len bytes of data (ignoring high line sequence)
               from the SPI port into a buffer.  Timeout is based on the
               current SPI clock rate and is given in number of bytes
               allowed to be in high line condition before data starts.
               Chip select and semaphores must be handled before
               calling this function, it only performs a card read.

PARAMETER1:		buffer - buffer for reply and received bytes
PARAMETER2:		len - number of bytes to receive (after high line condition)
PARAMETER3:		port - Base address of the SPI serial port to use
PARAMETER4:    timeout - number of milliseconds before timeout

RETURN VALUE:  number of bytes received (if positive)
               -EIO = Response Timeout occured

**************************************************************************/
_sdflash_nodebug
root int _sdspi_read_block(char *buffer, unsigned int len, int port,
                                  unsigned int timeout_ms)
{
#asm
; set up the registers
         ex     de, hl                    ; save dest in de
         ld     hl, (sp+@SP+timeout_ms) 	; get timeout count
         ld     bc, (MS_TIMER) 				; ...add it to low half of MS_TIMER
         scf                              ; set carry flag for additional 1ms
         adc    hl, bc
         ld     c,L
         ld     b,H                       ; BC = timeout 16-bit MS_TIMER value
         ld     iy, (sp+@SP+port)
; receive the reply/data bytes
;	de = destination address
;  bc = timeout value
;  iy = serial port register base (SxDR)

; High line condition loop
_Rx0Loop:
         ; set up RX control value
			ld		a, SD_SPI_CONTROL_VALUE | SD_SPI_RXMASK
	ioi	ld		(iy + SD_CR_OFFSET), a ; load RX control value - receive the byte

; wait for the receiver to complete
_Rx0Wait:
   ioi   bit   7,(iy + SD_SR_OFFSET)     ; test receiver bit
			jr		z, _Rx0Wait			; jump if not done yet

	ioi	ld		a, (iy)	   	; get the byte
         cp    0xFF           ; Compare to high line condition
         jr    nz, _RxGetData ; If not, then go get reply/data

         ; if (MS_TIMER - target >= 0), timeout occurred
         ld    hl, (MS_TIMER)
         xor   a              ; clear carry
         sbc   hl, bc         ; calculate MS_TIMER - target
         bit   7, h           ; if result is non-negative we timed out
         jr    nz,_Rx0Loop    ; Loop back if not expired
         
         ld    a, 0xFF        ; Timeout occurred
         ld    (de), a        ; Save FF byte to indicate timeout
         jr    _Rx0Exit       ; And exit

_RxGetData:
         ld    de', BitRevTable   ; use de' to reverse bytes as read
   		ld		hl, (sp+@SP+len)	 ; get the number of bytes to receive
         ld    c,L
         ld    b,H                ; Replace timeout count with byte count
         jr    _RxSaveByte        ; Save the byte and get the rest

; Data or reply reception loop
_Rx1Loop:
         ; set up RX control value
			ld		a, SD_SPI_CONTROL_VALUE | SD_SPI_RXMASK
	ioi	ld		(iy + SD_CR_OFFSET), a ; load RX control value - receive the byte

; wait for the receiver to complete
_Rx1Wait:
   ioi   bit   7,(iy + SD_SR_OFFSET)     ; test receiver bit
			jr		z, _Rx1Wait			; jump if not done yet

	ioi	ld		a, (iy)	   	; get the byte
_RxSaveByte:
	      ; reverse bit order before storing  (de) = BitRevTable[a]
	      exx
	      bool  hl
	      ld    L, a
	      add   hl, de
	      ld    a, (hl)
	      exx
		   ld		(de), a 	 		; store the byte
		   inc	de			 		; point to next byte
	    	dec	bc			 		; decrement bytes remaining to receive
		   ld    a,b
         or    c             	; check if done: z=1 if done
		   jr		nz, _Rx1Loop 	; jump if not done
_Rx0Exit:
#endasm
   return *buffer == 0xFF ? -EIO : len;
}

/*** BeginHeader */
#endif	// __SDFLASH_LIB__
/*** EndHeader */


