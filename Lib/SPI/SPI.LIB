/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION **************************************************
SPI.LIB 2.16

This library contains several functions which allow connection to an
SPI device via either a serial or a parallel interface.  It is the
responsibility of the caller to activate whatever Chip Select signal
which may be necessary.

This library is NOT interrupt driven.  It is strictly a polled operation.
The functions block until the requested operation is complete.

Modification list
 27-Apr-2005 JLC	2.16 implement macro to disable bit reversing: SPI_NOREV
 10-Mar-2004 EK   2.15 moved SPIdivisor variable from global init block
                       since SBC's set value for SPIdivisor in brdInit
  6-Jan-2004 JLC	2.14 add variable SPIdivisor for bit rate divisor
  5-Nov-2003 JLC	2.13 allow use of global RevBitTable
  5-May-2003 JLC	2.12 added #define R3000
 10-Apr-2003 JLC	2.11 added master flow control via SPI_MASTER_CS using
 									same bit as Chip Select from master
									added comments for "bit banging"
									use SPITXxor in SPIWrRd when "bit banging"
  7-Mar-2003 JLC	2.10 update TxRx operation for R3000 transceive operation
									fixed some comments for SPIRead and SPIWrite
  9-Jan-2003 JLC	2.09 fixed error in SPITxRx: incorrectly referenced SBCR
 10-Dec-2002 JLC	2.08 fixed dummy read in SPIinit
 26-Nov-2002 JLC	2.07 rename function swap to spi_swap to avoid global name conflict
									and insert into SPIinit header
									correct #define SPI_USE_PD4
 28-Oct-2002 JLC	2.06 corrected SPIinit to initialize PFFR for serial ports C and D
 25-Oct-2002 JLC	2.05 added SPI_USE_PD4 macro for use on devices which Dynamic C
									automatically defines SERB_USEPORTD
 16-Oct-2002 JLC	2.04 corrected bug for SPI_SLAVE_RDY_SHADOW references
 15-Aug-2002 JLC	2.03 save and restore IX for co-states/co-functions
 17-Jul-2002 JLC	2.02 added SPI_SLAVE_RDY_PORT detection for master
 16-Jul-2002 JLC	2.01 added version and SPI_SLAVE_HIGH_TRUE
 11-Jul-2002 JLC	modified SPIWrite (serial ports only) to decrease delay
 							between bytes
 10-Jun-2002 JLC	added SPI slave capability for serial ports only - see SPI_SLAVE
 							Added ability of SLAVE to signal master when a byte is ready
 							to be received or transmitted - see SPI_SLAVE_RDY macros
 							Added SLAVE_CS input for SPIRead and SPIWrRd
 							Made SPIWrRd an "int" function
 30-May-2002 JLC	added serial ports C and D and SPI_CLOCK_MODE for Rabbit 3000
 14-Apr-2002 jmh	added SPIWrRd for SPI_MODE_PARALLEL
				 JLC	Moved initialization of SPIxor & SPITXxor to GLOBAL_INIT section
  8-Jan-2002 JLC	added SPIWrRd for serial port interface only
 						added warning for SPI_CLK_DIVISOR < 5
  6-Dec-2001 JLC	These are for the parallel interface:
 						added SPITXxor value to enable inverting transmitted bits
 						added macro SPI_INVERT_CLOCK
 13-Sep-2001 JLC	added conditional SERB_USEPORTD to allow alternate serial port B
						SPIRead: read the input buffer to remove any "junk" before sending
							the clock
						SPIinit: Remove initialization of GOCR

The following is a description of the values which the user may define
BEFORE the #use SPI.lib statement:

(1) Interface (default is SPI_SER_B)
	SPI_SER_A			use serial port A
	SPI_SER_B			use serial port B
	SPI_SER_C			use serial port C (R3000 only)
	SPI_SER_D			use serial port D (R3000 only)
	SPI_CLOCK_MODE		clock and data phase (R3000 only)
	SERB_USEPORTD		define this to use the alternate serial port B pins

	SPI_SLAVE			defines the Rabbit as a slave device

		This signal is generated by the Slave to tell the
      Master that the slave is ready.  It is used for
      handshaking between each byte.
	SPI_SLAVE_RDY_PORT	defines the port for SLAVE_RDY signal
	SPI_SLAVE_RDY_SHADOW defines the shadow register for SPI_SLAVE_RDY_PORT
	SPI_SLAVE_RDY_BIT	defines the bit for the SLAVE_RDY signal

		This signal is read by the slave and is used by it
      to determine that it has been enabled by the Master.
	SPI_SLAVE_CS_REG	defines the register for the incoming CS signal
	SPI_SLAVE_CS_BIT	defines the bit for the incoming CS signal - Low True
	SPI_SLAVE_HIGH_TRUE define if high true chip select is desired

		This signal is generated by the Master.
		The user is responsible for setting/clearing this
      bit before/after every transaction.
      MASTER OPERATION: If SPI_MASTER_CS_PORT is defined it
      will be toggled during the data transfer.  The value of
      SPI_SLAVE_HIGH_TRUE is used to determine the true state.
      SLAVE OPERATION: If SPI_MASTER_CS_PORT is defined the
      slave receive function will use the CS input for
      handshaking between each byte.
	SPI_MASTER_CS_PORT	define CS port from master to Slave
	SPI_MASTER_CS_SHADOW	define shadow register for CS (Master only)
  	SPI_MASTER_CS_BIT		define CS bit number

		note: SLAVE mode is only available for serial ports

	SPI_MODE_PARALLEL	use a parallel I/O port

(2) SPI Bit Rate if using serial port (default is 5)
	SPI_CLK_DIVISOR	This is the divisor for the appropriate Timer A register.
	Warning: a small value for the SPI_CLK_DIVISOR can result in unstable operation.
	Recommendation is that values should be >= 5.

(3) I/O bits for parallel interface							(defaults)
	SPI_TX_REG		register for clock and Tx data		(PDDR)
	SPI_TXD_BIT		bit number for Tx Data					(bit 1)
	SPI_CLK_BIT		bit number for Clock						(bit 0)
	SPI_RX_REG		register for Rx data						(PDDR)
	SPI_RXD_MASK	mask for Rx bit							(8, bit 3)
	NOTES for the parallel interface:
	(1) the default values will be used if SPI_TX_REG is not defined.
		If SPI_TX_REG is defined then all the values must be defined.
	(2) the transmit data and clock bits must be in the same register
	(3) the user MUST initialize the I/O port as required for
		proper operation of the appropriate output and input bits!

END DESCRIPTION **********************************************************/


/*** BeginHeader */
#ifndef __SPILIB
#define __SPILIB
/*** EndHeader */

/*** BeginHeader */

#ifndef SPI_DEBUG
#define SPI_DEBUG nodebug
#endif

#ifndef R3000
#define	R3000		0x0100
#endif

//								**** test for type of interface ****
#ifndef SPI_SLAVE
#define SPI_MASTER
#endif

#ifndef SPI_SER_A
#ifndef SPI_SER_B
#ifndef SPI_SER_C
#ifndef SPI_SER_D
#ifndef SPI_MODE_PARALLEL
#warnt "No SPI interface defined: using SPI_SER_B"
#define SPI_SER_B
#endif // SPI_MODE_PARALLEL
#endif // SPI_SER_D
#endif // SPI_SER_C
#endif // SPI_SER_B
#endif // SPI_SER_A

//								**** set up to use serial port A ****
#ifdef SPI_SER_A
#define SPI_MODE_SERIAL
#define SPI_DR	SADR
#define SPI_CR	SACR
#define SPI_SR	SASR
#define SPI_ER	SAER		// R3000 only
#define SPI_ShER	SAERShadow
#endif // SPI_SER_A

//								**** set up to use serial port B ****
#ifdef SPI_SER_B
#define SPI_MODE_SERIAL
#define SPI_DR	SBDR
#define SPI_CR	SBCR
#define SPI_SR	SBSR
#define SPI_ER	SBER		// R3000 only
#define SPI_ShER	SBERShadow
#ifdef SERB_USEPORTD
#define SPI_USE_PD4
#endif
#endif // SPI_SER_B

//								**** set up to use serial port C ****
#ifndef _CPU_ID_
#define _CPU_ID_ 0
#endif

#ifdef SPI_SER_C
#if (_CPU_ID_ < R3000)
#error "Serial ports C and D not valid for R2000"
#endif
#define SPI_MODE_SERIAL
#define SPI_DR	SCDR
#define SPI_CR	SCCR
#define SPI_SR	SCSR
#define SPI_ER	SCER		// R3000 only
#define SPI_ShER	SCERShadow
#endif // SPI_SER_C

//								**** set up to use serial port D ****
#ifdef SPI_SER_D
#if (_CPU_ID_ < R3000)
#error "Serial ports C and D not valid for R2000"
#endif
#define SPI_MODE_SERIAL
#define SPI_DR	SDDR
#define SPI_CR	SDCR
#define SPI_SR	SDSR
#define SPI_ER	SDER		// R3000 only
#define SPI_ShER	SDERShadow
#endif // SPI_SER_D

#ifndef SPI_CLOCK_MODE
#define SPI_CLOCK_MODE 0
#endif

//								**** set up to use parallel port ****
#ifdef SPI_MODE_PARALLEL

#ifndef SPI_TX_REG
#warnt "No SPI Parallel Interface defined: using defaults - PD0,1,3"
#define SPI_SETUP_PORTD
#define SPI_TX_REG		PDDR
#define SPI_CLK_BIT		0
#define SPI_TXD_BIT		1
#define SPI_RX_REG		PDDR
#define SPI_RXD_MASK		8
#endif // SPI_TX_REG

#endif // SPI_MODE_PARALLEL

//								**** serial interface values ****
#ifdef SPI_MODE_SERIAL

#ifndef SPI_SLAVE

#ifndef SPI_CLK_DIVISOR
#define SPI_CLK_DIVISOR		5		// divisor for the bit rate generator
#endif // SPI_CLK_DIVISOR

#if (SPI_CLK_DIVISOR<5)
#warnt "SPI_CLK_DIVISOR may be too small!"
#endif

#else
#define SPI_CLK_DIVISOR		0	// dummy value for slave mode

#endif // not SPI_SLAVE

#endif	// SPI_MODE_SERIAL


/*** EndHeader */


/*** Beginheader SPIinit, SPIWrite, SPIRead, spi_swap */

void	SPIinit	( void );
int	SPIWrite ( void *DataAddress, int NbrBytes );
int	SPIRead  ( void *DataAddress, int NbrBytes );

#ifndef SPI_NOREV
extern const char RevBitTable[];
#endif

extern char	SPIxor;					// flag for inverting the received byte
extern char	SPITXxor;				// flag for inverting the transmitted byte
extern int	SPIdivisor;				// bit rate divisor

// SPI control register Definitions
#ifdef SPI_SLAVE
#define SPI_MS 0x08
#else
#define SPI_MS 0x0C
#endif

#ifdef SPI_USE_PD4
#define SPI_RX					0x50 | SPI_MS	// includes clock bits, input from PD4
#else
#define SPI_RX					0x40 | SPI_MS	// includes clock bits, input from PC4
#endif

#define SPI_TX					0x80 | SPI_MS	// includes clock bits

/*** endheader */

char	SPIxor;
char	SPITXxor;
int	SPIdivisor;				// bit rate divisor


#ifndef SPI_NOREV
#ifndef BIT_REVERSE_TABLE
const char RevBitTable[] = {
0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};
#endif
#endif

/* START FUNCTION DESCRIPTION ********************************************
SPIinit                  <SPI.LIB>

SYNTAX:	      void SPIinit ();

DESCRIPTION:   initialize the SPI port parameters - serial interface only!

PARAMETER1:		none

RETURN VALUE:	none

This library is NOT interrupt driven.  It is strictly a polled operation.
The functions block until the requested operation is complete.

The following is a description of the values which the user may define
BEFORE the #use SPI.lib statement:

(1) Interface (default is SPI_SER_B)
	SPI_SER_A			use serial port A
	SPI_SER_B			use serial port B
	SPI_SER_C			use serial port C (R3000 only)
	SPI_SER_D			use serial port D (R3000 only)
	SPI_CLOCK_MODE		clock and data phase (R3000 only)
	SERB_USEPORTD		define this to use the alternate serial port B pins

	SPI_SLAVE			defines the Rabbit as a slave device

	SPI_SLAVE_RDY: This signal is generated by the Slave to tell the
      Master that the slave is ready.
	SPI_SLAVE_RDY_PORT	defines the port for SLAVE_RDY signal
	SPI_SLAVE_RDY_SHADOW defines the shadow register for SPI_SLAVE_RDY_PORT
	SPI_SLAVE_RDY_BIT	defines the bit for the SLAVE_RDY signal

	SPI_SLAVE_CS: This signal is read by the slave and is used by it
      to determine that it has been enabled by the Master.
	SPI_SLAVE_CS_REG	defines the register for the incoming CS signal
	SPI_SLAVE_CS_BIT	defines the bit for the incoming CS signal - Low True
	SPI_SLAVE_HIGH_TRUE define if high true chip select is desired

	SPI_MASTER_CS: This signal is generated by the Master.
		The user is responsible for setting/clearing this
      bit before/after every transaction.
      MASTER OPERATION: If SPI_MASTER_CS_PORT is defined it
      will be toggled during the data transfer.  The value of
      SPI_SLAVE_HIGH_TRUE is used to determine the true state.
      SLAVE OPERATION: If SPI_MASTER_CS_PORT is defined the
      slave receive function will use the CS input for
      handshaking between each byte.
	SPI_MASTER_CS_PORT	define CS port from master to Slave
	SPI_MASTER_CS_SHADOW	define shadow register for CS
	SPI_MASTER_CS_BIT		define CS bit number

		note: SLAVE mode is only available for serial ports

	SPI_MODE_PARALLEL	use a parallel I/O port
		note: this function does nothing for a parallel interface

(2) SPI Clock Divisor if using serial port (default is 5)
	SPI_CLK_DIVISOR	This is the divisor for the appropriate Timer A register.
	Or, you may specify the divisor value via the integer variable SPIdivisor.

(3) I/O bits for parallel interface							(defaults)
	SPI_TX_REG		register for clock and Tx data		(PDDR)
	SPI_TXD_BIT		bit number for Tx Data					(bit 1)
	SPI_CLK_BIT		bit number for Clock						(bit 0)
	SPI_RX_REG		register for Rx data						(PDDR)
	SPI_RXD_MASK	mask for Rx bit							(8, bit 3)
	NOTES for the parallel interface:
	(1) the default values will be used if SPI_TX_REG is not defined.
		If SPI_TX_REG is defined then all the values must be defined.
	(2) the transmit data and clock bits must be in the same register
	(3) the user MUST initialize the I/O port as required for
		proper operation of the appropriate output and input bits!

(4) Other macros
	SPI_NOREV	define to disable bit reversing.  This enables the Rabbit
   	to Tx and Rx the LSB first.
	SPI_DEBUG	define to enable debugging of the library.

NOTES:
(1) sets SPIxor 0 (see SPIRead) and SPITXxor (see SPIWrite) to 0.
(2) It is the responsibility of the user to develop whatever Chip Select signal
		which may be required.
(3) This library is NOT interrupt driven.  It is strictly a polled operation.
		The functions block until the requested operation is complete.

	See also: SPIWrite, SPIRead, SPIWrRd
END DESCRIPTION **********************************************************/


/* START FUNCTION DESCRIPTION ********************************************
SPIWrite                  <SPI.LIB>

SYNTAX:	      int SPIWrite ( void *SrcAddr, int ByteCount );

DESCRIPTION:   Write a block of bytes to the SPI port

PARAMETER1:   	address of data to write
PARAMETER2:		number of bytes to write

RETURN VALUE:	Master: none,
					Slave: 0 = no CS signal, no transmitted bytes
							 1 = CS, bytes transmitted

If SPI_SLAVE_RDY_PORT is defined for a SLAVE device the driver will turn on the
bit immediately after loading the transmit register.  It will then wait for the
buffer to become available then turn off the bit.  The buffer will not become
available until the master supplies the first clock.

If SPI_SLAVE_RDY_PORT is defined for a MASTER device the driver will wait for
the bit to become true before transmitting the byte and then wait for it to
become false after transmitting the byte.

	Note for Master: the receiving device Chip Select must already be active

If doing "bit banging" via a parallel interface:
the variable SPITXxor may be set to 0xFF to invert the data bits in order
account for an invertor on the selected output.

	See also: SPIinit, SPIRead, SPIWrRd
END DESCRIPTION **********************************************************/


/* START FUNCTION DESCRIPTION ********************************************
SPIRead                  <SPI.LIB>

SYNTAX:	      int SPIRead ( void *DestAddr, int ByteCount );

DESCRIPTION:   Read a block of bytes from the SPI port

PARAMETER1:    address to store the data
PARAMETER2:		number of bytes to read

RETURN VALUE:	Master: none,
					Slave: 0 = no CS signal, no received bytes
							 1 = CS, bytes received

If SPI_SLAVE_RDY_PORT is defined for a SLAVE device the driver will turn on the
bit immediately upon activating the receiver.  It will then wait for a byte to
become available then turn off the bit.  The byte will not be available until
the master supplies the 8 clock pulses.

If SPI_SLAVE_RDY_PORT is defined for a MASTER device the driver will wait for
the bit to become true before activating the receiver and then wait for it to
become false after receiving the byte.

	Note for Master: the receiving device Chip Select must already be active

	The variable SPIxor needs to be set to either 0x00 or 0xFF depending
	on whether or not the received signal needs to be inverted.  Most
	applications will not need inversion.  SPIinit sets the value to 0.

If doing "bit banging" via a parallel interface:
the variable SPIxor may be set to 0xFF to invert the received data in order
account for an invertor in the data from the "other" device.

	See also: SPIinit, SPIWrite, SPIWrRd
END DESCRIPTION **********************************************************/


SPI_DEBUG void SPIinit ( void )
{	auto int i;

#GLOBAL_INIT {
	SPIxor = 0;									// assume no Rx invert
	SPITXxor = 0;								// assume no Tx invert
}

#ifndef SBC_SPI_DIVISOR
	SPIdivisor = SPI_CLK_DIVISOR;			// init divisor value
#else
	SPIdivisor = SBC_SPI_DIVISOR;			// init divisor value
#endif

#ifdef SPI_MODE_SERIAL		// set up SPI port

#ifdef SPI_SER_A
	BitWrPortI ( PCFR, &PCFRShadow, 1, 6 ); // enable serial Port A UART output
	WrPortI ( TAT4R, &TAT4RShadow, SPIdivisor );	// set the SPI bit rate
#endif

#ifdef SPI_SER_B
#ifdef SERB_USEPORTD																		// 13-Sep-2001
	BitWrPortI ( PDFR, &PDFRShadow, 1, 4 ); // enable serial Port B UART output on PD4
	BitWrPortI( PDDDR, &PDDDRShadow, 1, 4); // enable pin as output
#else
	BitWrPortI ( PCFR, &PCFRShadow, 1, 4 ); // enable serial Port B UART output on PC4
#endif
	WrPortI ( TAT5R, &TAT5RShadow, SPIdivisor );	// set the SPI bit rate
#endif	// SPI_SER_B

#ifdef SPI_SER_C
	WrPortI ( TAT6R, &TAT6RShadow, SPIdivisor );	// set the SPI bit rate
	BitWrPortI ( PCFR, &PCFRShadow, 1, 2 ); // enable serial Port C UART output on PC2
#ifndef SPI_SLAVE
	BitWrPortI ( PFDDR, &PFDDRShadow, 1, 1 );	// set PF1 as output
	BitWrPortI ( PFFR, &PFFRShadow, 1, 1 );	// set PF1 as serial clock
#else
	BitWrPortI ( PFDDR, &PFDDRShadow, 0, 1 );	// set PF1 as input
#endif
#endif	// SPI_SER_C

#ifdef SPI_SER_D
	WrPortI ( TAT7R, &TAT7RShadow, SPIdivisor );	// set the SPI bit rate
	BitWrPortI ( PCFR, &PCFRShadow, 1, 0 ); // enable serial Port D UART output on PC0
#ifndef SPI_SLAVE
	BitWrPortI ( PFDDR, &PFDDRShadow, 1, 0 );	// set PF0 as output
	BitWrPortI ( PFFR, &PFFRShadow, 1, 0 );	// set PF0 as serial clock
#else
	BitWrPortI ( PFDDR, &PFDDRShadow, 0, 0 );	// set PF0 as input
#endif
#endif	// SPI_SER_D

#ifndef SPI_SLAVE
	RdPortI ( SPI_DR );						// dummy read to empty the buffer		2.08
#endif

	WrPortI ( SPI_CR, NULL, SPI_MS );	// set clock Master/Slave mode

#if (_CPU_ID_ >= R3000)
	WrPortI ( SPI_ER, &SPI_ShER, (SPI_CLOCK_MODE & 0x03)<<4 ); // set SPI clock mode
#endif

#endif	// SPI_MODE_SERIAL

}

#asm SPI_DEBUG root

;Write multiple bytes to the SPI device
;Input Parameter 1: (int) source address in hl ( also 2(sp) )
;Input Parameter 2: (int) number of bytes to send ( 4(sp) )
;Enter with the SPI device ready to receive the data bytes
;
SPIWrite::
#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_CS_REG
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
#ifdef SPI_SLAVE_HIGH_TRUE
			jr		nz, SPIWrite_cont		; jump if yes - high true
#else
			jr		z, SPIWrite_cont		; jump if yes - low true
#endif
			xor	a							; a = 0 = show no CS
			ld		l, a						; set
			ld		h, a						;   return value
			ret
SPIWrite_cont:
#endif ; SPI_SLAVE_CS_REG
#endif ; SPI_SLAVE

; set up the registers
		push	ix						; preserve
		ld		a, 0xFF				; set up for testing end of loop
		ld		d, a
		ld		e, a					; de = 0xFFFF
		ld		ix, hl				; get the source address
		ld		iy, (sp+6)			; get the number of bytes
; send the data bytes
;	de = byte count mask
;	ix = source address
;	iy = byte count
SPIWriteA:
		ld		a, (SPITXxor)		; get bit inversion value
		ld		l, (ix)				; get a byte
		xor	l						; invert if necessary
		ld		l, a					; restore for call
		call	SPITx					; send it
		inc	ix						; point to next byte
		dec	iy						; update bytes remaining
		and	iy, de				; check if done (iy = 0): z=1 if done
		jr		nz, SPIWriteA		; jump if not done

#ifdef SPI_MODE_SERIAL
		call	SPIWait4Last		; wait for last byte to complete
#endif

#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_CS_REG
		ld		l, 1					; set
		ld		h, 0					;   return value
#endif
#endif

		pop	ix
		ret	;SPIWrite


;Read multiple bytes from the SPI device
;Input Parameter 1: (int) destination address in hl ( also 2(sp) )
;Input Parameter 2: (int) number of bytes to read ( 4(sp) )
;Enter with the SPI device ready to transmit the data bytes
;
SPIRead::

#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_CS_REG
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
#ifdef SPI_SLAVE_HIGH_TRUE
			jr		nz, SPIRead_cont		; jump if yes - high true
#else
			jr		z, SPIRead_cont		; jump if yes - low true
#endif
			xor	a							; a = 0 = show no CS
			ld		l, a						; set
			ld		h, a						;   return value
			ret
SPIRead_cont:
#endif ; SPI_SLAVE_CS_REG
#endif ; SPI_SLAVE

; set up the registers
		push	ix						; preserve
		ld		a, 0xFF				; set up for testing end of loop
		ld		d, a
		ld		e, a
		ld		ix, hl				; get the destination address
		ld		iy, (sp+6)			; get the number of bytes

; receive the data bytes
;	de = byte count mask
;	ix = destination address
;	iy = byte count
#ifdef SPI_MODE_SERIAL
	ioi	ld		a, (SPI_DR)		; dummy read to empty any "junk"					13-Sep-2001
#endif
SPIReadA:
		call	SPIRx					; send request
		ld		(ix), l				; store the byte
		inc	ix						; point to next byte
		dec	iy						; calculate bytes remaining
		and	iy, de				; check if done: z=1 if done
		jr		nz, SPIReadA		; jump if not done

#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_CS_REG
		ld		l, 1					; set
		ld		h, 0					;   return value
#endif
#endif

		pop	ix
		ret	;SPIRead

#ifdef SPI_MODE_SERIAL

SPITx::
; This function will transmit a byte via a serial port
;	set up in its synchronous mode.
; Input parameter: the byte value to transmit - in l
; Return value: none
; Uses: a, hl, (bc)
;
#ifndef SPI_NOREV
			call	spi_swap			; swap the bit order
#endif

#ifdef SPI_MASTER

#ifdef SPI_MASTER_CS_REG
			ld		a, (SPI_MASTER_CS_SHADOW) ; get the shadow register contents
#ifndef SPI_SLAVE_HIGH_TRUE
			set	SPI_MASTER_CS_BIT, a		; disable the CS bit = 1
#else
			res	SPI_MASTER_CS_BIT, a		; disable the CS bit = 0
#endif
			ld		(SPI_MASTER_CS_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_MASTER_CS_PORT), a ; send to I/O port
#endif ; SPI_MASTER_CS_REG

#ifdef SPI_SLAVE_RDY_PORT
SPITx1:
	ioi	ld		a, (SPI_SLAVE_RDY_PORT)
			bit	SPI_SLAVE_RDY_BIT, a ; is slave ready?
			jr		z, SPITx1		; jump if no
#endif
#endif ; SPI_MASTER

			ld		a, l				; get the data value (from spi_swap)
	ioi	ld		(SPI_DR), a		;		load it
			ld		a, SPI_TX		; get TX control value
	ioi	ld		(SPI_CR), a		; load TX control value - send the byte

#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_RDY_PORT
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			set	SPI_SLAVE_RDY_BIT, a ; set the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
#endif
#endif

; wait for the buffer to be available
Tx0:
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x08				; test buffer busy bit
			jr		nz, Tx0			; jump if not done

#ifdef SPI_SLAVE_RDY_PORT
#ifdef SPI_SLAVE
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			res	SPI_SLAVE_RDY_BIT, a ; clear the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
#else

#ifdef SPI_MASTER_CS_REG
			ld		a, (SPI_MASTER_CS_SHADOW) ; get the shadow register contents
#ifndef SPI_SLAVE_HIGH_TRUE
			res	SPI_MASTER_CS_BIT, a		; enable the CS bit = 0
#else
			set	SPI_MASTER_CS_BIT, a		; enable the CS bit = 1
#endif
			ld		(SPI_MASTER_CS_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_MASTER_CS_PORT), a ; send to I/O port
#endif ; SPI_MASTER_CS_REG


SPITx2:
	ioi	ld		a, (SPI_SLAVE_RDY_PORT)
			bit	SPI_SLAVE_RDY_BIT, a ; has slave released ready bit?
			jr		nz, SPITx2		; jump if no
#endif ; SPI_SLAVE
#endif ; SPI_SLAVE_RDY_PORT
			ret	;SPITx


;This function waits for a byte to complete
SPIWait4Last:
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x04				; test transmitter busy bit
			jr		nz, SPIWait4Last	; jump if not done
			ret

;Receive a byte via a serial port set up in its synchronous mode.
; Return value: the received byte as an integer - in hl
; Uses: a, hl, (bc)
;
SPIRx::
#ifdef SPI_MASTER
#ifdef SPI_SLAVE_RDY_PORT
	ioi	ld		a, (SPI_SLAVE_RDY_PORT)
			bit	SPI_SLAVE_RDY_BIT, a ; is slave ready?
			jr		z, SPIRx			; jump if no
#endif
#endif ; SPI_MASTER

			ld		a, SPI_RX		; set up RX control value
	ioi	ld		(SPI_CR), a		; load RX control value - receive the byte

#ifdef SPI_SLAVE

#ifdef SPI_MASTER_CS_REG
SPIRx1:	; wait for CS false
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
#ifndef SPI_SLAVE_HIGH_TRUE
			jr		z, SPIRx1		; jump if yes - low true
#else
			jr		nz, SPIRx1		; jump if yes - high true
#endif
#endif ; SPI_MASTER_CS_REG

#ifdef SPI_SLAVE_RDY_PORT
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			set	SPI_SLAVE_RDY_BIT, a ; set the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
#endif
#endif ; SPI_SLAVE

; wait for the receiver to complete
Rx0:
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x80				; test receiver bit
			jr		z, Rx0			; jump if not done yet

; get the byte
			ld		a, (SPIxor)		; get the byte invert value
			ld		L, a				; save for later
	ioi	ld		a, (SPI_DR)		; get the byte
			xor	L					; invert the bits - maybe
			ld		L, a				; store for caller


#ifdef SPI_SLAVE_RDY_PORT
#ifdef SPI_SLAVE

#ifdef SPI_MASTER_CS_REG
SPIRx2:	; wait for CS true
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
#ifndef SPI_SLAVE_HIGH_TRUE
			jr		nz, SPIRx2		; jump if no - low true
#else
			jr		z, SPIRx2		; jump if no - high true
#endif
#endif ; SPI_MASTER_CS_REG

			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			res	SPI_SLAVE_RDY_BIT, a ; clear the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
#else
SPIRx2:
	ioi	ld		a, (SPI_SLAVE_RDY_PORT)
			bit	SPI_SLAVE_RDY_BIT, a ; has slave released ready bit?
			jr		nz, SPIRx2		; jump if no
#endif ; SPI_SLAVE
#endif ; SPI_SLAVE_RDY_PORT

; drop thru to swap the bit order and return

;Swap the bits within a byte - 29 clocks (+12 for call)
; Input parameter: the byte value to swap - in L
; Return value: the new byte value as an integer - in HL
; Uses: a, HL, bc
;
#ifndef SPI_NOREV
spi_swap::
	ld		c, L						; copy the byte value
	xor	a							; a=0
	ld		b, a						; bc = offset into BitRev table
	ld		HL, RevBitTable		; get address of table
	add	HL, bc					; calculate address of bit reversed byte
	ld		L, (HL)					; get new byte
	ld		h, a						; make integer
#endif
	ret	;spi_swap


#else	// these following two functions are used when "bit banging"


SPITx::
; This function will transmit a byte via the defined I/O register and bits
; It will transmit the MSB first
; Input parameter: the byte value to transmit - in l
; Return value: none
; Uses: a, b, h, l
;
			ld		b, 8				; nbr of clocks
			ld		a, l				; working copy of data
			ld		hl, SPI_TX_REG	; output register
SPITxA:
; output the data bit state
			rla						; bit 7 into C
			jr		nc, SPITxB		; jump if C=0
	ioi	set	SPI_TXD_BIT, (hl) ; bit = 1
			jr		SPITxC
SPITxB:
	ioi	res	SPI_TXD_BIT, (hl) ; bit = 0

SPITxC:
#ifdef SPI_INVERT_CLOCK
	ioi	set	SPI_CLK_BIT, (hl) ; clock low
	ioi	res	SPI_CLK_BIT, (hl) ; clock high
#else
	ioi	res	SPI_CLK_BIT, (hl) ; clock low
	ioi	set	SPI_CLK_BIT, (hl) ; clock high
#endif
; test if done
			djnz	SPITxA			; jump if not done
			ret	;SPITx
;
SPIRx::
; This function will receive a byte via the defined I/O register and bits
; Input parameter: none
; Return value: data value in register l
; Uses: a, b, c, hl
;
			ld		b, 8				; nbr of clocks
			ld		hl, SPI_TX_REG	; clock register
SPIRxA:
; create clock pulse and receive data bit
#ifdef SPI_INVERT_CLOCK
	ioi	set	SPI_CLK_BIT, (hl) ; clock high
	ioi	ld		a, (SPI_RX_REG) ; read the data value
	ioi	res	SPI_CLK_BIT, (hl) ; clock  low
#else
	ioi	res	SPI_CLK_BIT, (hl) ; clock low
	ioi	ld		a, (SPI_RX_REG) ; read the data value
	ioi	set	SPI_CLK_BIT, (hl) ; clock  high
#endif
; operate on received data
			and	SPI_RXD_MASK	; keep the data bit: C=0, Z=0/1
			jr		z, SPIRxC		; jump if data bit is 0
			scf						; set C bit
;
SPIRxC:	rl		c					; shift 1 into LSB
; test if done
			djnz	SPIRxA			; jump if not done
			ld		a, (SPIxor)		; get the byte invert value
			xor	c					; invert the bits - maybe
			ld		l, a				; save for caller
			ret					;SPIRx

#endif // !SPI_MODE_SERIAL
#endasm


/* START FUNCTION DESCRIPTION ********************************************
SPIWrRd                  <SPI.LIB>

SYNTAX:	      int SPIWrRd ( void *SrcAddr, void *DstAddr, int ByteCount );

DESCRIPTION:   Read and Write a block of bytes from/to the SPI port

PARAMETER1:   	address of data to write
PARAMETER2:   	address to put received data
PARAMETER3:		number of bytes to read/write -
						max of 255 bytes - not checked!

The receive buffer MUST be at least as large as the number of bytes!

RETURN VALUE:	Master: none,
					Slave: 0 = no CS signal, no received/transmitted bytes
							 1 = CS, bytes received/transmitted

	Note for Master: the receiving device Chip Select must already be active

See also: SPIinit, SPIRead, SPIWrite
END DESCRIPTION **********************************************************/

/*** Beginheader SPIWrRd */
int SPIWrRd	( void *SrcAddr, void *DstAddr, int ByteCount );
/*** Endheader */

#asm SPI_DEBUG root

#ifdef SPI_MODE_SERIAL

;Write and read multiple bytes to/from the SPI device
;Input Parameter 1: (int) source address in HL ( also 2(sp) )
;Input Parameter 2: (int) dest address ( also 4(sp) )
;Input Parameter 3: (int) number of bytes to send ( 6(sp) )
;Enter with the SPI device ready to receive the data bytes
;
SPIWrRd::

#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_CS_REG
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
#ifdef SPI_SLAVE_HIGH_TRUE
			jr		nz, SPIWrRd_cont		; jump if yes - high true
#else
			jr		z, SPIWrRd_cont		; jump if yes - low true
#endif
			xor	a							; a = 0 = show no CS
			ld		l, a						; set
			ld		h, a						;   return value
			ret
SPIWrRd_cont:
#endif
#endif

; set up the registers
		push	ix
		ld		ix, HL				; get the source address
		ld		iy, (sp+6)			; get the destination address
		ld		hl, (sp+8)			; and byte count
		ld		e, L					; save byte count for processing
; send and receive the data bytes
SPIWrRdA:
		ld		L, (ix)				; get a byte to transmit
		call	SPITxRx				; send and receive a byte
#ifndef SPI_NOREV
		call	spi_swap				; swap the bit order of the received byte - Uses: a, HL, bc
#endif
		ld		(iy), L				; save received byte
		inc	ix						; point to next transmit byte
		inc	iy						; point to next receive byte
		dec	e						; update bytes remaining
		jr		nz, SPIWrRdA		; jump if not done

#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_CS_REG
		ld		l, 1					; set
		ld		h, 0					;   return value
#endif
#endif

		pop	ix
		ret	;SPIWrRd

SPITxRx::
; This function will transmit and receive a byte via a serial port
;	set up in its synchronous mode.
; Input parameter: the byte value to transmit - in L
; Return value: the received byte in L
; Uses: a, HL, (bc)
;
#ifndef SPI_NOREV
			call	spi_swap			; swap the bit order - Uses: a, HL, bc
#endif
			ld		a, L				; get the data value
	ioi	ld		(SPI_DR), a		;		load it

#if (_CPU_ID_ >= R3000)					; 2.10
			ld		a, SPI_RX|SPI_TX ; get transceive value
	ioi	ld		(SPI_CR), a		; initiate transceive operation
#else
; the next 3 instructions minimize the time at IPL = 3
			ld		HL, SPI_CR		; get address of control register
			ld		c, SPI_RX		; set up RX control value
			ld		a, SPI_TX		; get TX control value
			ipset	3					; disable interrupts so the next two
										;	instructions will not be interrupted
	ioi	ld		(HL), a			; load TX control value
			nop
	ioi	ld		(HL), c			; load RX control value
			nop
			ipres						; enable other interrupts
#endif

#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_RDY_PORT
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			set	SPI_SLAVE_RDY_BIT, a ; set the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
#endif
#endif

; wait for the receiver to complete - the receiver will complete AFTER the transmitter
SPITxRx0:
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x80				; test receiver done bit
			jr		z, SPITxRx0			; jump if not done

#ifdef SPI_SLAVE
#ifdef SPI_SLAVE_RDY_PORT
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			res	SPI_SLAVE_RDY_BIT, a ; set the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
#endif
#endif

	ioi	ld		a, (SPI_DR)		; get the received byte
			ld		L, a				; save for return
			ret	;SPITxRx


// Added - 2002.05.14 - START

#else	// if not SPI_MODE_SERIAL: these following two functions are used when "bit banging"

;Write and read multiple bytes to/from the SPI device
;Input Parameter 1: (int) source address in HL ( also 2(sp) )
;Input Parameter 2: (int) dest address ( 4(sp) )
;Input Parameter 3: (int) number of bytes to send and receive ( 6(sp) )
;Enter with the SPI device ready to receive the data bytes
;
SPIWrRd::
; set up the registers
		push	ix
		ld		ix, HL				; get the source address
		ld		iy, (sp+6)			; get the destination address
		ld		hl, (sp+8)			; and byte count
		ld		e, L					; save byte count for processing
; send and receive the data bytes
SPIWrRdA:
		ld		a, (SPITXxor)		; get bit inversion value
		ld		l, (ix)				; get a byte
		xor	l						; invert if necessary
		ld		l, a					; restore for call
		call	SPITxRx				; send and receive a byte - does NOT use e
		ld		(iy), L				; save received byte
		inc	ix						; point to next transmit byte
		inc	iy						; point to next receive byte
		dec	e						; update bytes remaining
		jr		nz, SPIWrRdA		; jump if not done
		pop	ix
		ret	;SPIWrRd

SPITxRx::
; This function will transmit and receive a byte via the defined I/O register and bits
; It will transmit the MSB first
; Input parameter: the byte value to transmit - in L
; Return value: Return value: data value in register L
; Uses: a, b, c, d, h, L
;
			ld		b, 8				; nbr of clocks
			ld		d, L				; working copy of data
			ld		hl, SPI_TX_REG	; output register
SPITxRxA:
; output the data bit state
			rl		d					; bit 7 into C
			jr		nc, SPITxRxB	; jump if C=0
	ioi	set	SPI_TXD_BIT, (hl) ; bit = 1
			jr		SPITxRxC
SPITxRxB:
	ioi	res	SPI_TXD_BIT, (hl) ; bit = 0

SPITxRxC:	; generate the clock pulse & read the input bit
#ifdef SPI_INVERT_CLOCK
	ioi	set	SPI_CLK_BIT, (hl) ; clock high
	ioi	ld		a, (SPI_RX_REG) ; read the data value
	ioi	res	SPI_CLK_BIT, (hl) ; clock low
#else
	ioi	res	SPI_CLK_BIT, (hl) ; clock low
	ioi	ld		a, (SPI_RX_REG) ; read the data value
	ioi	set	SPI_CLK_BIT, (hl) ; clock high
#endif
; operate on received data
			and	SPI_RXD_MASK	; keep the data bit: C=0, Z=0/1
			jr		z, SPITxRxD		; jump if data bit is 0
			scf						; set C bit
SPITxRxD:
			rl		c					; shift C into LSB of c

; test if done
			djnz	SPITxRxA			; jump if not done
			ld		a, (SPIxor)		; get the byte invert value
			xor	c					; invert the bits - maybe
			ld		L, a				; save for caller
			ret	;SPITxRx
;
// Added - 2002.05.14 - END

#endif // SPI_MODE_SERIAL
#endasm


/*** BeginHeader */
#endif	// __SPILIB
/*** EndHeader */