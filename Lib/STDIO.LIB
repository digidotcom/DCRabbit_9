/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader  ********************************************/
#ifndef __STDIO_LIB
#define __STDIO_LIB
/*** EndHeader ***********************************************/

/* START LIBRARY DESCRIPTION *********************************************
STDIO.LIB

DESCRIPTION:
	Standard I/O (with Dynamic C terminal window) functions

SUPPORT LIB'S:
END DESCRIPTION **********************************************************/

/*** Beginheader  */
#define DEFDECDIGITS 6
/*** endheader */

/*** Beginheader gets */

/*=========================================================================*\
	Wait for String from Keyboard Input ( Do Cooking )
\*=========================================================================*/
char *gets(char *s);

/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
gets                         <STDIO.LIB>

SYNTAX: char *gets(char *s);

KEYWORDS: keyboard, input, stdio window

DESCRIPTION: This function communicates through the stdio window to wait
for a string terminated by a return.  It does not return until a return
is typed in the stdio window.  The string returned is null terminated
without the return.  The input string is put to the location pointed to by
the argument "s".  The caller is responsible to make sure the location
pointed to by "s" is big enough for the string.

This function requires Dynamic C's stdio window to be open, and the
stdio window must have the focus for keybaord hits on the PC to be
detected. Any call to printf in debug mode opens the stdio window.

The user should make sure only one process calls this function at a time.

RETURN VALUE: The same pointer to characters passed in, but now the pointer
points to a null-terminated string typed from the stdio window in Dynamic
C.
END DESCRIPTION **********************************************************/
nodebug useix
char *gets(char *s)
{
	auto char *p, c;

	p = s;
	while (1)
	{
//#asm xmemok
//	rst	28h	;	inserted here so the user may break execution
//#endasm
		c = getchar();
		switch (c)
		{
			case '\b':
				if (s != p)
				{
					puts("\b \b");
					p--;
				}
				break;
			case '\r':
				*p = 0;
				putchar('\n');
				c = 0;
				break;
			default:
				*p++= c;
				putchar(c);
				break;
		}
		if (! c)
			break;
	}
	return (s);
}

/*** Beginheader getswf */

int getswf(char *);

/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
getswf                         <STDIO.LIB>

SYNTAX: int getswf(char *s);

KEYWORDS: keyboard, input, stdio window

DESCRIPTION: This function communicates through the stdio window to wait
for a string terminated by a return.  It does not return until a return
is typed in the stdio window.  The string returned is null terminated
without the return.  The input string is put to the location pointed to by
the argument "s".  The caller is responsible to make sure the location
pointed to by "s" is big enough for the string.

This function requires Dynamic C's stdio window to be open, and the
stdio window must have the focus for keybaord hits on the PC to be
detected. Any call to printf in debug mode opens the stdio window.

The user should make sure only one process calls this function at a time.

RETURN VALUE:	Return 1 when the user ends the input with a linefeed,
otherwise returns 0, indicating the user is not done yet.

END DESCRIPTION **********************************************************/
nodebug useix
int getswf(char *s)
{
	auto res;
	static char *p, c;

	res = 0;
	costate {
		p = s;
		while (1)
		{
			waitfor(kbhit());
			c = getchar();
			switch (c)
			{
				case '\b':
					if (s != p)
					{
						puts("\b \b");
						p--;
					}
					break;
				case '\r':
					*p = 0;
					putchar('\n');
					c = 0;
					break;
				default:
					*p++= c;
					putchar(c);
					break;
			}
			if (! c)
				break;
		}
		res = 1;
	}
	return res;
}

/* START FUNCTION DESCRIPTION ********************************************
kbhit                      <STDIO.LIB>

SYNTAX: int kbhit();

KEYWORDS: keyboard, input, stdio

DESCRIPTION:  Returns non-zero if a key on the PC has been hit while
the stdio window in the Dynamic C IDE has the focus. Returns zero
otherwise

Like printf, this function is only useful for debugging in the
Dynamic C IDE. This function will always return 0 if the the Dynamic C
stdio window is not already open and focused. Any call to printf opens
the stdio window. The user should make sure only one process calls this
function at a time.

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/
/*** beginheader kbhit */
int kbhit();
/*** endheader */

nodebug
int kbhit() {
#ifdef STDIO_DEBUG_SERIAL
#ifndef STDIO_DEBUG_FORCEDSERIAL
	if (OPMODE & 0x08)
		return dkCharReady;
	else
#endif	//STDIO_DEBUG_FORCEDSERIAL
		return(_stdioSerialKbhit());
#else
	#asm debug
	rst	0x28
	#endasm
	return dkCharReady;
#endif
}

/*** beginheader getchar */

char getchar(void);

/*** endheader */

/*=========================================================================*\
	Wait for Keyboard Input
\*=========================================================================*/

/* START FUNCTION DESCRIPTION ********************************************
getchar                      <STDIO.LIB>

SYNTAX: char getchar();

KEYWORDS: keyboard, input, stdio

DESCRIPTION: This function busy waits for a character to be typed from the
stdio window in Dynamic C.

This function requires Dynamic C's stdio window to be open, and the
stdio window must have the focus for keybaord hits on the PC to be
detected. Any call to printf in debug mode opens the stdio window.

The user should make sure only one process calls this function at a time.

RETURN VALUE: a character typed in the stdio window in Dynamic C.
END DESCRIPTION **********************************************************/
nodebug useix
char getchar(void)
{
	auto char c;

	while (!kbhit()) {
		}
#ifdef STDIO_DEBUG_SERIAL
#ifndef STDIO_DEBUG_FORCEDSERIAL
	if (OPMODE & 0x08) {
		dkGetCharFromStdio();
		c = dkCharData;

		asm push	ip
		asm ipset 1
	   dkCharReady--;
		asm pop	ip
	}
	else
#endif	//STDIO_DEBUG_FORCEDSERIAL
		c = _stdioSerialIn();
#else
	dkGetCharFromStdio();
	c = dkCharData;

	asm push	ip
	asm ipset 1
   dkCharReady--;
	asm pop	ip
#endif

	return (c);
}

/*** BeginHeader selectkey */

int selectkey(char *selection);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
selectkey                         <STDIO.LIB>

SYNTAX: int selectkey(char *selection);

KEYWORDS: string, output, display, stdio window

DESCRIPTION: This function waits for the user to enter a key (character),
then match the character to a given selection.  This function is not
task reentrant.

This function requires Dynamic C's stdio window to be open, and the
stdio window must have the focus for keybaord hits on the PC to be
detected. Any call to printf in debug mode opens the stdio window.

PARAMETER1:	This string lists all the valid choices the user can make.

RETURN VALUE: If the operator enters a valid choice, the index to the
character in the "selection" argument + 1 is returned. Otherwise, 0 is
returned to indicate no valid choices has been made.

END DESCRIPTION **********************************************************/

nodebug
int selectkey(char *selection) {
	auto int retval;
	auto char *p;

	retval = 0;
	if (kbhit()) {
		p = strchr(selection,getchar());
		if (p) { putchar(*p); putchar('\n'); }
		return p ? p-selection+1 : 0;
	} else {
		return 0;
	}
}


/*** BeginHeader puts */

int puts(char *s);

/*** EndHeader   puts */

/***************************************************************************\
	ANSI String I/O

		 int puts ( char *s );
\***************************************************************************/

/* START FUNCTION DESCRIPTION ********************************************
puts                         <STDIO.LIB>

SYNTAX: int puts(char *s);

KEYWORDS: string, output, display, stdio window

DESCRIPTION: This function displays the string pointed to by argument "s"
on the stdio window in Dynamic C.  The stdio window is responsible to
interpret any escape code sequences contained in the string.

While this function is task reentrant, it should be used with care in a
multi-tasking situation.  Since only one character is output at a time,
output from different tasks can end up getting interleaved.

RETURN VALUE: Returns 1 if successful.
END DESCRIPTION **********************************************************/
nodebug useix
int puts(char *s)
{
	while (*s) {
		putchar(*s++);
	}
	return (1);
}

/*** BeginHeader putchar, putbin */

root void putchar(int ch);
root void putbin();
/*** EndHeader   putchar */

/* START FUNCTION DESCRIPTION ********************************************
putchar                      <STDIO.LIB>

SYNTAX: void putchar(int ch);

KEYWORDS: display, stdio window

DESCRIPTION: Puts a single character to STDOUT.

RETURN VALUE: none.
END DESCRIPTION **********************************************************/

#asm  nodebug

; PUTCHAR : Put a Single Character to STDOUT
;
; INPUT  :
;          None
; OUTPUT :
;          None

putchar::
#ifndef STDIO_DEBUG_SERIAL	// don't check OPMODE if stdio going to serial port
		ld			a, (OPMODE)
		and		8
		jr			nz, .putchar_cont		; using DEBUG mode
		ret									; putchar does nothing is non-DEBUG mode
#endif
.putchar_cont:
	   ld       a,0ah                ; Expand CR to CR/LF
	   cp       l
	   jr       nz,putbin
	   push     hl
	   ld       l,0dh
	   call     putbin
	   pop      hl

putbin::
	   xor      a							; Output Character
		ld			h,a						; hl has character and null
	   push     hl
		bool		hl
		ld			l,h
		add		hl,sp                ; pass location of character on stack to dkDoMsg
#ifdef STDIO_DEBUG_SERIAL
#ifndef STDIO_DEBUG_FORCEDSERIAL
		ld			a, (OPMODE)
		and		8
		jr			nz, .SDSdebugmode
#endif	//STDIO_DEBUG_FORCEDSERIAL
		call		_stdioSerialOut
#ifndef STDIO_DEBUG_FORCEDSERIAL
		jr			.SDSdone
.SDSdebugmode:
	   call     dkDoMsg
.SDSdone:
#endif	//STDIO_DEBUG_FORCEDSERIAL
#else
	   call     dkDoMsg
#endif
	   pop      hl                   ; realign sp
	   ret
#endasm

/*** BeginHeader __qe_snprintf */
void __qe_snprintf(int c, char *buf, int *cnt, void *instanceParam);
/*** EndHeader  */

nodebug
void __qe_snprintf(int c, char *buf, int *cnt, void *instanceParam)
{
	auto int *len;

	/*
		instanceParam is a pointer to the number of bytes remaining in the
		destination buffer and snprintf() guarantees a null-terminated buffer.
		Hence, if 1 >= (int) *instanceParam then we can't write any more non-null
		characters into buf[].
	*/
	len = (int *) instanceParam;
	if (0 < *len) {
		if (1 == *len) {
			buf[*cnt] = 0;	// guaranteed null-termination in buf[]
		} else {
			buf[*cnt] = c;
		}
		--*len;
	}
	++*cnt;
}


/*** BeginHeader snprintf */
int snprintf(char *buffer, int len, char *format, ...);
/*** EndHeader   snprintf */

/* START FUNCTION DESCRIPTION ********************************************
snprintf                      <STDIO.LIB>

SYNTAX:
   int snprintf(char *buffer, int len, char *format, ...);

KEYWORDS:

DESCRIPTION:
   Output length limited version of sprintf. Encodes, according to the
   format string and subsequent parameters, at most length - 1 non-null
   characters into the output buffer. The output buffer is guaranteed to
   be null-terminated. This function can be called by processes of
   different priorities.

   The user should make sure that:
      1) there are enough arguments after "format" to fill in the format
         specifiers in the format string, and
      2) the types of arguments after "format" match the format specifiers
         in the format string.

   The following is an incomplete list of possible format specifiers in
   the format string (for more details, please refer to most any C
   language books):
      %d    decimal integer (expects type int)
      %ld   decimal integer (expects type long)
      %u    decimal unsigned integer (expects type unsigned)
      %lu   decimal unsigned integer (expects type unsigned long)
      %x    hexadecimal integer (expects types int or unsigned)
      %lx   hexadecimal integer (expects types long or unsigned long)
      %s    string root pointer (not interpreted, expects type char *)
      %ls   string physical address (not interpreted, expects types long
            or unsigned long)
      %p    root pointer (expects type void *)
      %lp   physical address (expects types long or unsigned long)
      %e    decimal with exponent floating point Real (expects type float)
      %f    decimal floating point Real (expects type float)
      %g    shorter of %e or %f floating point Real (expects type float)

   Example:
      snprintf(buffer, 15, "%s=%x", "variable x", 256);
      should write the string "variable x=100" into buffer.

   The macro STDIO_DISABLE_FLOATS can be defined if it is not necessary to
   encode floating point numbers. If this macro is defined, %e, %f and %g
   will not be recognized. This can save thousands of bytes of code space.

PARAMETER1:
   The output buffer into which encoded characters are written.

PARAMETER2:
   The maximum number of characters to encode into the output buffer. Note
   that because the output buffer is guaranteed to be null-terminated, at
   most N - 1 non-null characters can be encoded into the output buffer.

PARAMETER3:
   The format string which specifies the output encoding of the subsequent
   (...) parameters.

PARAMETER...:
   Zero or more parameters to be encoded into the output buffer according
   to the format string's format specifiers.

RETURN VALUE:
   Either the count of non-null characters encoded into the output buffer
   or the count of non-null characters that would have been encoded into
   the output buffer had not the length limitation truncated the encoding.
END DESCRIPTION *********************************************************/

nodebug
int snprintf(char *buffer, int len, char *format, ...)
{
	auto int count, __cnt;
	auto int local_len;

	local_len = len;
	count = 0;

	doprnt(__qe_snprintf, format, (char *) ((char *) &format + sizeof format),
	       (void *) &local_len, buffer, &count);
	__cnt = count;
	__qe_snprintf(0, buffer, &count, (void *) &local_len);	// null terminator
	return __cnt;
}


/*** BeginHeader sprintf */
#if !(_SYSTEM)
int sprintf(char *buffer, char *format, ...);
#endif
/*** EndHeader   sprintf */

nodebug
void __qe(int c, char *buf, int *cnt,  void *instanceParam)
{
	buf[(*cnt)++] = c;
}


/* START FUNCTION DESCRIPTION ********************************************
sprintf                      <STDIO.LIB>

SYNTAX: int sprintf(char *buffer, char *format, ...);

KEYWORDS:

DESCRIPTION:  This function takes a "format" string (pointed to by "format"),
arguments of the format, and output the formatted string to "buffer"
(pointed to by "buffer").  The user should make sure

(1) there are enough arguments after "format" to fill in the format
    parameters in the format string

(2) the types of arguments after "format" match the format fields in
	 "format"

(3) buffer is large enough to hold the longest possible formatted
    string

The following is a short list of possible format parameters in the
format string.  For more details, please refer to any C language
books.

%d    decimal integer (expects type int)
%u    decimal unsigned integer (expects type unsigned int)
%x    hexidecimal integer (expects type signed int or unsigned int)
%s    a string (not interpreted, expects type (char *))
%ls   physical address of NULL terminated string.
%f    a float (expects type float)
%p    a pointer (expects 16-bit pointer)
%lp   a physical pointer (expected 32-bit pointer)

Example: sprintf(buffer,"%s=%x","variable x",256) should put the
string "variable x=100" into buffer.

The macro STDIO_DISABLE_FLOATS can be defined if it is not necessary to format
floating point numbers.  If this macro is defined, %e, %f and %g will not
be recognized. This can save thousands of bytes of code space.

This function can be called by processes of different priorities.

RETURN VALUE: The number of characters written
END DESCRIPTION **********************************************************/
#if !(_SYSTEM)
nodebug
int sprintf(char *buffer, char *format, ...)
{
	auto count, __cnt;
	count = 0;

	doprnt(__qe, format, (char *) ((char *) &format + sizeof (format)), NULL, buffer, &count);
	__cnt = count;
	__qe(0, buffer, &count, NULL);  // Null Terminator
	return __cnt;
}
#endif

/*** BeginHeader _rk_sendstdiohook */
#if _SYSTEM
extern unsigned int _rk_sendstdiohook;
#endif
/*** EndHeader */

#if _SYSTEM
unsigned int _rk_sendstdiohook;
#endif

/*** BeginHeader dkDoMsg */
root void dkDoMsg();
/*** EndHeader */


#asm
dkDoMsg::			;dkDoMsg(char *buffer)
#if (DK_ENABLE_DEBUGKERNEL)
   call   dkSendStdio
   ret
#else
	#if _SYSTEM
	   push	hl
      xor   a
      ld    hl,(_rk_sendstdiohook)
      ld    a,h
      or    l
      pop	hl
      jr    z,._dk_dmdone2		;no app. level call linked in
      push	su
      push	hl
	   ; disable system writes before switching to user mode.
		ld 	a, 1
      ioi 	ld (WPCR), a
		setusr
      ld		ix,(_rk_sendstdiohook)
      ld    de,._dk_dmdone
      push  de
      jp    (ix)
   ._dk_dmdone:
   	add	sp,2
   	pop	su
	   ; re-enable system writes on entry into system.
		xor a
      ioi ld (WPCR), a
   ._dk_dmdone2:
      ret
   #endif
#endif
#endasm

/*** BeginHeader _printf */

int _printf(char *fmt, char *args);

/*** EndHeader */

/***************************************************************************\
   Buffered Printf for Dynamic C
\***************************************************************************/

// This macro should not be defined to be more than 128, as a buffer any larger
// runs the risk of causing target communication problems.
#ifndef STDIO_MAX_PRINTF_BUF_SIZE
	#define STDIO_MAX_PRINTF_BUF_SIZE 128
#endif

nodebug
void __qe2(int c, char *__printfbuf, int *__printfcnt,  void *instanceParam)
{
#ifndef STDIO_ENABLE_LONG_STRINGS
	// No more than STDIO_MAX_PRINTF_BUF_SIZE - 1 bytes will be buffered to be sent.
	// Strings longer than STDIO_MAX_PRINTF_BUF_SIZE - 1 will be truncated.
	if (*__printfcnt < STDIO_MAX_PRINTF_BUF_SIZE - 1)
	{
		__printfbuf[(*__printfcnt)++] = c;
	}
	else
	{
		__printfbuf[STDIO_MAX_PRINTF_BUF_SIZE - 1] = '\0';
	}
#else
	// Treat __printfbuf as a circular buffer, flushing when it is full.  In a
	// multi-tasking application, this can cause output from different tasks to
	// be interleaved if each call to printf is printing > STDIO_MAX_PRINTF_BUF_SIZE - 1
	// bytes.
	if ((*__printfcnt % (STDIO_MAX_PRINTF_BUF_SIZE - 1)) < (STDIO_MAX_PRINTF_BUF_SIZE - 2))
	{
		__printfbuf[((*__printfcnt)++) % (STDIO_MAX_PRINTF_BUF_SIZE - 1)] = c;
	}
	else
	{
		__printfbuf[STDIO_MAX_PRINTF_BUF_SIZE - 2] = c;
		__printfbuf[STDIO_MAX_PRINTF_BUF_SIZE - 1] = '\0';
		(*__printfcnt)++;
#ifdef STDIO_DEBUG_SERIAL
	#ifndef STDIO_DEBUG_FORCEDSERIAL
		if (OPMODE & 0x08)
			dkDoMsg(__printfbuf);  // xmit buffer to stdout window for debug mode
		else
	#endif   //STDIO_DEBUG_FORCEDSERIAL
			_stdioSerialOut(__printfbuf);
#else
		dkDoMsg(__printfbuf);  // xmit buffer to stdout window
#endif
		__printfbuf[0] = 0;
	}
#endif
}

nodebug
int _printf(char *fmt,char *args)
{
	auto int __printfcnt, __cnt;
	auto char __printfbuf[STDIO_MAX_PRINTF_BUF_SIZE];

	__printfcnt = 0;
	doprnt(__qe2, fmt, args, NULL, __printfbuf, &__printfcnt);
	__cnt = __printfcnt;
	__qe2(0, __printfbuf, &__printfcnt, NULL);

   if(__printfbuf[0] != 0)
   {
#ifdef STDIO_DEBUG_SERIAL
#ifndef STDIO_DEBUG_FORCEDSERIAL
		if (OPMODE & 0x08)
			dkDoMsg(__printfbuf);  // xmit buffer to stdout window for debug mode
		else
#endif	//STDIO_DEBUG_FORCEDSERIAL
			_stdioSerialOut(__printfbuf);
#else
		dkDoMsg(__printfbuf);  // xmit buffer to stdout window
#endif
	}
	return __cnt;
}

/*** BeginHeader printf */
#if !(_SYSTEM)
int printf(char *fmt,...);
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
printf                       <STDIO.LIB>

SYNTAX: int printf(char *fmt, ...);

KEYWORDS: display

DESCRIPTION: Similar to sprintf, but outputs the formatted string to the
stdio window in Dynamic C.  Please refer to the description of sprintf for
more details.  This function is task reentrant.

As of Dynamic C 8.50, printf can print more than 127 bytes at a time if the
STDIO_ENABLE_LONG_STRINGS macro is defined.  If this macro is defined in a
multi-tasking application and more than one task is utilizing printf and at
least one task is printing strings longer than 127 bytes, the application will
need to ensure serialization of access to printf (via a semaphore or something
similar) so that printf output from different tasks is not interleaved in the
stdio window.

As of Dynamic C 7.25, it is possible to redirect printf output to a serial
port during run mode by defining a macro to specify which serial port.
See the sample program SAMPLES/STDIO_SERIAL.C for more information.

The macro STDIO_DISABLE_FLOATS can be defined if it is not necessary to format
floating point numbers.  If this macro is defined, %e, %f and %g will not
be recognized. This can save thousands of bytes of code space.

RETURN VALUE: The number of characters written

SEE ALSO :	sprintf

END DESCRIPTION **********************************************************/
#if !(_SYSTEM)
nodebug int printf(char *fmt,...) {
#ifndef STDIO_DEBUG_SERIAL		// don't check OPMODE if sending stdio to serial port
	if(OPMODE&8)  // only use in debug mode
#endif
		return _printf(fmt,((char*)&fmt+sizeof(fmt)));
	return 0;
}
#endif
/*** BeginHeader printfwf */

extern char _comattn;
int printfwf(char *fmt, ...);

/*** EndHeader */

nodebug
int printfwf(char *fmt, ...) {
	if (!LockTestAndSet(&_comattn,1)) return 0;
	else {
		_printf(fmt,((char*)&fmt+sizeof(fmt)));
		return 1;
	}
}

/*** BeginHeader doprnt */

void doprnt(int (*putc)(), char *fmt, void *arg1, void *instanceParam,
            char *buf, int *cnt);

/*** EndHeader   doprnt */

/***************************************************************************\
   DOPRNT - Formatted Output Routine
\***************************************************************************/

/* START FUNCTION DESCRIPTION *********************************************
doprnt                       <STDIO.LIB>

SYNTAX:
   void doprnt(int (*putc)(), char *fmt, void *arg1, void *instanceParam,
               char *buf, int *cnt);

KEYWORDS:

DESCRIPTION: Formatted output routine.  This is the support routine behind
all ...printf routines.  "putc" is a function that outputs one byte, it is
called by doprnt whenever doprnt outputs a character.  "fmt" is the format
string that specifies the output.  "arg1" points to the address of the
first parameter to be used by the formatted string.  The interpretation of
the parameters depends on the format fields in the format string.  This
routine brings in many math functions.

This routine can be called from processes of different priorities.

The macro STDIO_DISABLE_FLOATS can be defined if it is not necessary to format
floating point numbers.  If this macro is defined, %e, %f and %g will not
be recognized. This can save thousands of bytes of code space.

RETURN VALUE: none.
END DESCRIPTION **********************************************************/

// Define STDIO_DISABLE_FLOATS to remove floating-point conversion from
// printf.  This macro can be defined locally within a user program, or globally
// here.

//#define STDIO_DISABLE_FLOATS

union dop_p {
				int         *argptr;
				long int    *largptr;
				float       *fargptr;
				char        **pargptr;
			};      // 8-18-94, aoc

union   rra {
				float       round;
				char        cround[4];
			};      // 8-18-94, aoc

nouseix nodebug
void doprnt(int (*putc)(), char *fmt, void *arg1, void *instanceParam,
            char *buf, int *cnt)
{
	auto union dop_p p;
	auto long int alnum;
	auto int 	lng, width, prec,
					FmtSpecified, temp, j, anum, length;
	auto char code, flag;
	auto char *fptr, *sptr;
	auto int digits;

   /* Long string support vars: */
   auto long 	farstrptr;

   /* Constants: */
// The following array is referenced only by commented out code
//	const static float rounds[9] =
//			 {
//				 .5, .05, .005, .0005, .00005, .000005,
//				 .0000005, .00000005, .000000005
//			 };

	auto union rra r;

	p.argptr = arg1;         // pointer to stack of args
	fptr = fmt;
__DC_loop:
	lng = FmtSpecified = flag = 0;
	prec = -1;

	while((temp = *fptr++) != '%' && temp != 0)
			(*putc) (temp, buf, cnt, instanceParam);
	if (! temp)
		return;
//	__getprtspec();
	if (*fptr == '-' || *fptr == '0')
	{
		flag = *fptr;
		*fptr++;
	}

/* convert width */

	if (*fptr == '*') {
		++fptr;
		width = *p.argptr++;
	} else {
		width = (int) strtol(fptr, &fptr, 10);		//	total length
	}

	if (*fptr == '.')
	{
		++fptr;
		if (*fptr == '*') {
			++fptr;
			prec = *p.argptr++;
			FmtSpecified = 1;
		} else {
			prec = (int) strtol(fptr, &fptr, 10);
				//	places after decimal pt.
			FmtSpecified = 1;              // record that precision specified
		}
	}
	else
	{
		prec = -1;	//	DEFDECDIGITS;
	}

	code = *fptr++;
	if (tolower(code) == 'l')
	{
		lng = 1;
		code = *fptr++;
	}

	switch (code)
	{
		case '%' :
			(*putc) ('%', buf, cnt, instanceParam);
			goto __DC_loop;
		case 's' :
      	if(lng)
         {
         	// XMEM string pointer
            farstrptr = *p.largptr++;
            length = (int) xstrlen( farstrptr );
         }
         else
         {
         	// Root code/data string pointer
				sptr = *p.pargptr++;
				length = strlen(sptr);
         }

			if ((prec>0) && (length > prec))
				 length = prec;
			if (width > length)
				 temp = width - length;
			else
				temp = 0;
			if (flag != '-' && temp > 0)
				outchrs(' ', temp, putc,instanceParam, buf, cnt);

         if(lng)
         {
         	// Read one char at a time from xmem.  Use xgetint() and take
            // only the lower word.  This works OK since the Rabbit is
            // little-endian, this works OK.
         	for( j=0 ; j < length ; ++j )
            {
            	(*putc)((char)xgetint(farstrptr), buf, cnt, instanceParam);
               ++farstrptr;
            }
         }
         else
         {
				for(j = 0; j < length; j++)
					(*putc)(*sptr++, buf, cnt, instanceParam);
         }

			if (flag == '-' && temp > 0)
				outchrs(' ', temp, putc,instanceParam, buf, cnt);
			goto __DC_loop;
		case 'd' :
		case 'u' :
			if (prec<0) prec = 1;
			if (width && (width < prec)) width = prec;
			if (! lng)
				pint(flag, code, width, putc, *p.argptr++,instanceParam, buf, cnt);
			else
				plint(flag, code, width, putc, *p.largptr++,instanceParam, buf, cnt);
			goto __DC_loop;
#ifndef STDIO_DISABLE_FLOATS
		case 'F' :
		case 'f' :
		case 'G' :
		case 'g' :
		case 'E' :
		case 'e' :
			if (prec < 0)
			{
				prec = DEFDECDIGITS;
			}
			r.round = *p.fargptr++;
			// Better to round in function after ftoa conversion (i.e. round the
			//  long) because floating point operations lose precision.
			pflt(flag,
			     code,
			     width,
			     prec,
			     putc,
			     r.round,
			     FmtSpecified,
			     instanceParam,
			     buf,
			     cnt);
			goto __DC_loop;
#endif
      case 'p' : 				// %p is 16-bit pointer, %lp is 32-bit pointer.
      	code = 'X';			// use upper-case hex chars for address.
		case 'X' :
		case 'x' :
			if (prec<0) prec = 1;
			if (width && (prec > width)) width = prec;
			if (!lng)
				phex(flag, width, putc, *p.argptr++,instanceParam, buf, cnt, code);
			else
				plhex(flag, width, putc, *p.largptr++,instanceParam, buf, cnt, code);
			goto __DC_loop;
		case 'c' :
			(*putc) (*p.argptr++, buf, cnt, instanceParam);
			goto __DC_loop;
		default :
			goto __DC_loop;
	}
}

/*** BeginHeader plhex */

void plhex(char left, int n1, int (*putc)(), long int num, void *instanceParam, char *buf, int *cnt, char code);

/*** EndHeader   plhex */

/*=========================================================================*\
 print a long integer in hex
 left == '-' for left justification, else right justification
 n1 is field width, or zero if field width not specified
 putc is a routine called to output chars left to right
 num is the number to be converted - 16 bits
\*=========================================================================*/

/* START _FUNCTION DESCRIPTION ********************************************
plhex                        <STDIO.LIB>

SYNTAX: void plhex(char left, int n1, int (*putc)(), long int num,void *instanceParam, char code);

KEYWORDS:

DESCRIPTION: Prints a long integer in hex.  "left" specifies the padding
character that goes to the left hand side of the actual hexidecimal number.
If "left" is '-', the white space is used as a padding character.  "n1"
is the expected length of the output.  If the number "num" requires more
width than "n1", n1 astrieks will be output.  Otherwise, the padding
character "left" will be used to make up the remaining spaces.  "putc"
is the function used by this function to output one character.  The
function pointed to by "putc" should take a character argument.  "num" is
the number to be converted and output.

This function can be called from processes of different priorities.

RETURN VALUE: none.
END DESCRIPTION **********************************************************/
nodebug useix
void plhex(char left, int n1, int (*putc)(), long int num,void *instanceParam, char* buf, int *cnt, char code)
{
	auto int spaces;
	auto char array[9];         // 8-18-94, aoc     char     array[9];
	auto char *ptr;
	auto int i;

	ptr = (char*)&num;
	for (i=3; i >= 0; --i) {
		if (!i || *(ptr+i)) break;
	}
	if ((unsigned)*(ptr+i) >= 16) {
		i=i*2+1;
		++i;
	} else {
		i = i * 2 + 1;
	}
	spaces = n1 - i;
	hltoa(num, array);
	if (code != 'X')
	{
   	/* Change upper-case hex digits to lower-case. */
		for (i = 0; i < strlen(array); ++i)
		{
			if (array[i] >= 'A' && array[i] <= 'F')
			{
				array[i] += 'a' - 'A';
			}
		}
	}
	if (n1 == 0)
		spaces = 0;             // if width unspecified, no spaces
	if (spaces < 0)
		outchrs('*', n1, putc,instanceParam, buf, cnt); // asterisk fill if no fit
	else if (left == '-')
	{
		outstr(array, putc,instanceParam, buf, cnt);
		outchrs(' ', spaces, putc,instanceParam, buf, cnt);
	}
	else
	{
		outpad(left, spaces, putc,instanceParam, buf, cnt);
		outstr(array, putc,instanceParam, buf, cnt);
	}

}

/*** BeginHeader __divmod10 */
root void __divmod10();
/*** EndHeader */

#asm
;	hl	has the address of the dest (pointing to MSByte)
;	de	has the address of the operand (pointing to MSByte)
;	c has the number of bytes to deal with	(at least one)
;	a returns the result of mod
;	consumes all of af bc de hl, as well as the stuff pointed to by
;	de
;	about 2110 states
__divmod10::
	xor	a			;	4
	ld		b,c
	push	hl
.clrDest:
	ld		(hl),a	;	6
	dec	hl			;	4
	djnz	.clrDest

	pop	hl
	ex		de,hl		;	3

	xor	a			;	4
	sla	(hl)		;	13
	rla				;	3
	sla	(hl)		;	13
	rla				;	4
	sla	(hl)		;	13
	rla				;	4
	ld		b,5		;	6

.dmNextBit:
	sla	(hl)		;	13
	rla				;	4

	sub	0xa		;	6
	jr		nc,.dmFixBit	;	6/8
	add	a,0xa		;	6
.dmFixBit:
	ccf				;	3
	ex		de,hl		;	3
	rl		(hl)		;	13
	ex		de,hl		;	3
	djnz	.dmNextBit	;	7/9
	dec	de			;	4
	dec	hl			;	4
	dec	c			;	4
	ld		b,8		;	6
	jr		nz,.dmNextBit	;	6/8
	ret				;	9
#endasm

/*** BeginHeader ltoa, ltoan, gtoa, gtoan, _gltoa */

char *ltoa(long num, char *ibuf);
int ltoan(long num);
char *gtoa(unsigned long num, char *ibuf);
int gtoan(unsigned long num);
char *_gltoa(unsigned long int num, char *ibuf, char neg);
xmem int _gltoan(unsigned long num, int signed);
/*** EndHeader   ltoa, ltoan */

/*=========================================================================*\
 Convert (un)signed long to ascii. Pass long and pointer to 12 byte field.
 Returns count of digits generated including minus sign if any.
 For example: -500 generates "-500" and returned value of 4.
 Returned string terminated by null. Provide 12 bytes in buf
 for longest possible number.  330 bytes 1.1 millisecond 9mhz 64180.

 *** performance not checked under new version
\*=========================================================================*/

/* START _FUNCTION DESCRIPTION ********************************************
_gltoa                       <STDIO.LIB>

SYNTAX: char *_gltoa(unsigned long int num, char *ibuf, char neg);

KEYWORDS:

DESCRIPTION: Converts (un)signed long to ascii. Passes long and pointer
to 12 byte field. "num" is the unsigned long int to be converted to a
string, "ibuf" is a pointer to the array that will hold the ASCII string
representing "num", and "neg" indicates whether or not "num" should be
displayed as a negative number.  The user should make sure the string
pointed to by "ibuf" is large enough to hold the string.

RETURN VALUE: Pointer to string.
END DESCRIPTION **********************************************************/
nouseix nodebug
char *_gltoa(unsigned long int num, char *ibuf, char neg)
{
	auto unsigned long tmpL;   // 8-18-94, aoc unsigned long thisDigit;
	auto char *beginStr;            // 8-18-94, aoc char *beginStr;

	beginStr = ibuf;
#asm xmemok
	ld		hl,@SP+neg
	add	hl,sp
	ld		a,(hl)
	or		a
	jr		z,.notNeg
	ld		hl,@SP+num
	add	hl,sp       ; low byte of long
	ld    a,(hl)
	inc	hl
	or    (hl)
	inc	hl
	or    (hl)
	ld    b,a         ; toward 0x80000000 special case check
	inc	hl          ; high byte of long
	or    (hl)
	bit	7,(hl)
	jr		z,.notNeg
	res	7,a
	or    b           ; high bit in a could have been from lower bytes
	jr		z,.notNeg    ; don't put '-' for max neg long here
	;	negate the entire number now
	dec	hl
	dec	hl
	dec	hl
	ld		a,(hl)
	cpl
	or		a		;	clear carry
	add	a, 1
;	inc	a
;	jp		novf,noOv	;jump if no overflow
;	scf
;noOv:
	ld		(hl),a
	inc	hl
	ld		a,(hl)
	cpl
	adc	a,0
	ld		(hl),a
	inc	hl
	ld		a,(hl)
	cpl
	adc	a,0
	ld		(hl),a
	inc	hl
	ld		a,(hl)
	cpl
	adc	a,0
	ld		(hl),a

	;	num = -num now

	ld		hl,@SP+ibuf
	add	hl,sp
	push	hl
	ld		b,(hl)
	inc	hl
	ld		h,(hl)
	ld		l,b
	ld		a,'-'
	ld		(hl),a
	inc	hl
	ex		de,hl
	pop	hl
	ld		(hl),e
	inc	hl
	ld		(hl),d
	push	de
	jr		.makeStr

.notNeg:
	ld		hl,@SP+ibuf
	add	hl,sp
	ld		a,(hl)
	inc	hl
	ld		h,(hl)
	ld		l,a
	push	hl

.makeStr:
	ld		hl,@SP+num+3+2	;	point to MSByte
	add	hl,sp
	push	hl
	ld		hl,@SP+tmpL+3+4
	add	hl,sp
	pop	de
	;	now de points to num, hl points to tmpL
	ld		c,4
.anotherDigit:
.findMSB:
	ld		a,(de)
	or		a
	jr		nz,.doIt
	dec	c
	jr		z,.done
	dec	de
	dec	hl
	jr		.findMSB

	;	now we found MSB
.doIt:
	push	de
	push	hl
	push	bc
	call	__divmod10

	ld		hl,@SP+ibuf+8	;	*ibuf++ = regA+'0'
	add	hl,sp
	push	hl
	ld		b,(hl)
	inc	hl
	ld		h,(hl)
	ld		l,b
	add	a,'0'
	ld		(hl),a
	inc	hl
	ex		de,hl
	pop	hl
	ld		(hl),e
	inc	hl
	ld		(hl),d

	pop	bc
	pop	de			;	tricky: we swap de and hl now!
	pop	hl

	;	readjust hl
	jr		.anotherDigit

.done:
	;	all done now
	ld		hl,@SP+ibuf+2
	add	hl,sp
	ld		a,(hl)
	inc	hl
	ld		h,(hl)
	ld		l,a
	pop	de
	push	hl
	;	hl is end, de is beg of numeral string
	xor	a
	sbc	hl,de
	pop	hl
	jr		z,.is0
	push	hl
	dec	hl
	jr		.flip

.is0:
	ld		a,'0'
	ld		(hl),a
	inc	hl
	jr		.putNullEnd

.flip:
	push	hl
	or		a
	sbc	hl,de
	pop	hl
	jr		z,.endFlip
	jr		c,.endFlip
	ld		b,(hl)
	ld		a,(de)
	ex		de,hl
	ld		(de),a
	ld		(hl),b
	ex		de,hl
	dec	hl
	inc	de
	jr		.flip
.endFlip:
	pop	hl
.putNullEnd:
	ld		a,0
	ld		(hl),a
#endasm
	return beginStr;
}

/* returns number of digits needed in field 1-11 for (un)signed long int */

/* START_FUNCTION DESCRIPTION *********************************************
_gltoan                       <STDIO.LIB>

SYNTAX:
   int _gltoan(unsigned long num, int signed);

KEYWORDS:

DESCRIPTION:
   This function determines how many characters (possible sign character
   plus digits) are required for decimal display of the supplied (un)signed
   long integer given the specified signed or unsigned type.

PARAMETER1:
   The possibly signed integer whose decimal display length is to be
   returned.

PARAMETER2:
   1 to specify that the supplied integer's type is signed, or 0 to specify
   unsigned type.

RETURN VALUE:
   The number of characters needed for decimal display of the supplied
   (un)signed long integer, always in the range [1,11].
END DESCRIPTION **********************************************************/

xmem nodebug
int _gltoan(unsigned long num, int signed)
{
	auto int j, len;
	static const unsigned long __ltens[] = { 1000000000ul, 100000000ul,
	                                         10000000ul, 1000000ul, 100000ul,
	                                         10000ul, 1000ul, 100ul, 10ul, 1ul };

	// Initially ignoring the possible sign character, 32-bit (un)signed long
	//  type display may require as many as 10 or as few as 1 decimal digit
	//  characters.
	len = sizeof __ltens / sizeof __ltens[0];
	if (signed && ((long) num < 0L))
	{
		num = labs(num);
		++len;	// add one for the required sign character
	}
	// The j count maximum allows for the minimum 1 digit character required for
	//  decimal display.
	for (j = 0; j < sizeof __ltens / sizeof __ltens[0] - 1; ++j)
	{
		if (__ltens[j] <= num)
		{
			break;
		}
		--len;
	}
	return len;
}

/* START _FUNCTION DESCRIPTION ********************************************
gtoa                         <STDIO.LIB>

SYNTAX: char *gtoa(unsigned long num, char *ibuf);

KEYWORDS:

DESCRIPTION:

RETURN VALUE:
END DESCRIPTION **********************************************************/
nodebug char *gtoa(unsigned long num, char *ibuf)
{
	return _gltoa(num, ibuf, 0);
}

/* START _FUNCTION DESCRIPTION ********************************************
ltoa                         <STDIO.LIB>

SYNTAX: char *ltoa(long num, char *ibuf)

KEYWORDS:

DESCRIPTION:  This function uses _gltoa to output a signed long int "num"
to the character array pointed to by "ibuf".

RETURN VALUE: Pointer to the same array passed in to hold the result.
END DESCRIPTION **********************************************************/
nodebug char *ltoa(long num, char *ibuf)
{
	return _gltoa((unsigned long) num, ibuf, 1);
}


/* returns number of digits needed in field 1-11 for unsigned long int */

/* START _FUNCTION DESCRIPTION ********************************************
gtoan                        <STDIO.LIB>

SYNTAX: int gtoan(unsigned long num);

KEYWORDS:

DESCRIPTION:  This function uses _gltoa to output an unsigned long int
"num" to the character array pointed to by "ibuf"

RETURN VALUE: Pointer to the same array passed in to hold the result.
END DESCRIPTION **********************************************************/
nodebug int gtoan(unsigned long num)
{
	return _gltoan(num, 0);
}

/* START _FUNCTION DESCRIPTION ********************************************
ltoan                        <STDIO.LIB>

SYNTAX: int ltoan(long num)

KEYWORDS:

DESCRIPTION:  This function returns the number of characters required to
display a signed long int "num".

RETURN VALUE: The number of characters to display "num".
END DESCRIPTION **********************************************************/
nodebug int ltoan(long num)
{
	return _gltoan((unsigned long) num, 1);
}

/*** BeginHeader plint */

void plint(char left, char code, int n1, int (*putc) (), long num,void *instanceParam, char *buf, int *cnt);

/*** EndHeader   plint */

/*=========================================================================*\
 print a long integer
 left == '-' for left justification, else right justification
 n1 is field width, or zero if field width not specified
 putc is a routine called to output chars left to right
 num is the number to be converted - 16 bits
\*=========================================================================*/

/* START _FUNCTION DESCRIPTION ********************************************
plint                        <STDIO.LIB>

SYNTAX: void plint(char left, char code, int n1, int (*putc)(), long num,void *instanceParam);

KEYWORDS:

DESCRIPTION:  "left" is the padding character to the left of the number.
"code" indicates how the number is printed.

RETURN VALUE:
END DESCRIPTION **********************************************************/
nodebug useix
void plint(char left, char code, int n1, int (*putc) (), long int num,void *instanceParam, char *buf, int *cnt)
{
	auto int spaces;
	auto char array[14];        // 8-18-94, aoc     char array[14];
	auto char isSigned;

	if (isSigned = ((code | 0x20) == 'd'))
	{
		spaces = n1 - ltoan(labs(num)) - ((num < 0 && num != 0x80000000)?1:0);
		ltoa((num<0)?-num:num, array);
	}
	else
	{
		spaces = n1 - gtoan((unsigned long) num);
		gtoa((unsigned long) num, array);
	}
	if (n1 == 0)
		spaces = 0;          // if field width not specified, no spaces
	if (spaces < 0)
		outchrs('*', n1, putc,instanceParam, buf, cnt);// asterisk fill if no fit
	else if (left == '-')
	{
		if ((num < 0) && isSigned) outchrs('-',1,putc,instanceParam, buf, cnt);
		outstr(array, putc,instanceParam, buf, cnt);
		outchrs(' ', spaces, putc,instanceParam, buf, cnt);
	}
	else
	{
		if (left != '0') outpad(left,spaces,putc,instanceParam, buf, cnt);
		if ((num < 0) && isSigned && array[0] != '-') outchrs('-',1,putc,instanceParam, buf, cnt);
		if (left == '0') outpad(left, spaces, putc,instanceParam, buf, cnt);
		outstr(array, putc,instanceParam, buf, cnt);
	}
}

/* START_FUNCTION DESCRIPTION *********************************************
__ftoa                        <STDIO.LIB>

SYNTAX: int __ftoa(float f, long *rlng);

KEYWORDS: convert

DESCRIPTION:  Converts the floating pointer number "f" to a long
for use by the ftoa function.  This was code was separated out
from ftoa so that pflt can handle mantissa rounding at the integer (long)
level without performing additional string conversions.
This function acts the same as ftoa except that it returns the decimal
exponent of the converted long instead of a pointer to the string.

RETURN VALUE: the decimal exponent of the number.
END DESCRIPTION **********************************************************/

/*** BeginHeader __ftoa */

int __ftoa(float f, long* rlng);

/*** EndHeader */

nodebug
int __ftoa(float f, long* rlng)
{
/* index on upper 4 bits of exponent */
	auto float tmp;
	auto float mant;

/* adjustment to 10's exponent for each */

	/* log base 2 of 10 to find magnitude of 10's exponent */
	const static float lg_2_10 = 3.321928094887;

	auto int sgn, texp;
	auto int exp,exp2,exp10,i;
	auto unsigned long int lng,chg;
	auto long int slng; //signed long to pass value to _gltoa

	exp10 = sgn = 0;
	if (f < 0.0)
	{
		f = - f;
		sgn = 1;
	}
	// 0 is special case handle separately
	if (f == 0.0)
	{
		exp10 = 0;
		sgn = 0;
		lng = 0;
		goto __DC_loop2;
	}
#asm xmemok
c		f;
	   rl       c
	   rl       b              ; shift to get exp to b
		ld      hl, exp2+@SP    ; 8-18-94, aoc changed slightly eff
		add     hl, sp          ; 8-18-94, aoc
		ld      (hl), b         ; 8-18-94, aoc
		inc     hl              ; 8-18-94, aoc
		ld      (hl), 0         ; 8-18-94, aoc
#endasm
	exp2 = exp2-127-28;
	exp10 = (int)(((float)exp2)/lg_2_10);

// normalize the mantissa to the 2^28
	mant = f;
#asm xmemok
c	mant;
	set   7, c				;set bit high (implicit) bit
	ld		hl, mant+@SP+3	;start at MSB
	add	hl, SP
	ld		(hl), 0x4B		;make exponent 24 and ignore sign
	dec	hl
	ld		(hl), c
#endasm

	lng = (unsigned long) mant;
	lng <<= 4;
	chg=0;  // extra precision bits
	if(exp2 > 0) {
		texp = exp10;
		for(i = 0; i < exp2; i++) {
			while(lng > 214748364)  {
				texp--;
				chg /=10;
				chg += lng % 10 * 1000000;
				lng /= 10; // code in assembly later to optimize
			}
			lng <<= 1;
			chg <<= 1;
			if(chg > 10000000) {
				lng++;
				chg-=10000000;
			}
		}
		while(texp > 0) {
			texp--;
			lng+=5;
			lng /= 10;
		}
		// add any difference of 10s exponent to exp10; for some numbers texp will be neg
		exp10 -= texp;
	}
	else {
		f;
		texp=exp2;
		for(i = exp10;  i < 0; i++) {
			while(lng > 42949672 && texp < 0) {
				texp++;
				chg >>= 1;
				if(lng&1) {
					chg += 5000000;
				}
				lng >>= 1;
			}
			lng*=10;
			chg*=10;
			lng += chg/10000000;
			chg %= 10000000;
		}
		while(texp < 0) {
			texp++;
			lng >>= 1;
		}
	}
	if (0x80000000 & lng) {
		lng/=10;
		exp10++;
	}
	__DC_loop2:
	if(rlng != NULL) {
		if (sgn)
			*rlng = - lng;
		else
			*rlng = lng;
	}
	else // abort?? null pointer passed
		*rlng;
	return (exp10);

}


/*** BeginHeader ftoa */

int ftoa(float f, char *buf);

/*** EndHeader */

/*=========================================================================*\
 convert a floating number to character string
 places signed string in buf no more than 12 chars long
 and returns exponent as for 10**n
\*=========================================================================*/

/* START _FUNCTION DESCRIPTION ********************************************
ftoa                         <STDIO.LIB>

SYNTAX: int ftoa(float f, char *buf);

KEYWORDS: convert

DESCRIPTION:  Converts the floating pointer number "f" to a character
string into "buf".  The string is no longer than 12 characters long.
The character string only displays the mantissa up to 12 digits, no
decimal points.  The function returns the exponent (of 10) that should
be used to compensate for the string.  I.e., ftoa(1.0,buf) yields
buf="1000000000", and returns -10.

RETURN VALUE: the exponent of the number.
END DESCRIPTION **********************************************************/

nodebug
int ftoa(float f, char *buf){
	auto long slng;
	auto int e;
	e = __ftoa(f,&slng);
	_gltoa((unsigned long)slng, buf, 1);
	return e;
}



/*** BeginHeader outpad */
void outpad(char left, int count, int (*putc) (),void *instanceParam, char *buf, int *cnt);
/*** EndHeader outpad */

nodebug
void outpad(char left, int count, int (*putc) (),void *instanceParam, char *buf, int *cnt)
{
	auto char k;            // 8-18-94, aoc     char k;

	if (left == '0')
		k = '0';
	else
		k = ' ';
	outchrs(k, count, putc, instanceParam, buf, cnt);
}

/*** BeginHeader phex */

void phex(char left, int n1, int (*putc) (), int num, void *instanceParam, char *buf, int *cnt, char code);

/*** EndHeader   phex */

/*=========================================================================*\
 print an integer in hex
 left == '-' for left justification, else right justification
 n1 is field width, or zero if field width not specified
 putc is a routine called to output chars left to right
 num is the number to be converted - 16 bits
\*=========================================================================*/

/* START _FUNCTION DESCRIPTION ********************************************
phex                         <STDIO.LIB>

SYNTAX: void phex(char left, int n1, int (*putc) (), int num, void *instanceParam, char code);

KEYWORDS:

DESCRIPTION:  Similar to plhex, except this function prints the hex.
representation for an int or unsigned int.  Please refer to the
description of plhex for details.

RETURN VALUE: none.
END DESCRIPTION **********************************************************/
nodebug useix
void phex(char left, int n1, int (*putc) (), int num, void *instanceParam, char *buf, int *cnt, char code)
{
	auto int spaces;
	auto char array[5];         // 8-18-94, aoc     char array[5];
	auto int i;

	spaces = n1 - (((unsigned)num < 16) ? 1 :
						((unsigned)num < 256) ? 2 :
						((unsigned)num < 4096) ? 3 : 4);
	htoa(num, array);
	if (code != 'X')
	{
   	/* Convert upper-case hex digits to lower-case. */
		for (i = 0; i < strlen(array); ++i)
		{
			if (array[i] >= 'A' && array[i] <= 'F')
			{
				array[i] += 'a' - 'A';
			}
		}
	}
	if (n1 == 0)
		spaces = 0;          // if field width not specified, no spaces
	if (spaces < 0)
		outchrs('*', n1, putc,instanceParam, buf, cnt);// asterisk fill if no fit
	else if (left == '-')
	{
		outstr(array, putc,instanceParam, buf, cnt);
		outchrs(' ', spaces, putc,instanceParam, buf, cnt);
	}
	else
	{
		outpad(left, spaces, putc,instanceParam, buf, cnt);
		outstr(array, putc,instanceParam, buf, cnt);
	}
}

/*** BeginHeader pint */

xmem void pint(char left, char code, int n1, int (*putc)(), int num,
               void *instanceParam, char *buf, int *cnt);

/*** EndHeader */

/*=========================================================================*\
 print an integer
 left == '-' for left justification, 0 for left zero pad,
 else right justification
 code == 'd' or 'D' for signed int, else unsigned
 n1 is field width, or zero if field width not specified
 putc is a routine called to output chars left to right
 num is the number to be converted - 16 bits
\*=========================================================================*/

/* START _FUNCTION DESCRIPTION ********************************************
pint                         <STDIO.LIB>

SYNTAX: void pint(char left, char code, int n1, int (*putc) (), int num, void *instanceParam);

KEYWORDS:

DESCRIPTION:  Similar to plint, except this function outputs int or
unsigned ints.  Please refer to plint for details.

RETURN VALUE: none.
END DESCRIPTION **********************************************************/
nodebug useix
xmem void pint(char left, char code, int n1, int (*putc)(), int num,
               void *instanceParam, char *buf, int *cnt)
{
	auto int spaces;
	auto char array[7];         // 8-18-94, aoc     char array[7];
	auto char isSigned;

	if (isSigned = ((code | 0x20) == 'd'))
	{
		spaces = n1 - itoan(abs(num))-((num<0 && (num != 0x8000))?1:0);
		itoa(abs(num), array);
	}
	else
	{
		spaces = n1 - utoan(num);
		utoa(num, array);
	}
	if (n1 == 0)
		spaces = 0;          // if field width not specified, no spaces
	if (spaces < 0)
		outchrs('*', n1, putc,instanceParam, buf, cnt);// asterisk fill if no fit
	else if (left == '-')
	{
		if ((num < 0) && isSigned) outchrs('-',1,putc,instanceParam, buf, cnt);
		outstr(array, putc, instanceParam, buf, cnt);
		outchrs(' ', spaces, putc, instanceParam, buf, cnt);
	}
	else
	{
		if (left != '0') outpad(left,spaces,putc,instanceParam, buf, cnt);
		// array check fixes problem with double minus sign (-32768)
		if ((num < 0) && isSigned && array[0] != '-') outchrs('-',1,putc, instanceParam, buf, cnt);
		if (left == '0') outpad(left, spaces, putc, instanceParam, buf, cnt);
		outstr(array, putc, instanceParam, buf, cnt);
	}
}

/*** BeginHeader pflt */

xmem void pflt(char left, char fmtS, int lenTotal, int digAfterDecPt,
               int (*putc)(), float f, int precSpecified, void *instanceParam,
               char *buffer, int *cnt);

/*** EndHeader   pflt */

/*=========================================================================*\
   PFLT - Formatted Output of Floating Point Numbers
\*=========================================================================*/

/* START_FUNCTION DESCRIPTION *********************************************
pflt                          <STDIO.LIB>

SYNTAX:
   void pflt(char left, char fmtSpec, int lenTotal, int digAfterDecPt,
             int (*putc)(), float f, int precSpecified,
             void *instanceParam, char *buffer, int *cnt);

KEYWORDS:

DESCRIPTION:
   This function outputs the ASCII decimal representation of a floating
   point number using the passed in function pointer, "putc".

PARAMETER1:
   "left" is the filler character to the left of the number.

PARAMETER2:
   "code" specifies how the floating point number should be printed.

PARAMETER3:
   "lenTotal" when non-zero is the maximum total length of the output.

PARAMETER4:
   "digAfterDecPt" optionally specifies the output precision, as the number
   of digits following the decimal point.

PARAMETER5:
   "putc" is the single character output function pointer.

PARAMETER6:
   "f" is the floating point value to be output in ASCII decimal
   representation.

PARAMETER7:
   "precSpecified" true (nonzero) indicates that "digAfterDecPt" should be
   used as the output precision. When "precSpecified" is zero the default
   output precision is 6 digits following the decimal point.

PARAMETER8:
   "instanceParam" when non-NULL is a pointer to an object, such as a data
   structure or a buffer limit down counter, that the particular instance
   of the putc function requires as a parameter. Note that "instanceParam"
   is used only as a parameter that is passed either directly or indirectly
   to putc.

PARAMETER9:
   "buffer" is a pointer to the output buffer. Note that "buffer" is used
   only as a parameter that is passed either directly or indirectly to
   putc.

PARAMETER10:
   "cnt" is a pointer to the count of output characters. Note that "cnt" is
   used only as a parameter that is passed either directly or indirectly to
   putc.

RETURN VALUE:
   None.
END DESCRIPTION **********************************************************/

#define DEFMANTISSA 12
#define _LENOUT_FOR_E_FORMAT_SPECIFIER_ \
        (sgnM + digPreDecPt + (digPostDecPt > 0) + digPostDecPt + 2 + \
         ((2 > lenE) ? 2 : lenE))
#define _LENOUT_FOR_F_FORMAT_SPECIFIER_ \
        (sgnM + digPreDecPt + (digPostDecPt > 0) + digPostDecPt)

nouseix nodebug
xmem void pflt(char left, char fmtSpec, int lenTotal, int digAfterDecPt,
               int (*putc)(), float f, int precSpecified, void *instanceParam,
               char *buffer, int *cnt)
{
	auto char buf[DEFMANTISSA + 30], padC;
	auto int expD, lenE, lenM, lenOut, lenPad, nPow, sgnE, sgnM, temp, xFmtS;
	auto int digIndex, digPostDecPt, digPreDecPt;
	auto int firstDigitIsZero, maxCalcRecalcCnt, okToRound, omitTrailingZeros;
	auto long sLng;
	const static long round[] = { 500000000L, 50000000L, 5000000L, 500000L,
	                              50000L, 5000L, 500L, 50L, 5L };

	// get the decimal exponent of sLng (which is converted from f's mantissa)
	nPow = __ftoa(f, &sLng);
	// an initial calculation followed by a recalculation is the maximum allowed
	maxCalcRecalcCnt = 2;
	// only on the first time through is it OK to round the converted sLng value
	okToRound = 1;
	while (0 < maxCalcRecalcCnt)
	{
		// reset or set the mantissa's sign flag as appropriate to sLng (and to f)
		sgnM = sLng < 0L;
		// get the output length of sLng's (i.e. f's mantissa's) absolute value
		lenM = _gltoan((unsigned long) labs(sLng), 0);
		// calculate f's actual (i.e. "x.y * 10^^z" format) decimal exponent
		expD = nPow + lenM - 1;
		// reset or set the exponents's sign flag as appropriate to f
		sgnE = expD < 0;
		// get the output length of f's decimal exponent's absolute value
		lenE = _gltoan((unsigned long) abs(expD), 0);
		// set the post decimal point precision (initial value, may change later)
		digPostDecPt = (precSpecified) ? digAfterDecPt : DEFDECDIGITS;

		xFmtS = fmtSpec;
		if (tolower(xFmtS) == 'g')
		{	// 'G' and 'g' always omit trailing zeros following the decimal point,
			//  and will also omit the decimal point on whole numbers.
			omitTrailingZeros = 1;
			// 'G' or 'g': Use 'E' or 'e' (respectively) if decimal exponent < -4
			//  or if decimal exponent >= output precision.
			if (-4 > expD || expD >= digPostDecPt)
			{	// convert 'G' to 'E' or 'g' to 'e'
				//  (assumes ASCII-like ordering of upper and lower case letters)
				xFmtS -= 'g' - 'e';
			}
			else
			{	// convert 'G' to 'F' or 'g' to 'f'
				//  (assumes ASCII-like ordering of upper and lower case letters)
				xFmtS -= 'g' - 'f';
			}
		}
		else
		{	// 'E' or 'e' or 'F' or 'f' never omit trailing zeros following the
			//  decimal point.
			omitTrailingZeros = 0;
		}
		switch (xFmtS)
		{
		case 'E':	// [-]d[.dd*]E(+-)dd[d*]
		case 'e':	// [-]d[.dd*]e(+-)dd[d*]
			// 'E' and 'e' format specifiers have exactly 1 non-zero decimal digit
			//  to the left of the decimal point.
			firstDigitIsZero = 0;
			digPreDecPt = 1;
			// maximum output length is [-]d[.dd*]E(+-)dd[d*] or [-]de(+-)dd[d*]
			lenOut = _LENOUT_FOR_E_FORMAT_SPECIFIER_;
			if (0 < lenTotal && lenTotal < lenOut)
			{	// 'E' or 'e' output must be truncated to fit the specified field
				//  width and the mantissa is the only possibility for truncation.
				digPostDecPt -= lenOut - lenTotal;
				digPostDecPt = (digPostDecPt < 0) ? 0 : digPostDecPt;
				// recalculate the output length
				lenOut = _LENOUT_FOR_E_FORMAT_SPECIFIER_;
			}
			break;
		case 'F':	// [-]dd*[.dd*]
		case 'f':	// [-]dd*[.dd*]
			// 'F' and 'f' format specifiers have at least 1 decimal digit to the
			//  left of the decimal point.
			firstDigitIsZero = 0 > expD;
			digPreDecPt = firstDigitIsZero ? 1 : 1 + expD;
			// maximum output length is [-]dd*[.dd*]
			lenOut = _LENOUT_FOR_F_FORMAT_SPECIFIER_;
			if (0 < lenTotal && lenTotal < lenOut)
			{	// 'F' or 'f' output must be truncated to fit the specified field
				//  width and the mantissa is the only possibility for truncation.
				digPostDecPt -= lenOut - lenTotal;
				digPostDecPt = (digPostDecPt < 0) ? 0 : digPostDecPt;
				// recalculate the output length
				lenOut = _LENOUT_FOR_F_FORMAT_SPECIFIER_;
			}
			break;
		default:
#ifdef STDIO_VERBOSE
			printf("\npflt() format specifier error! (How is this possible?)\n");
#endif
			//break;
		}

		// Was sLng already rounded on a previous pass through this part of pflt?
		if (okToRound)
		{	// No, but we must prevent re-rounding in case there's another pass.
			okToRound = 0;
			// Calculate the index into the rounding array.
			temp = (firstDigitIsZero ? 0 : digPreDecPt) + digPostDecPt +
			       (sizeof round / sizeof round[0] - lenM);
			// Is the output precision within range of a long round value?
			if (0 <= temp && sizeof round / sizeof round[0] > temp)
			{	// Within range, so round sLng to suit the output precision.
				if (sgnM)
				{	// f is a negative number
					sLng -= round[temp];
				}
				else
				{	// f is a non-negative number
					sLng += round[temp];
				}
				// Did rounding change the mantissa length?
				if (_gltoan((unsigned long) labs(sLng), 0) == lenM)
				{	// No, we're done with output precision calculations.
					break;
				}
			}
		}
		// If we get here  at all (see the "rounding" break immediately above)
		//  then we've got one less calculation / recalculation pass to go.
		--maxCalcRecalcCnt;
	}

	// Convert the long mantissa's absolute value to a string mantissa.
	_gltoa((unsigned long) labs(sLng), buf, 0);

	// May trailing zeros to the right of the decimal point, if any, be omitted?
	if (omitTrailingZeros && 0 < digPostDecPt)
	{	// Yes, omit trailing zeros (if any) by adjusting both digPostDecPt and
		//  lenOut to suit.
		// First, calculate the difference between the total output digits length
		//  and the buffered mantissa length (and accounting for a possible
		//  significant leading zero digit that is not in the mantissa buffer).
		temp = digPreDecPt + digPostDecPt - firstDigitIsZero - lenM;
		// Is the mantissa length shorter than the total output digits length?
		if (0 < temp)
		{	// Yes, immediately truncate the excess trailing zero digits. (At most,
			//  we truncate all of the digits after the decimal point.)
			temp = (temp < digPostDecPt) ? temp : digPostDecPt;
			digPostDecPt -= temp;
			lenOut -= temp;
		}
		// Now calculate the zero-based index of the remaining least significant
		//  buffered mantissa digit.
		temp = digPreDecPt + digPostDecPt - firstDigitIsZero - 1;
		// Account for possible zeros between decimal point and mantissa.
		if (-1 > expD && 'f' == tolower(xFmtS))
		{
			temp -= abs(expD) - 1;
		}
		// Now truncate buffered trailing zero digits, if any, one at a time from
		//  right to left.
		while (0 < digPostDecPt && 0 <= temp && ('0' == buf[temp]))
		{
			--digPostDecPt;
			--lenOut;
			--temp;
		}
		// Have we omitted all digits after the decimal point?
		if (!digPostDecPt)
		{	// Yes, so omit the decimal point, too.
			--lenOut;
		}
	}

	// Is there a specified field width?
	if (0 < lenTotal)
	{	// Yes, field width is specified. Will the output length fit?
		if (lenTotal < lenOut)
		{	// Won't fit, output the field width as '*' characters, then return.
			outchrs('*', lenTotal, putc, instanceParam, buffer, cnt);
			return;
		}
		// Calculate the (left or right) padding length.
		lenPad = lenTotal - lenOut;
		// Is padding required?
		if (lenPad > 0)
		{	// Is this field not left justified?
			if ('-' != left)
			{	// Yes, it's not left justified. Is it zero-padded on the left?
				if ('0' == left)
				{	// Yes, zero padded on the left. Is f negative?
					if (sgnM)
					{	// Yes, f is negative, output the sign character now.
						(*putc)('-', buffer, cnt, instanceParam);
						// Prevent unwanted subsequent sign character output.
						sgnM = 0;
					}
					padC = '0';
				}
				else
				{
					padC = ' ';
				}
				// Left pad with one or more (zero or space) characters.
				outchrs(padC, lenPad, putc, instanceParam, buffer, cnt);
			}
		}
	}

	// Is f negative and the leading sign character hasn't already been output?
	if (sgnM)
	{	// Yes, output the mantissa's sign character now.
		(*putc)('-', buffer, cnt, instanceParam);
	}

	// Is the first decimal digit a zero, separate from the digits buffer?
	if (firstDigitIsZero)
	{	// Yes, output the zero character now and decrement the 'before' count.
		(*putc)('0', buffer, cnt, instanceParam);
		--digPreDecPt;
	}

	// initialize the decimal digits buffer index
	digIndex = 0;
	while (0 < digPreDecPt)
	{	// Output any / all remaining digits before the decimal point.
		// Do any buffered decimal digits remain?
		if (0 < lenM)
		{	// Yes, output from the decimal digits buffer.
			(*putc)(buf[digIndex], buffer, cnt, instanceParam);
			--digPreDecPt;
			++digIndex;
			--lenM;
		}
		else
		{	// No decimal digits remain, output the trailing zero characters.
			outchrs('0', digPreDecPt, putc, instanceParam, buffer, cnt);
			digPreDecPt = 0;
		}
	}
	// Any digits following the decimal point?
	if (0 < digPostDecPt)
	{	// Yes, output the decimal point now.
		(*putc)('.', buffer, cnt, instanceParam);
		// Is the decimal exponent < -1 and is this 'F' or 'f' format?
		if (-1 > expD && 'f' == tolower(xFmtS))
		{	// Yes, output the significant leading zero characters, the count of
			//  which is one less than the absolute value of the decimal exponent.
			//  (E.g. 1e-2 == 0.01 where there is one significant leading zero to
			//  the right of the decimal point.)
			temp = abs(expD) - 1;
			temp = (temp < digPostDecPt) ? temp : digPostDecPt;
			outchrs('0', temp, putc, instanceParam, buffer, cnt);
			digPostDecPt -= temp;
		}
		while (0 < digPostDecPt)
		{	// Output any / all remaining digits after the decimal point.
			// Do any buffered decimal digits remain?
			if (0 < lenM)
			{	// Yes, output from the decimal digits buffer.
				(*putc)(buf[digIndex], buffer, cnt, instanceParam);
				--digPostDecPt;
				++digIndex;
				--lenM;
			}
			else
			{	// No decimal digits remain, output the trailing zero characters.
				outchrs('0', digPostDecPt, putc, instanceParam, buffer, cnt);
				digPostDecPt = 0;
			}
		}
	}

	// Is this an 'E' or 'e' format specification?
	if ('e' == tolower(xFmtS))
	{	// Yes, output the exponent part now.
		// convert the int exponent's absolute value to a string exponent
		_gltoa((unsigned long) abs(expD), buf, 0);
		// output the 'E' or 'e' exponent character
		(*putc)((char) xFmtS, buffer, cnt, instanceParam);
		// re-use padC as the exponent's sign character and output it
		padC = sgnE ? '-' : '+';
		(*putc)(padC, buffer, cnt, instanceParam);
		// Is the exponent length less than 2?
		if (2 > lenE)
		{	// Yes, left pad the exponent with a single zero character.
			(*putc)('0', buffer, cnt, instanceParam);
		}
		// output the remainder of the string exponent
		outstr(buf, putc, instanceParam, buffer, cnt);
	}

	// Is a field width specified and padding required for left justified output?
	if (0 < lenTotal && 0 < lenPad && '-' == left)
	{	// Yes, output the right-side padding space characters.
		outchrs(' ', lenPad, putc, instanceParam, buffer, cnt);
	}
}

/*** BeginHeader itoa */

root char *itoa(int value, char *buf);

/*** EndHeader   itoa */

/* START FUNCTION DESCRIPTION ********************************************
itoa                         <STDIO.LIB>

SYNTAX: char *itoa(int value, char *buf);

KEYWORDS: string

DESCRIPTION: Places up to 5 digit character string at *buf, representing
value of signed number, with minus sign in first place, when appropriate.
Supresses leading zeros, but leaves one zero digit for value = 0. Max =
65535. 73 program bytes. Executes in about 200us on 9 mhz hd64180.

RETURN VALUE: pointer to the end (null terminator) of the string in buf.
END DESCRIPTION **********************************************************/
#asm nodebug

; 153 bytes, 3 routines
;
; char *itoa(int value, char *buf)
; same as utoa below, but places minus sign first in buffer if neg

itoa::
	   pop      bc                ; ret
	   pop      de                ; value
	   pop      hl                ; pointer
	   ld       a,d
	   or       a
	   jp       p,.itoa2           ; not neg
	   res      7,a
	   or       e
	   jp       z,.itoa2           ; max neg int
	   ld       a,e
	   cpl
	   ld       e,a
	   ld       a,d
	   cpl
	   ld       d,a
	   inc      de                ; de neg value
	   ld       (hl),'-'          ; minus to buffer
	   inc      hl
.itoa2:
	   push     hl
	   push     de
	   push     bc
	   jp       utoa              ; continue as unsigned

#endasm

/*** BeginHeader utoa, utoan, itoan */

root char *utoa(unsigned value, char *buf);
root int utoan(int num);
root int itoan(int num);

/*** EndHeader   utoa */

/* START _FUNCTION DESCRIPTION ********************************************
utoa                         <STDIO.LIB>

SYNTAX: char *utoa(unsigned value, char *buf);

KEYWORDS: string

DESCRIPTION: Places up to 5 digit character string at *buf representing
value of unsigned number.  Supresses leading zeros, but leaves one zero
digit for value = 0. Max = 65535. 73 program bytes. Executes in about
200us on 9 mhz hd64180.

RETURN VALUE: Pointer to null at end of string.
END DESCRIPTION **********************************************************/

const unsigned short _tens[] = {10000,1000,100,10,1};

#asm nodebug

; char *utoa(unsigned int value, char *buf )
; places up to 5 digit character string at *buf representing
; value of unsigned number. returns pointer to null at end of string.
; supresses leading zeros. places one zero digit for zero. max 65535.
; 73 program bytes. Exectes in about 200us on 9 mhz hd64180.

utoa::
	  pop      bc                ; return
	  pop      hl                ; value
	  exx
	  pop      hl                ; pointer to buf
	  ld       de,_tens         ; pointer to power of tens
	  ld       c,0               ; c' is first non zero flag
	  exx
	  push     hl
	  push     hl
	  push     bc                ; return
; hl value, hl' pointer to buf, de' pointer to tens, c' nozero flag
	  ld       b,5               ; number of steps
__DC_loop:  exx
	  ld       a,(de)            ; get power of ten
	  inc      de
	  exx
	  ld       e,a               ; to de
	  exx
	  ld       a,(de)
	  inc      de
	  exx
	  ld       d,a             ; de is power of 10
	  or       a                 ; clc
	  ld       c,-1              ; digit
.loopi:
	  inc      c                 ; digit
	  sbc      hl,de             ; sub a power of ten
	  jp       nc,.loopi          ; carry means done
	  add      hl,de             ; restore value
; c has digit
	  ld       a,c
	  exx
	  or       c                 ; first nonzero flag
	  ld       c,a               ; save
	  exx
	  jr       z,__DC_loop2           ; if digit not encountered yet
	  ld       a,c               ; digit
	  add      a,'0'             ; to ascii
	  exx
	  ld       (hl),a            ; to *buf++
	  inc      hl
	  exx
__DC_loop2:
	  djnz     __DC_loop              ; do 5 times b=b-1
	  exx
	  ld       a,c
	  or       c                 ; any digits in entire process
	  jr       nz,.loop3          ; yes
	  ld       a,'0'
	  ld       (hl),a            ; put one zero if none at all
	  inc      hl
.loop3:
	  xor      a
	  ld       (hl),a            ; term null
	  ret                        ; pass pointer back in hl

; returns number of digits needed to express unsigned int
; never less than 1
; int utoan(int num)

utoan::
	  ld       b,5               ; max possible
	  ld       iy,_tens         ; pointer to array
.utoan1:
	  ld       e,(iy)
	  inc      iy
	  ld       d,(iy)
	  inc      iy
	  push     hl
	  or       a
	  sbc      hl,de
	  pop      hl
	  jr       nc,.utoan3         ; if hl>= tenpower, need this many digs
	  djnz     .utoan1            ; loop
	  inc      b                 ; at least 1 digit
.utoan3:
	  ld       l,b               ; count
	  ld       h,0               ; return in hl
	  ret

; routine to return number of digits in signed integer
; same as utoan, but one more for sign

itoan::
	  bit      7,h
	  jr       z,utoan           ; unsigned
	  ex       de,hl
	  ld       hl,0
	  or       a
	  sbc      hl,de             ; negate
	  call     utoan
	  inc      hl                ; 1 more for sign
	  ret

#endasm

/*** BeginHeader htoa, hltoa */

root char *htoa(int value, char *buf);
root char *hltoa(long int value, char *buf);
/*** EndHeader   htoa */

/* START _FUNCTION DESCRIPTION ********************************************
htoa                         <STDIO.LIB>

SYNTAX: char *htoa(int value, char *buf);

KEYWORDS: math

DESCRIPTION: Converts integer "value" to hex number and put result into
"buf".

RETURN VALUE: Pointer to end (null terminator) of string in buf.
END DESCRIPTION **********************************************************/
#asm nodebug

; convert integer to hex number
; char * htoa(int value, char *buf)

._ls4:
		ld		b,4
._lsloop:
		or		a
		rl		e
		rl		d
		djnz	._lsloop
		ret

htoa::
	   ex       de,hl
	   ld       hl,4
	   add      hl,sp
	   ld       a,(hl)
	   inc      hl
	   ld       h,(hl)
	   ld       l,a               ; pointer to output buf
.htoa0:
	   ld			a,d
	   cp			010h
	   jr			c,._3orLess
	   ld			c,4
	   jr			.htoa1

._3orLess:
		call		._ls4
		ld			a,d
		cp			010h
		jr			c,._2orLess
		ld			c,3
		jr			.htoa1

._2orLess:
		call		._ls4
		ld			a,d
		cp			010h
		jr			c,._1
		ld			c,2
		jr			.htoa1
._1:
		call		._ls4
		ld			c,1
.htoa1:
	   ld       b,4               ; shift count
	   ld       a,0
.htoa2:
	   rl       e
	   rl       d
	   rla
	   djnz     .htoa2
	   cp       10
	   jr       c,.htoa3           ; 0-9
	   add      a,'A'-10
	   jr       .htoa4
.htoa3:
	   add      a,'0'
.htoa4:
	   ld       (hl),a
	   inc      hl
	   dec      c
	   jr       nz,.htoa1          ; 4 hex digits
	   ld       (hl),0            ; terminal null
	   ret

; char * hltoa(long int value, char *buf)
; convert long to hex

hltoa::
	   ld       hl,6
	   add      hl,sp
	   ld       a,(hl)
	   inc      hl
	   ld       h,(hl)
	   ld       l,a               ; pointer to buffer now in hl
	   push     de                ; save least
	   push     hl                ; pointer
	   ld       d,b
	   ld			a,d
	   ld       e,c               ; arg must be in hl too
	   or			e
	   jr			z,.lobyteonly
	   call     .htoa0          ; 4 digits, hl returns pointer
	   pop      bc                ; clean stack
	   pop      de                ; next 16 bits
		ld			c,4
	   call     .htoa1
	   ret

.lobyteonly:
		pop		bc
		pop		de
		call		.htoa0
		ret
#endasm

/*** BeginHeader outchrs */
root char outchrs(char c, int n, int (*putc)(), void *instanceParam, char *buf,
                  int *cnt);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
outchrs                      <STDIO.LIB>

SYNTAX:
   char outchrs(char c, int n, int (*putc)(), void *instanceParam,
                char *buf, int *cnt);

KEYWORDS:

DESCRIPTION:  Use "putc" to output "n" times the character "c".  The
function pointed to by "putc" should take a character parameter.

RETURN VALUE: The character in parameter "c".
END DESCRIPTION **********************************************************/

nodebug root
char outchrs(char c, int n, int (*putc)(), void *instanceParam, char *buf,
             int *cnt)
{
#asm xmemok
.repeatOut:
	ld		hl,@SP+n
	add	hl,sp
	ld		e,(hl)
	inc	hl
	ld		d,(hl)
	ld		a,d
	or		a
	jp		m, .endFunc				; negative count, nothing to do!
	or		e
	jr		z, .endFunc				; zero count, nothing to do!

	dec	de
	ld		(hl),d
	dec	hl
	ld		(hl),e

	ld		hl,@SP+instanceParam
	add	hl,sp
	ld		e,(hl)
	inc	hl
	ld		d,(hl)
	push	de

   ld		hl,@SP+cnt+2
   add	hl,sp
   ld		e,(hl)
   inc	hl
   ld		d,(hl)
   push	de

   ld		hl,@SP+buf+4
   add	hl,sp
   ld		e,(hl)
   inc	hl
   ld		d,(hl)
   push	de

	ld		hl,@SP+c+6
	add	hl,sp
	ld		e,(hl)
	inc	hl
	ld		d,(hl)
	push	de

	ld		de,.retAddr
	push	de

	ld		hl,@SP+putc+10
	add	hl,sp
	ld		a,(hl)
	inc	hl
	ld		h,(hl)
	ld		l,a
	jp		(hl)
.retAddr:
	pop	bc
	pop	bc
	pop 	bc
	pop   bc
	jr		.repeatOut
.endFunc:
#endasm
	return c;
}

/*** BeginHeader outstr */
char *outstr(char *string, int (*putc)(), void *instanceParam, char *buf,
             int *cnt);
/*** EndHeader */

/* START_FUNCTION DESCRIPTION *********************************************
outstr                       <STDIO.LIB>

SYNTAX:
   char *outstr(char *string, int (*putc)(), void *instanceParam,
                char *buf, int *cnt);

KEYWORDS:

DESCRIPTION: Output the string pointed to by "string" via calls to "putc".
"putc" should take one character parameter.

RETURN VALUE: Pointer to null at end of string.
END DESCRIPTION **********************************************************/

nodebug
char *outstr(char *string, int (*putc)(), void *instanceParam, char *buf,
             int *cnt)
{
	auto char *ptr;
	ptr = string;

#asm xmemok
.repeatOut:
	ld		hl,@SP+ptr
	add	hl,sp
	ld		e,(hl)
	inc	hl
	ld		d,(hl)
	ld		a,(de)
	or		a
	jr		z,.endFunc

	inc	de
	ld		(hl),d
	dec	hl
	ld		(hl),e

	ld		hl,@SP+instanceParam
	add	hl,sp
	ld		e,(hl)
	inc	hl
	ld		d,(hl)
	push	de

	ld		hl,@SP+cnt+2
   add	hl,sp
   ld		e,(hl)
   inc	hl
   ld		d,(hl)
   push	de

   ld		hl,@SP+buf+4
   add	hl,sp
   ld		e,(hl)
   inc	hl
   ld		d,(hl)
   push	de

	ld		e,a
	ld		d,0
	push	de

	ld		de,.retAddr
	push	de

	ld		hl,@SP+putc+10
	add	hl,sp
	ld		a,(hl)
	inc	hl
	ld		h,(hl)
	ld		l,a
	jp		(hl)
.retAddr:
	pop   bc
	pop	bc
	pop	bc
	pop	bc
	jr		.repeatOut
.endFunc:
#endasm
	return string;
}


/*** BeginHeader _tmtoa */

char * _tmtoa(long t, char *str);

/*** EndHeader */

nodebug
char * _tmtoa(long t, char *str) {
	auto struct tm ts;
	sprintf(str,"%2d:%02d:%02d",
		(int)(t/3600),
		(int)((t%3600)/60),
		(int)(t%60));
	return str;
}

/*** BeginHeader _dtmonname */

extern const char * const _dtmonname[13];

/*** EndHeader */

const char * const _dtmonname[13] = {
	"???","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
};

/*** BeginHeader _dttoa */

char * _dttoa(int t, char *str);

/*** EndHeader */

nodebug
char * _dttoa(int d, char *str) {
	auto struct tm ts;
	_mktm_date(&ts,d);
	sprintf(str,"%d/%d/%02d", ts.tm_mon, ts.tm_mday, ts.tm_year % 100);
	return str;
}

/*** BeginHeader _atotm */

long _atotm(char *str);

/*** EndHeader */

nodebug
long _atotm(char *str) {
	auto long time;
	auto int i;
	auto char *tail;

	i = (int)strtol(str, &tail, 10);
	if (i >= 0 && i < 24) {
		time = i * 3600L;
	} else {
		return -1;
	}

	if (*tail != ':') return -1;
	++tail;
	i = (int)strtol(tail, &tail, 10);
	if (i >= 0 && i < 60) {
		time += i * 60L;
	} else {
		return -1;
	}

	if (*tail != ':') return -1;
	++tail;
	i = (int)strtol(tail, &tail, 10);
	if (i >= 0 && i < 60) {
		return time + i;
	} else {
		return -1;
	}
}

/*** BeginHeader _atodt */

int _atodt(char *str);

/*** EndHeader */

nodebug
int _atodt(char *str) {
	auto int date;
	auto char *tail;
	auto int i;
	auto struct tm t;

	static const int __dom[2][12] =
		{
		{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
		{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
		};

	i = (int)strtol(str, &tail, 10);
	if (i >= 1 && i < 13) {
		t.tm_mon = i;
	} else {
		return -1;
	}

	if (*tail != '/') return -1;
	++tail;

	i = (int)strtol(tail, &tail, 10);
	if (i >= 1) {
		t.tm_mday = i;
	} else {
		return -1;
	}

	if (*tail != '/') return -1;
	++tail;

	i = (int)strtol(tail, &tail, 10);
	if (	(i >= 1980 && i <= 2079) || (i >= 0 && i <= 99)) {
		t.tm_year = i % 100;
		if (t.tm_year < 80) t.tm_year += 100;
	} else {
		return -1;
	}

	if (t.tm_mday < __dom[!(t.tm_year % 4)][t.tm_mon-1]+1) {
		return (int)_mktime_date(&t);
	} else {
		return -1;
	}
}

/*** BeginHeader _stdioSerialInit, _stdioSerialOut,
					  _stdioSerialIn, _stdioSerialKbhit */

void _stdioSerialInit();
void _stdioSerialOut(char *);
int _stdioSerialIn();
int _stdioSerialKbhit();

/*** EndHeader */


// parameters for debug output of STDIO to a serial port -- to use this
// feature, see the example program in SAMPLES/STDIO_SERIAL.C .

#ifdef STDIO_DEBUG_SERIAL
#if (STDIO_DEBUG_SERIAL == SADR)
	#define	SDS_SxDR					SADR
	#define	SDS_SxSR					SASR
	#define	SDS_TATxR				TAT4R
	#define	SDS_TATxRShadow		TAT4RShadow
   #define	SDS_PxFR					PCFR
   #define	SDS_PxFRShadow			PCFRShadow
	#define	SDS_PxFRMask			0x40
#endif
#if (STDIO_DEBUG_SERIAL == SBDR)
	#define	SDS_SxDR					SBDR
	#define	SDS_SxSR					SBSR
	#define	SDS_TATxR				TAT5R
	#define	SDS_TATxRShadow		TAT5RShadow
   #define	SDS_PxFR					PCFR
   #define	SDS_PxFRShadow			PCFRShadow
	#define	SDS_PxFRMask			0x10
#endif
#if (STDIO_DEBUG_SERIAL == SCDR)
	#define	SDS_SxDR					SCDR
	#define	SDS_SxSR					SCSR
	#define	SDS_TATxR				TAT6R
	#define	SDS_TATxRShadow		TAT6RShadow
   #define	SDS_PxFR					PCFR
   #define	SDS_PxFRShadow			PCFRShadow
	#define	SDS_PxFRMask			0x04
#endif
#if (STDIO_DEBUG_SERIAL == SDDR)
	#define	SDS_SxDR					SDDR
	#define	SDS_SxSR					SDSR
	#define	SDS_TATxR				TAT7R
	#define	SDS_TATxRShadow		TAT7RShadow
   #define	SDS_PxFR					PCFR
   #define	SDS_PxFRShadow			PCFRShadow
	#define	SDS_PxFRMask			0x01
#endif

#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
 #if (STDIO_DEBUG_SERIAL == SEDR)
	#define	SDS_SxDR					SEDR
	#define	SDS_SxSR					SESR
	#define	SDS_TATxR				TAT2R
	#define	SDS_TATxRShadow		TAT2RShadow
	#define	SDS_PxFR					PGFR
	#define	SDS_PxFRShadow			PGFRShadow
	#define	SDS_PxFRMask			0x40
	#define	SDS_AndDDR				0x7F
	#define	SDS_OrDDR				0x40
 #endif
 #if (STDIO_DEBUG_SERIAL == SFDR)
	#define	SDS_SxDR					SFDR
	#define	SDS_SxSR					SFSR
	#define	SDS_TATxR				TAT3R
	#define	SDS_TATxRShadow		TAT3RShadow
	#define	SDS_PxFR					PGFR
	#define	SDS_PxFRShadow			PGFRShadow
	#define	SDS_PxFRMask			0x04
	#define	SDS_AndDDR				0xF7
	#define	SDS_OrDDR				0x04
 #endif
#endif

#ifndef SDS_SxSR
 #if (CPU_ID_MASK(_CPU_ID_) >= R3000)
#error "Unknown value for STDIO_DEBUG_SERIAL, must be SxDR where x = A,B,...,F."
 #else
#error "Unknown value for STDIO_DEBUG_SERIAL, must be SxDR where x = A,B,C,D."
 #endif
#endif

#ifndef STDIO_DEBUG_BAUD
#error "If STDIO_DEBUG_SERIAL enabled, must set STDIO_DEBUG_BAUD as well."
#endif

xmem nodebug
void _stdioSerialInit()
{
	static unsigned long	divisor;
	// empty function to hold global init code

	#GLOBAL_INIT {
#ifndef STDIO_DEBUG_FORCEDSERIAL
		if (!(OPMODE & 0x08)) {	// init serial port if NOT in debug mode
#endif	//STDIO_DEBUG_FORCEDSERIAL
#if (STDIO_DEBUG_SERIAL == SADR)
	 		// disable interrupts (enforce polled I/O) for serial port A
			WrPortI(SACR, &SACRShadow, SACRShadow & 0xFC);
#endif
			divisor = (long)(freq_divider * 19200.0/(float)(STDIO_DEBUG_BAUD) + 0.5) - 1L;
   		WrPortI(SDS_TATxR, &SDS_TATxRShadow, (char) divisor);
			WrPortI(SDS_PxFR, &SDS_PxFRShadow, SDS_PxFRShadow | SDS_PxFRMask);
#if (SDS_PxFR == PGFR)
			WrPortI(PGDDR, &PGDDRShadow, (PGDDRShadow & SDS_AndDDR) | SDS_OrDDR);
#endif
#ifndef STDIO_DEBUG_FORCEDSERIAL
		}
#endif	//STDIO_DEBUG_FORCEDSERIAL
	}
}

#asm nodebug
_stdioSerialOut::
	// assumes that HL is address of null-terminated string
__DC_loop:
	xor	a
	cp		(hl)
#if __RABBITSYS
#if SHADOWS_MODE == PROT_MODE
	jp		z, .done
#else
	jr		z, .done
#endif
#else
	jr		z, .done
#endif

.waitforclear:
;	ioi	ld a, (SDS_SxSR)
	IOREAD_A(SDS_SxSR)
	bit	2, a
	jr		nz, .waitforclear
	ld		a, (hl)
;	ioi	ld (SDS_SxDR), a
	IOWRITE_A(SDS_SxDR)
#ifdef STDIO_DEBUG_ADDCR
	cp		'\n'
	jr		nz, .notNL
.sendCR:
;	ioi	ld a, (SDS_SxSR)
   IOREAD_A(SDS_SxSR)
	bit	2, a
	jr		nz, .sendCR
	ld		a, '\r'
;	ioi	ld (SDS_SxDR), a
	IOWRITE_A(SDS_SxDR)
.notNL:
#endif
	inc	hl
#if __RABBITSYS
#if SHADOWS_MODE == PROT_MODE
	jp		__DC_loop
#else
	jr		__DC_loop
#endif
#else
	jr		__DC_loop
#endif
.done:
	ret
#endasm


#asm nodebug
_stdioSerialIn::
	// wait for a character on serial port, then return it
.waitfordata:
;	ioi	ld a, (SDS_SxSR)
	IOREAD_A(SDS_SxSR)
	bit	7, a
	jr		z, .waitfordata
;	ioi	ld a, (SDS_SxDR)
	IOREAD_A(SDS_SxDR)
	ld		l, a
	ret
#endasm


#asm nodebug
_stdioSerialKbhit::
	// see if a character is available
;	ioi	ld a, (SDS_SxSR)
	IOREAD_A(SDS_SxSR)
	and	0x80
	bool	hl
	ld		l, a
	ret
#endasm
#endif

/*** BeginHeader  ********************************************/
#endif
/*** EndHeader ***********************************************/