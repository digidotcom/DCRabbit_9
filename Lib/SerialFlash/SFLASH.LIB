/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/************************************************************************
SFLASH.LIB

Library for interfacing to serial flash memory devices on an SPI bus.
Specifically, written to work with Atmel DataFlash (AT45DBxxx) parts.

Uses serial port B for SPI port
redefine following macros to set up chip select (/CS) pin for flash chip:
	SF_SPI_CSPORT   - data register for port with CS pin (e.g. PEDR)
	SF_SPI_CSSHADOW - shadow varible for data register (e.g. PEDRShadow)
	SF_SPI_CSDD - data direction register for CS pin (e.g. PEDDR)
	SF_SPI_CSDDSHADOW - shadow for data direction register (PEDDRShadow)
	SF_SPI_CSPIN - pin number of CS  (e.g. 6)

The library has two sets of API functions. The first is maintained for
compatibility with previous versions of SFLASH.LIB. It interfaces to a
single serial flash chip whose SPI parameters are set at compile time
using the macros described above. These functions are all blocking and
only work for single flash devices.
The functions are:
sf_init
sf_status
sf_writeRAM
sf_readRAM
sf_RAMToPage
sf_pageToRAM
There are also global variables initialized by sf_init():
sf_blocks
sf_blocksize
sf_prefixsize

The new API functions make use of an sf_device structure as a handle for
a specific serial flash device. This allows multiple devices to be used
by an application with this library
The new functions are:
sf_initDevice
sf_getPageSize
sf_getPageCount
sf_writeDeviceRAM
sf_readDeviceRAM
sf_readPage
sf_writePage
sf_isWriting

Revision History:	Rev 1.0 Initial Release
						Rev 1.1 Clear Rcv FIFO upon initialization for
                          proper startup of serial commumications.
						Rev 1.2 Changed SCLKC and SCLKD to parallel port D.
	2014 Oct 23  SJH - Added support for 45DB641E.  The old method of
                  determining device parameters by reading just the status
                  register is not sufficient.  Need to read manufacturer
                  and device ID as well.
	2015 Feb 05  SJH - Added support for 45DB642D with the page size OTP'd
                  to 1024 bytes.  This is not normally done, but flash
                  part datecodes 1210 had this option burned in.  Note that
                  the check for 1024 page size is performed using bit 0
                  of the device status register, however this test is
                  only done specifically for device IDs which are known
                  to be affected.  The test can easily be expanded to
                  other parts if required (just by adding a table flag).
                  See sf_devtable for details.

*************************************************************************/

/*** BeginHeader */

#ifndef __SFLASH_LIB__
#define __SFLASH_LIB__

/*
_XMEM_XLT is a macro to jump to the assembly routine _XMEM_XLT from non-root
code
*/
// Expects A to contain the relevant XPC value;
// HL contains a logical address in 0xE000-0xEFFF range of the data to translate,
// B contains number of bytes to translate (1 <= B <= 255, or 0 for 256 bytes),
// DE' points to a 256-byte translation table in root memory.
// On return, AF and HL' trashed; B set to zero, HL points to first byte after
// translated section.  Other regs preserved.
#define _XMEM_XLT	db 0xCF $ dw _xmem_xlt $ db 0

#ifdef SFLASH_DEBUG
#define _sflash_nodebug
#else
#define _sflash_nodebug nodebug
#endif


#ifndef SF_SPI_DIVISOR
#define SF_SPI_DIVISOR 0
#endif

#define SF_SPI_CONTROL_VALUE 0x0C
#define SF_SPI_TXMASK 0x80
#define SF_SPI_RXMASK 0x40

#ifndef SF_SPI_CLOCKMODE
#define SF_SPI_CLOCKMODE 0
#endif

#ifndef SF_SPI_CSPORT
	#define SF_SPI_CSPORT PEDR
   #ifndef SF_SPI_CSSHADOW
		#define SF_SPI_CSSHADOW PEDRShadow
   #endif
	#define SF_SPI_CSDD PEDDR
   #ifndef SF_SPI_CSDDSHADOW
		#define SF_SPI_CSDDSHADOW PEDDRShadow
   #endif
	#define SF_SPI_CSPIN 6
#endif

#ifndef SF_SPI_TACRSHADOW
	#define SF_SPI_TACRSHADOW TACRShadow
#endif

#ifndef SF_SPI_PCFRSHADOW
	#define SF_SPI_PCFRSHADOW PCFRShadow
#endif

#ifndef SF_SPI_PBDDRSHADOW
	#define SF_SPI_PBDDRSHADOW PBDDRShadow
#endif

#ifndef SF_SPI_PFFRSHADOW
   #define SF_SPI_PFFRSHADOW PFFRShadow
#endif

#ifndef SF_SPI_PFDCRSHADOW
   #define SF_SPI_PFDCRSHADOW PFDCRShadow
#endif

#ifndef SF_SPI_PFDDRSHADOW
   #define SF_SPI_PFDDRSHADOW PFDDRShadow
#endif

//serial port register offsets
#define SF_SR_OFFSET 3
#define SF_CR_OFFSET 4
#define SF_ER_OFFSET 5

#ifndef SF_SERPORT
#define SF_SERPORT SBDR
#endif

#if SF_SERPORT == SADR
	#define SF_SERPORT_TR 4
   #ifndef SF_SERPORT_TR_REG
	   #define SF_SERPORT_TR_REG TAT4R
   #endif
	#ifndef SF_SERPORT_TR_SHADOW
	   #define SF_SERPORT_TR_SHADOW TAT4RShadow
   #endif
   #ifndef SF_SERPORT_CR_SHADOW
		#define SF_SERPORT_CR_SHADOW SACRShadow
   #endif
   #ifndef SF_SERPORT_ER_SHADOW
		#define SF_SERPORT_ER_SHADOW SAERShadow
   #endif
#elif SF_SERPORT == SBDR
	#define SF_SERPORT_TR 5
   #ifndef SF_SERPORT_TR_REG
	   #define SF_SERPORT_TR_REG TAT5R
   #endif
	#ifndef SF_SERPORT_TR_SHADOW
	   #define SF_SERPORT_TR_SHADOW TAT5RShadow
   #endif
   #ifndef SF_SERPORT_CR_SHADOW
		#define SF_SERPORT_CR_SHADOW SBCRShadow
   #endif
   #ifndef SF_SERPORT_ER_SHADOW
		#define SF_SERPORT_ER_SHADOW SBERShadow
   #endif
#elif SF_SERPORT == SCDR
	#define SF_SERPORT_TR 6
   #ifndef SF_SERPORT_TR_REG
	   #define SF_SERPORT_TR_REG TAT6R
   #endif
   #ifndef SF_SERPORT_TR_SHADOW
	   #define SF_SERPORT_TR_SHADOW TAT6RShadow
	#endif
   #ifndef SF_SERPORT_CR_SHADOW
		#define SF_SERPORT_CR_SHADOW SCCRShadow
   #endif
   #ifndef SF_SERPORT_ER_SHADOW
		#define SF_SERPORT_ER_SHADOW SCERShadow
   #endif
#elif SF_SERPORT == SDDR
	#define SF_SERPORT_TR 7
   #ifndef SF_SERPORT_TR_REG
	   #define SF_SERPORT_TR_REG TAT7R
   #endif
   #ifndef SF_SERPORT_TR_SHADOW
	   #define SF_SERPORT_TR_SHADOW TAT7RShadow
   #endif
   #ifndef SF_SERPORT_CR_SHADOW
	   #define SF_SERPORT_CR_SHADOW SDCRShadow
   #endif
   #ifndef SF_SERPORT_ER_SHADOW
		#define SF_SERPORT_ER_SHADOW SDERShadow
   #endif
#endif

#if SF_SERPORT != SADR && \
	 SF_SERPORT != SBDR && \
    SF_SERPORT != SCDR && \
    SF_SERPORT != SDDR
	#error "Invalid definition of SF_SERPORT"
#endif


#define SF_BITSREVERSED 0x01
#define SF_RAMBANK1 0x00
#define SF_RAMBANK2 0x02



/*** EndHeader */

/*** BeginHeader _xmem_xlt */
/*=== Do NOT call this function from C! ===*/
/*
_xmem_xlt translates bytes in a buffer using a supplied translation table
hl - logical address of bytes to translate
'de - translation table in root memory
b - number of bytes to translate, 0 means 256
*/
root char * _xmem_xlt(/* register params */void);
/*** EndHeader */
#asm root nodebug
_xmem_xlt::
	ld		xpc,a
.loop:
	ld		a,(hl)
   exx
   bool	hl
   ld		L,a
   add	hl,de
   ld		a,(hl)
   exx
   ld		(hl),a
   inc	hl
   djnz	.loop
	lret
#endasm



/*** BeginHeader sfspi_init */
int sfspi_init();

/* START FUNCTION DESCRIPTION ********************************************
sfspi_init                 <SFLASH.LIB>

SYNTAX: int sfspi_init()

DESCRIPTION:	Initialize SPI driver for use with serial flash. This must
					be called before any calls to sf_initDevice()


RETURN VALUE:  0 - inialization OK
					-1 - error

END DESCRIPTION **********************************************************/

/*** EndHeader */


_sflash_nodebug int sfspi_init()
{

	BitWrPortI(TACR, &SF_SPI_TACRSHADOW, 0, SF_SERPORT_TR); //use pclk/2 for TATxR
   WrPortI(SF_SERPORT_TR_REG, &SF_SERPORT_TR_SHADOW, SF_SPI_DIVISOR);

   WrPortI(SF_SERPORT + SF_CR_OFFSET,
   		  &SF_SERPORT_CR_SHADOW,
           SF_SPI_CONTROL_VALUE);
   WrPortI(SF_SERPORT + SF_ER_OFFSET,
   		  &SF_SERPORT_ER_SHADOW,
           SF_SPI_CLOCKMODE << 4);

   //specific code for setting up pins for different ports
#if SF_SERPORT == SADR
   BitWrPortI(PCFR, &SF_SPI_PCFRSHADOW, 1, 6); //set to ser A TX
   BitWrPortI(PBDDR, &SF_SPI_PBDDRSHADOW, 1, 1); //make sure CLK(PB1) is output

   // Clear Rcv Status
  	#asm
	ioi ld	 a, (SADR)		;Do dummy read to clear rcv status
  	#endasm

#elif SF_SERPORT == SBDR
   BitWrPortI(PCFR, &SF_SPI_PCFRSHADOW, 1, 4); //set to ser B TX
   BitWrPortI(PBDDR, &SF_SPI_PBDDRSHADOW, 1, 0); //make sure CLK(PB0) is output

   // Clear Rcv Status
   #asm
  	ioi ld	 a, (SBDR)		;Do dummy read to clear rcv status
   #endasm


#elif SF_SERPORT == SCDR
   BitWrPortI(PCFR, &SF_SPI_PCFRSHADOW, 1, 2); //set to ser C TX
   //setup CLK(PF1 or PD2)
   BitWrPortI(PFFR, &SF_SPI_PFFRSHADOW, 1, 1);
   BitWrPortI(PFDCR, &SF_SPI_PFDCRSHADOW, 0, 1);
   BitWrPortI(PFDDR, &SF_SPI_PFDDRSHADOW, 1, 1);
   // Clear Rcv Status
  	#asm
	ioi ld	 a, (SCDR)		;Do dummy read to clear rcv status
  	#endasm

#elif SF_SERPORT == SDDR
   BitWrPortI(PCFR, &SF_SPI_PCFRSHADOW, 1, 0); //set to ser D TX
   //setup CLK(PF0 or PD0)
   BitWrPortI(PFFR, &SF_SPI_PFFRSHADOW, 1, 0);
   BitWrPortI(PFDCR, &SF_SPI_PFDCRSHADOW, 0, 0);
   BitWrPortI(PFDDR, &SF_SPI_PFDDRSHADOW, 1, 0);
   // Clear Rcv Status
  	#asm
	ioi ld	 a, (SDDR)		;Do dummy read to clear rcv status
  	#endasm
#endif

   return 0;
}




/*** BeginHeader sfspi_write */
int sfspi_write(char *buffer, int len);

/* _START FUNCTION DESCRIPTION ********************************************
sfspi_write                 <SFLASH.LIB>

SYNTAX: int sfspi_write(char *buffer, int len)

DESCRIPTION:   Transmits a block of data over the SPI port. This
					function blocks until the tranmission completes

PARAMETER1:		buffer - An array of bytes to transmit
PARAMETER2:		len - number of bytes to transmit

RETURN VALUE:  0 - transmit OK
					-1 - error

END DESCRIPTION **********************************************************/

/*** EndHeader */

_sflash_nodebug
int sfspi_write(char *buffer, int len)
{
	auto int rc;

#ifdef SFLASH_VERBOSE
	printf("writing buffer 0x%p, len 0x%X\n", buffer, len);
#endif

#asm
		; get len parameter value
		ld		hl, (SP+@SP+len)
		; check for negative len (if so, go return -1 result)
		bit	7, h						; test len's sign bit
		jr		z, .continue			; continue if sign bit is Zero (non-negative)

		ld		hl, -1					; set error (-1) result code
		jr		.returnResultCode

.continue:
		; check for zero len (if so, nothing to do; go return 0 result)
		ld		a, h
		or		L
		jr		z, .returnResultCode	; if both H and L contain zero then go return

		ld		c, h						; put len MSB into C (outer loop count)
		ld		b, L						; put len LSB into B (initial inner loop count)
		ld		a, b						; if initial inner loop count is zero (i.e.
		or		a							;  256) then no need to account for it by
		jr		z, .noinc				;  incrementing the outer loop count

		inc	c							; account for non-zero initial inner loop count
.noinc:
		ld		hl, (SP+@SP+buffer)
		ld		a, (SF_SERPORT_CR_SHADOW)
		or		SF_SPI_TXMASK
		ld		e, a						; E holds control reg value for byte transmit
		exx
		ld		de, SF_SERPORT + SF_CR_OFFSET
		ld		hl, SF_SERPORT + SF_SR_OFFSET
		exx
.sfspi_write_loop:
		ld		a, (hl)
		inc	hl
ioi	ld		(SF_SERPORT), a		; load next byte to transmit
		ld		a, e
		exx
ioi	ld		(de), a					; start tx
.sfspi_write_wait:
ioi	bit	3, (hl)
		jr		nz, .sfspi_write_wait	; wait until tx buffer empties

		exx
		djnz	.sfspi_write_loop

		dec	c
		jr		nz, .sfspi_write_loop

.sfspi_write_done:
ioi	ld		a, (SF_SERPORT + SF_SR_OFFSET)
		and	0x0C
		jr		nz, .sfspi_write_done	; wait for tx to finish completely

		; report 0 (OK) result code
		bool	hl
		ld		L, h
.returnResultCode:
		ld		(SP+@SP+rc), hl
#endasm
	return rc;
}

/*** BeginHeader sfspi_xwrite */
int sfspi_xwrite(long buffer, int len);

/* _START FUNCTION DESCRIPTION ********************************************
sfspi_xwrite                 <SFLASH.LIB>

SYNTAX: int sfspi_xwrite(long buffer, int len)

DESCRIPTION:   Transmits a block of data over the SPI port from an xmem
					buffer. This function blocks until the tranmission completes

PARAMETER1:		buffer - Pointer to an array of bytes in xmem
PARAMETER2:		len - number of bytes to transmit

RETURN VALUE:  0 - transmit OK
					-1 - error

END DESCRIPTION **********************************************************/
/*** EndHeader */

_sflash_nodebug int sfspi_xwrite(long buffer, int len)
{
	// Do this <= 128 bytes at a time via xmem2root.
	auto char buf[128];
	auto int rc, write_len;

	if (0 > len)
	{
		rc = -1;	// negative len, set error result
	}
	else
	{
		rc = 0;	// default to OK result
		while (!rc && len)
		{
			write_len = (len > (int) (sizeof buf)) ? (int) (sizeof buf) : len;
			xmem2root(buf, buffer, (unsigned) write_len);
			rc = sfspi_write(buf, write_len);
			buffer += (long) write_len;
			len -= write_len;
		}
	}
	return rc;
}


/*** BeginHeader sfspi_read */
int sfspi_read(char *buffer, int len);

/* _START FUNCTION DESCRIPTION ********************************************
sfspi_read                 <SFLASH.LIB>

SYNTAX: int sfspi_xwrite(char *buffer, int len)

DESCRIPTION:   Reads in len bytes of data from the SPI port into a buffer

PARAMETER1:		buffer - buffer for received bytes
PARAMETER2:		len - number of bytes to receive

RETURN VALUE:  0 - receive OK
					-1 - error

END DESCRIPTION **********************************************************/

/*** EndHeader */

_sflash_nodebug int sfspi_read(char *buffer, int len)
{
	auto int rc;

#ifdef SFLASH_VERBOSE
	printf("reading buffer 0x%p, len 0x%X\n", buffer, len);
#endif

#asm
		; get len parameter value
		ld		hl, (SP+@SP+len)
		; check for negative len (if so, go return -1 result)
		bit	7, h						; test len's sign bit
		jr		z, .continue			; continue if sign bit is Zero (non-negative)

		ld		hl, -1					; set error (-1) result code
		jr		.returnResultCode

.continue:
		; check for zero len (if so, nothing to do; go return 0 result)
		ld		a, h
		or		L
		jr		z, .returnResultCode	; if both H and L contain zero then go return

		ld		c, h						; put len MSB into C (outer loop count)
		ld		b, L						; put len LSB into B (initial inner loop count)
		ld		a, b						; if initial inner loop count is zero (i.e.
		or		a							;  256) then no need to account for it by
		jr		z, .noinc				;  incrementing the outer loop count

		inc	c							; account for non-zero initial inner loop count
.noinc:
		ld		hl, (SP+@SP+buffer)
		ld		a, (SF_SERPORT_CR_SHADOW)
		or		SF_SPI_RXMASK
		ld		e, a						; E holds control reg value for byte receive
		exx
		ld		bc, SF_SERPORT
		ld		de, SF_SERPORT + SF_CR_OFFSET
		ld		hl, SF_SERPORT + SF_SR_OFFSET
		exx
.sfspi_read_loop:
		ld		a, e
		exx
ioi	ld		(de), a					; start rx
.sfspi_read_wait:
ioi	bit	7, (hl)
		jr		z, .sfspi_read_wait	; wait until rx buffer fills

ioi	ld		a, (bc)					; get rx byte
		exx
#ifdef SF_SPI_INVERT_RX
		cpl
#endif
		ld		(hl), a
		inc	hl
		djnz	.sfspi_read_loop

		dec	c
		jr		nz, .sfspi_read_loop

		; report 0 (OK) result code
		bool	hl
		ld		L, h
.returnResultCode:
		ld		(SP+@SP+rc), hl
#endasm
	return rc;
}

/*** BeginHeader sfspi_xread */
int sfspi_xread(long buffer, int len);

/* _START FUNCTION DESCRIPTION ********************************************
sfspi_xread                 <SFLASH.LIB>

SYNTAX: int sfspi_xread(long buffer, int len)

DESCRIPTION:   Reads in len bytes of data from the SPI port into
					an xmem buffer

PARAMETER1:		buffer - xmem buffer for received bytes
PARAMETER2:		len - number of bytes to receive

RETURN VALUE:  0 - receive OK
					-1 - error

END DESCRIPTION **********************************************************/

/*** EndHeader */

_sflash_nodebug
int sfspi_xread(long buffer, int len)
{
	// Do this <= 128 bytes at a time via root2xmem.
	auto char buf[128];
	auto int rc, read_len;

	if (0 > len)
	{
		rc = -1;	// negative len, set error result
	}
	else
	{
		rc = 0;	// default to OK result
		while (!rc && len)
		{
			read_len = (len > (int) (sizeof buf)) ? (int) (sizeof buf) : len;
			rc = sfspi_read(buf, read_len);
			root2xmem(buffer, buf, (unsigned) read_len);
			buffer += (long) read_len;
			len -= read_len;
		}
	}
	return rc;
}


/*** BeginHeader sfspi_bitrev */
void sfspi_bitrev(char *buffer, int len);

/* _START FUNCTION DESCRIPTION ********************************************
sfspi_bitrev                 <SFLASH.LIB>

SYNTAX: int sfspi_bitrev(char *buffer, int len)

DESCRIPTION:   Translates in place a number of bytes in a root buffer
					into their bit-reversed equivelants. (e.g. 0x34 -> 0x2C)

PARAMETER1:		buffer - root buffer with bytes to be altered
PARAMETER2:		len - number of bytes to bit reverse

END DESCRIPTION **********************************************************/

/*** EndHeader */

_sflash_nodebug void sfspi_bitrev(char *buffer, int len)
{

   while(len > 0)
   {
		// We use the xmem routine with very minor loss in efficiency
	#asm
		ld		hl,BitRevTable
   	ex		de',hl			; DE' has table address
   	ld		hl,(sp+@sp+len)
		ld		b, 0				; reset b to zero
		ld		a,h            ; get upper byte of len
      and 	a              ; check if zero
      jr		nz,.noload     ; don't load b if greater than 255
	   ld		b,L				; Count in B (1..256)
.noload:
   	ld		hl,(sp+@sp+buffer)
   	_XMEM_XLT				; This won't care about the value of A, since not xmem.
   	; Residual HL value is returned.
	#endasm
      len    -= 256;
      buffer += 256;
   }
}

/*** BeginHeader sfspi_xbitrev */
void sfspi_xbitrev(long buffer, int len);

/* _START FUNCTION DESCRIPTION ********************************************
sfspi_xbitrev                 <SFLASH.LIB>

SYNTAX: int sfspi_xbitrev(long buffer, int len)

DESCRIPTION:   Translates in place a number of bytes in an xmem buffer
					into their bit-reversed equivelants. (e.g. 0x34 -> 0x2C)

PARAMETER1:		buffer - address of xmem buffer with bytes to be altered
PARAMETER2:		len - number of bytes to bit reverse

END DESCRIPTION **********************************************************/

/*** EndHeader */

_sflash_nodebug void sfspi_xbitrev(long buffer, int len)
{
   while(len > 0)
   {
	#asm
		ld		hl,BitRevTable
	   ex		de',hl			; DE' has table address
	   ld		hl,(sp+@sp+len)
		ld		b, 0				; reset b to zero
		ld		a,h            ; get upper byte of len
      and 	a              ; check if zero
      jr		nz,.noload     ; don't load b if greater than 255
	   ld		b,L				; Count in B (1..256)
.noload:
	   ld		hl,(sp+@sp+buffer+2)
	   ld		a,L
	   ld		hl,(sp+@sp+buffer)
	   _LIN2SEG
	   _XMEM_XLT
	#endasm
      len    -= 256;
      buffer += 256;
   }

}

/*** BeginHeader */

typedef struct
{
	int port;
   char *shadow;
   char mask;
} sf_cspin;

typedef struct sf_device_st
{
	struct sf_device_st *next;  //next element in linked list
	long pages; //number of usable pages in flash device
   unsigned int pagesize; //size (in bytes) of pages in flash device
   int addressbytes; // number of bytes used for page addressing
   int pagebitshift; // number of 'don't care' bits following the page address
   int write_state;  // state for multi-page writes (used by filesystem)
   long write_page;  // page currently being written (used by filesystem)
   sf_cspin cspin;
} sf_device;

//separate variables kept for backward compatibility
extern long sf_blocks;
extern int sf_prefixsize;
extern int sf_blocksize;
extern sf_device sf_dev;

/*** EndHeader */


/*** BeginHeader sf_init */
int sf_init();
/*** EndHeader */


/* START FUNCTION DESCRIPTION ********************************************
sf_init                 <SFLASH.LIB>

SYNTAX: int sf_init();

DESCRIPTION:  Initializes serial flash chip. This function must be called
				before the serial flash can be used.
            Currently supported devices are:
            AT45DB041
            AT45DB081
            AT45DB642
            AR45DB1282

RETURN VALUE:  0 for success,
					-1 if no flash chip detected
               -2 if error communicating with flash chip
               -3 if unknown flash chip type

END DESCRIPTION **********************************************************/


sf_device sf_dev;
long sf_blocks;
int sf_prefixsize;
int sf_blocksize;


_sflash_nodebug int sf_init()
{
	auto int rc;

   sf_blocks = 0;
   sf_prefixsize = 0;
   sf_blocksize = 0;

   sfspi_init();

	//setup CS pin
   BitWrPortI(SF_SPI_CSPORT, &SF_SPI_CSSHADOW, 1, SF_SPI_CSPIN);
   BitWrPortI(SF_SPI_CSDD, &SF_SPI_CSDDSHADOW, 1, SF_SPI_CSPIN);

   if ((rc = sf_initDevice(&sf_dev, SF_SPI_CSPORT, &SF_SPI_CSSHADOW,
          SF_SPI_CSPIN)) < 0 )
   	return rc;

   //fill in variables needed for backward compatibility
   sf_blocks = sf_dev.pages;
   sf_prefixsize = sf_dev.pagesize % 256; //extra space past n*256
   sf_blocksize = sf_dev.pagesize;

   return 0;
}

/*** BeginHeader sf_print_dev */
void sf_print_dev(sf_device *dev);
/*** EndHeader */
//DEBUGGING function
void sf_print_dev(sf_device *dev)
{
	printf("sf_device address: 0x%x\n", (unsigned int)dev );
   printf("\tnext: 0x%x\n", (unsigned int)(dev->next) );
   printf("\tpages: %ld\n", dev->pages);
   printf("\tpagesize: %d\n", dev->pagesize);
   printf("\taddressbytes: %d\n", dev->addressbytes);
   printf("\tpagebitshift: %d\n", dev->pagebitshift);
   printf("\twrite_state: %d\n", dev->write_state);
   printf("\twrite_page: %ld\n", dev->write_page);
   printf("\tcs_pin:\n");
   printf("\t\tport: 0x%x\n", dev->cspin.port);
   printf("\t\tshadow: 0x%x\n", (unsigned int)(dev->cspin.shadow) );
   printf("\t\tmask: 0x%x\n", dev->cspin.mask);
}

/*** BeginHeader sf_initDevice */
int sf_initDevice(sf_device *dev, int cs_port, char *cs_shadow, int cs_pin);

/* START FUNCTION DESCRIPTION ********************************************
sf_initDevice                 <SFLASH.LIB>

SYNTAX: int sf_initDevice(sf_device *dev,
							     int cs_port,
                          char *cs_shadow,
                          int cs_pin);

DESCRIPTION: Replaces sf_init()
				sfspi_init() must also be called before any calls to this
            function.
				Initializes serial flash chip. This function must be called
				before the serial flash can be used.
            Currently supported devices are:
            AT45DB041
            AT45DB081
            AT45DB642
            AR45DB1282

PARAMETER1:		dev - pointer to an empty sf_device struct that will be
						filled in. The struct will then act as a handle for
                  the device
PARAMETER2:		cs_port - I/O port for the active low chip select pin for
							the device
PARAMETER3:		cs_shadow - pointer to the shadow variable for cs_port
PARAMETER4:		cs_pin - I/O port pin number for the chip select signal


RETURN VALUE:  0 for success,
					-1 if no flash chip detected
               -2 if error communicating with flash chip
               -3 if unknown flash chip type

END DESCRIPTION **********************************************************/

/*** EndHeader */


/*
table for flash device configuration
*/

#ifndef SFLASH_DEVTABLE_SIZE
#define SFLASH_DEVTABLE_SIZE 10
#endif
typedef struct {
	int id_code;    	// From status byte & 0x3C (4 bits)
   long mfgid;			// 4 bytes from mfg and dev id read.  If zero, then
   						// ignore (for backwards compat).
   long pages;
   unsigned int pagesize;
   int addressbytes;
   int pagebitshift;
   int flags;			// Special flags as follows:
   #define SDE_POW2	0x0001	// If set, check LSB of status byte to see if
   									// this device has been OTP to power-of-2
                              // page size.  This is not normally done, but
                              // allows devices which have been inadvertently
                              // programmed this way to be used (albeit with
                              // reduced capacity).
} sf_devtable_entry;

// NOTE: put devices with non-zero manufacturer info (2nd field) before the
// zero (i.e. default) entry with the same status code (1st field).
// The first byte read using the 9F opcode is in the LSB of the long
// value, so (e.g.) the 0x1F for Atmel is the LSB.  Currently, only
// 4 bytes are read.  If more than this is required in the future,
// another field will need to be added.
const sf_devtable_entry sf_devtable[SFLASH_DEVTABLE_SIZE] =
{
   {0x001C, 0L,          2048L,  264,  3, 9},	  // AT45DB041B
	{0x0024, 0L,          4096L,  264,  3, 9},	  // AT45DB081B
	{0x0034, 0L,          8192L,  528,  3, 10},	  // AT45DB321
	{0x003C, 0x0100281FL, 32768L, 264,  3, 9},     // AT45DB641E
	{0x003C, 0L,          8192L,  1056, 3, 11, SDE_POW2},    // AT45DB642
	{0x0010, 0L,          16384L, 1056, 4, 11},    // AT45DB1282
};


_sflash_nodebug sf_initDevice(sf_device *dev,
					 					int cs_port,
                              char *cs_shadow,
                              int cs_pin)
{
	auto char status;
   auto int i;
   auto long mfg;

   dev->pages = 0;
   dev->pagesize = 0;
   dev->next = NULL; //defaults to end of linked list

   dev->cspin.port = cs_port;
   dev->cspin.shadow = cs_shadow;
   dev->cspin.mask = 1 << cs_pin;

   dev->write_state = 0;

   status = sf_deviceStatus(dev);

   if(status == 0xff)
   {
   	return -1; //no response
   }
   if((status & 0x80) == 0)
   {
   	return -2; //serial flash busy ???
   }

   mfg = sf_mfgDevID(dev);

   for(i = 0; i < SFLASH_DEVTABLE_SIZE;i++)
   {
      if(sf_devtable[i].id_code == (status & 0x3C) &&
         (!sf_devtable[i].mfgid || sf_devtable[i].mfgid == mfg))
      {
         dev->pages = sf_devtable[i].pages;
         dev->pagesize = sf_devtable[i].pagesize;
         dev->addressbytes = sf_devtable[i].addressbytes;
         dev->pagebitshift = sf_devtable[i].pagebitshift;
         if (sf_devtable[i].flags & SDE_POW2 && status & 0x01) {
			#ifdef SFLASH_VERBOSE
         	printf("sflash device 2**n page size\n");
         #endif
         	dev->pagesize &= 0xFF00;	// Squash the extra LSBs
         }
		#ifdef SFLASH_VERBOSE
			printf("sflash device initialized:\n");
   		sf_print_dev(dev);
		#endif
			return 0;
      }
      else if(sf_devtable[i].id_code == 0)
      {
      	break; //end of valid entries
      }
   }
#ifdef SFLASH_VERBOSE
	printf("status = 0x%x\n", status);
#endif
	return -3; //unknown part
}



/*** BeginHeader sf_status */
char sf_status();
/*** EndHeader */

//return status byte
_sflash_nodebug char sf_status()
{
   return sf_deviceStatus(&sf_dev);
}

/*** BeginHeader sf_enableCS */
void sf_enableCS(sf_device *dev);
/*** EndHeader */

_sflash_nodebug void sf_enableCS(sf_device *dev)
{
	auto char ipreg;

	// prevent interruption of WrPortI
	#asm
	inc	sp          ; Adjust SP for save to ipreg variable
	push	ip          ; Save IP register in ipreg variable on stack
	ipset	1           ; Set IP to prevent interruption of WrPortI
	#endasm

	WrPortI(dev->cspin.port,
   		  dev->cspin.shadow,
           *(dev->cspin.shadow) & ~(dev->cspin.mask) );

	#asm
	pop	ip          ; Restore IP register from ipreg variable
	dec	sp          ; And adjust the SP back to compensate for the INC SP
	#endasm
}

/*** BeginHeader sf_disableCS */
void sf_disableCS(sf_device *dev);
/*** EndHeader */

_sflash_nodebug void sf_disableCS(sf_device *dev)
{
	auto char ipreg;

	// prevent interruption of WrPortI
	#asm
	inc	sp          ; Adjust SP for save to ipreg variable
	push	ip          ; Save IP register in ipreg variable on stack
	ipset	1           ; Set IP to prevent interruption of WrPortI
	#endasm

	WrPortI(dev->cspin.port,
   		  dev->cspin.shadow,
           *(dev->cspin.shadow) | dev->cspin.mask );

	#asm
	pop	ip          ; Restore IP register from ipreg variable
	dec	sp          ; And adjust the SP back to compensate for the INC SP
	#endasm
}

/*** BeginHeader sf_deviceStatus */
char sf_deviceStatus(sf_device *dev);
/*** EndHeader */
_sflash_nodebug char sf_deviceStatus(sf_device *dev)
{
	auto char status;

	sf_enableCS(dev);
   sfspi_write("\xEB", 1);  //0xEB is reverse of command 0xD7
   sfspi_read(&status, 1);
   sfspi_bitrev(&status, 1);
	sf_disableCS(dev);
   return status;
}

/*** BeginHeader sf_mfgDevID */
// Read 4 bytes of the mfg+dev ID (opcode 0x9F), and return as a long
// (1st byte in LSB, should be 0x1F for Atmel).
long sf_mfgDevID(sf_device *dev);
/*** EndHeader */
_sflash_nodebug long sf_mfgDevID(sf_device *dev)
{
	auto char status;
   auto long retval;

	sf_enableCS(dev);
   sfspi_write("\xF9", 1);  //0xF9 is reverse of command 0x9F
   sfspi_read(&status, 1);
   sfspi_bitrev(&status, 1);
   retval = status;
   sfspi_read(&status, 1);
   sfspi_bitrev(&status, 1);
   retval |= (unsigned long)status << 8;
   sfspi_read(&status, 1);
   sfspi_bitrev(&status, 1);
   retval |= (unsigned long)status << 16;
   sfspi_read(&status, 1);
   sfspi_bitrev(&status, 1);
   retval |= (unsigned long)status << 24;
	sf_disableCS(dev);
   return retval;
}

/*** BeginHeader sf_getPageSize */
unsigned int sf_getPageSize(sf_device *dev);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sf_getPageSize                 <SFLASH.LIB>

SYNTAX: unsigned int sf_getPageSize(sf_device *dev);

DESCRIPTION:	Return size(in bytes) of a page on the current flash
					device.
PARAMETER1:		dev - pointer to sf_device struct for initialized flash
						device

RETURN VALUE:  bytes in a page

END DESCRIPTION **********************************************************/

_sflash_nodebug unsigned int sf_getPageSize(sf_device *dev)
{
	return dev->pagesize;
}

/*** BeginHeader sf_getPageCount */
long sf_getPageCount(sf_device *dev);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sf_getPageCount                 <SFLASH.LIB>

SYNTAX: long sf_getPageCount(sf_device *dev);

DESCRIPTION:	Return number of pages in a flash device.

PARAMETER1:		dev - pointer to sf_device struct for initialized flash
						device


RETURN VALUE:  number of pages

END DESCRIPTION **********************************************************/

_sflash_nodebug long sf_getPageCount(sf_device *dev)
{
	return dev->pages;
}



/*** BeginHeader sf_writeRAM */
int sf_writeRAM(char *buffer, int offset, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sf_writeRAM                 <SFLASH.LIB>

SYNTAX: int sf_writeRAM(char *buffer, int offset, int len);

DESCRIPTION:	Write data to the RAM buffer on the serial flash chip

PARAMETER1:    buffer - pointer to data to write into the flash
						chip RAM
PARAMETER2:		offset - the address in the serial flash RAM to start
						writing at
PARAMETER3:		len - the number of bytes to write

RETURN VALUE:  0 for success
					-1 for error

END DESCRIPTION **********************************************************/

//buffer size is equal to block size
_sflash_nodebug int sf_writeRAM(char *buffer, int offset, int len)
{
	return sf_writeDeviceRAM(&sf_dev, paddr(buffer), offset, len, SF_RAMBANK1);
}

/*** BeginHeader sf_writeDeviceRAM */
int sf_writeDeviceRAM(sf_device *dev,
					  		 long buffer,
                 		 int offset,
                 		 int len,
                 		 int flags);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sf_writeDeviceRAM                 <SFLASH.LIB>

SYNTAX: int sf_writeDeviceRAM(sf_device *dev,
                         long buffer,
                         int offset,
                         int len
                         int flags);

DESCRIPTION:	Write data to the RAM buffer on the serial flash chip from
					a buffer in xmem.

PARAMETER1:		dev - pointer to sf_device structure
PARAMETER2:    buffer - pointer to xmem data to write into the flash
						chip RAM
PARAMETER3:		offset - the address in the serial flash RAM to start
						writing at
PARAMETER4:		len - the number of bytes to write

PARAMETER5:		flags -
						SF_BITSREVERSED - Allows the data to be written to the
                  	flash in reverse bit order. This improves speed, and
                     works fine as long as the data is read back out with
                     this same flag (see sf_XReadRAM)
                  SF_RAMBANK1(default) - Writes to the first RAM bank on
                  	the flash device
                  SF_RAMBANK2 - Writes to the alternate RAM bank on the
                  	flash device

RETURN VALUE:  0 for success
					-1 for error

END DESCRIPTION **********************************************************/

//buffer size is equal to block size
_sflash_nodebug int sf_writeDeviceRAM(sf_device *dev,
                                      long buffer,
                                 	  int offset,
                                 	  int len,
                                 	  int flags)
{
   auto unsigned char command[6], dummy;
   auto int i;

#ifdef SFLASH_VERBOSE
   auto char temp_buf[20];


  	xmem2root(temp_buf, buffer, 20);

   temp_buf[19] = 0;
   printf("writing '%s' to RAM\n", temp_buf);

#endif


   if(len == 0)
   {
   	return 0; //don't write anything
   }


   if(dev->addressbytes > 5)
   {
   	return -1; //too many address bytes for command buffer
   }

   if(flags & SF_RAMBANK2)
   {
   	command[0] = '\x87';
   }
   else
   {
   	command[0] = '\x84';
   }
	for(i = 1;i <= dev->addressbytes;i++)
   {
      //setup address bytes
    	command[i] = (unsigned char)(offset >> (8*(dev->addressbytes - i)));
   }
	sf_enableCS(dev);

   sfspi_bitrev(command, dev->addressbytes+1);
   sfspi_write(command, dev->addressbytes+1);

   if((flags & SF_BITSREVERSED) == 0)
   {
  		sfspi_xbitrev(buffer, len);
   }
	sfspi_xwrite(buffer, len);

   sf_disableCS(dev);

	return 0;
}

/*** BeginHeader sf_readRAM */
int sf_readRAM(char *buffer, int offset, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sf_readRAM                 <SFLASH.LIB>

SYNTAX: int sf_readRAM(char *buffer, int offset, int len);

DESCRIPTION:	Read data from the RAM buffer on the serial flash chip

PARAMETER1:    buffer - pointer to character buffer to copy data
						into
PARAMETER2:		offset - the address in the serial flash RAM to start
						reading from
PARAMETER3:		len - the number of bytes to read

RETURN VALUE:  0 for success
					-1 for error

END DESCRIPTION **********************************************************/


//buffer is equal to block size
_sflash_nodebug int sf_readRAM(char *buffer, int offset, int len)
{
	return sf_readDeviceRAM(&sf_dev, paddr(buffer), offset, len, 0x00);
}

/*** BeginHeader sf_readDeviceRAM */
int sf_readDeviceRAM(sf_device *dev,
                     long buffer,
                     int offset,
                     int len,
                     int flags);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sf_readDeviceRAM                 <SFLASH.LIB>

SYNTAX: int sf_readDeviceRAM(sf_device *dev,
                        long buffer,
                        int offset,
                        int len,
                        int flags);

DESCRIPTION:	Read data from the RAM buffer on the serial flash chip
					into an xmem buffer.

PARAMETER1:		dev - pointer to sf_device structure
PARAMETER2:		buffer - address of an xmem buffer
PARAMETER3:		offset - the address in the serial flash RAM to start
						reading from
PARAMETER4:		len - the number of bytes to read

PARAMETER5:		flags -
						SF_BITSREVERSED - Reads the data in bit reversed order from
                  	the flash chip. This improves speed, but the data must
                     have been also written in reversed order
                     (see sf_XWriteRAM)
                  SF_RAMBANK1(default) - Reads from the first RAM bank on
                  	the flash device
                  SF_RAMBANK2 - Reads from the alternate RAM bank on the
                  	flash device
RETURN VALUE:  0 for success
					-1 for error

END DESCRIPTION **********************************************************/


//buffer is equal to block size
_sflash_nodebug int sf_readDeviceRAM(sf_device *dev,
                                      long buffer,
                                		  int offset,
                                		  int len,
                                		  int flags)
{
   auto unsigned char command[7];
   auto int i;

#ifdef SFLASH_VERBOSE
	auto char temp_buf[20];

#endif




   if(len == 0)
   {
   	return 0; //don't read anything
   }

   if(dev->addressbytes > 5)
   {
   	return -1; //too many address bytes for command buffer
   }
   if(flags & SF_RAMBANK2)
   {
   	command[0] = '\xD6';
   }
   else
   {
		command[0] = '\xD4';
   }
   for(i = 1;i <= dev->addressbytes;i++)
   {
   	command[i] = (unsigned char)(offset >> (8*(dev->addressbytes - i)));
   }
   command[dev->addressbytes+1] = '\x00'; //add 'don't care' byte to end

   sf_enableCS(dev);

   sfspi_bitrev(command, dev->addressbytes+2);
   sfspi_write(command, dev->addressbytes+2);
   sfspi_xread(buffer, len);
   sf_disableCS(dev);
   if((flags & SF_BITSREVERSED) == 0)
   {
   	sfspi_xbitrev(buffer, len);
   }

#ifdef SFLASH_VERBOSE

	xmem2root(temp_buf, buffer, 20);
   temp_buf[19] = 0;
   printf("read '%s' from RAM\n", temp_buf);

#endif

	return 0;
}



/*** BeginHeader sf_RAMToPage */
int sf_RAMToPage(long page);

/* START FUNCTION DESCRIPTION ********************************************
sf_RAMToPage                 <SFLASH.LIB>

SYNTAX: int sf_RAMToPage(long page);

DESCRIPTION:	Command the serial flash to write it's RAM buffer contents
					to one of the flash memory pages

PARAMETER1:    page - the page to write the RAM buffer to

RETURN VALUE:  0 for success
					-1 for error, write operation timed out

END DESCRIPTION **********************************************************/

/*** EndHeader */


//max wait time in msec
#ifndef SF_PAGEWRITE_WAIT
#define SF_PAGEWRITE_WAIT 100
#endif

_sflash_nodebug int sf_RAMToPage(long page)
{
   auto unsigned long t;

	sf_writePage(&sf_dev, 1, page); //use bank 1
   t = MS_TIMER;
   while(sf_isWriting(&sf_dev))
   {
   	if( (MS_TIMER - t) > SF_PAGEWRITE_WAIT)
      {
      	return -1;
      }
   }
	return 0;
}

/*** BeginHeader sf_writePage */
int sf_writePage(sf_device *dev, int bank, long page);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sf_writePage                 <SFLASH.LIB>

SYNTAX: int sf_writePage(sf_device *dev, int bank, long page);

DESCRIPTION:	Replaces sf_RAMTOPage().
					Command the serial flash to write it's RAM buffer contents
					to one of the flash memory pages. Check for completion
               of the write operation using sf_isWriting().

PARAMETER1:		dev - pointer to initialized sf_device structure for
						 the flash chip
PARAMETER2:		bank - which RAM bank to write the data from. For Atmel
						45DBxxx devices, this can be 1 or 2
PARAMETER3:    page - the page to write the RAM buffer to

RETURN VALUE:  0 for success
					-1 for error

END DESCRIPTION **********************************************************/
_sflash_nodebug int sf_writePage(sf_device *dev, int bank, long page)
{
   auto unsigned char command[7];
   auto int i, rshift;

#ifdef SFLASH_VERBOSE
	printf("sf_writePage - write from bank %d to page %ld\n", bank, page);
#endif

   if(dev->addressbytes > 5)
   {
   	return -1; //too many address bytes
   }

   if(bank == 1)
   {
   	command[0] = '\x83';
   }
   else
   {
   	command[0] = '\x86';
   }
   for(i = 1;i < dev->addressbytes;i++)
   {
   	rshift = 8*(dev->addressbytes - i) - dev->pagebitshift;
   	if(rshift > 0)
      {
      	if(rshift > 16)
         {
         	command[i] = '\x00';
         }
         else
         {
         	command[i] = (unsigned char)(page>>rshift);
         }
      }
      else if(rshift < 0)
      {
      	if(rshift < -8)
         {
         	command[i] = '\x00';
         }
         else
         {
         	command[i] = (unsigned char)(page<<(-rshift));
         }
      }
      else
      {
      	//no shift
         command[i] = (unsigned char)page;

   	}
   }
   command[dev->addressbytes+1] = '\x00'; //extra zero byte

   sf_enableCS(dev);

   sfspi_bitrev(command, dev->addressbytes+2);
   sfspi_write(command, dev->addressbytes+2);

   sf_disableCS(dev);

	return 0;
}

/*** BeginHeader sf_isWriting */
int sf_isWriting(sf_device *dev);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sf_isWriting                 <SFLASH.LIB>

SYNTAX: int sf_isWriting(sf_device *dev);

DESCRIPTION:   Returns 1 if the flash device is busy writing to a page

PARAMETER1:		dev - pointer to initialized sf_device structure for
						 the flash chip

RETURN VALUE:  1 busy
					0 ready, not currently writing

END DESCRIPTION **********************************************************/

_sflash_nodebug int sf_isWriting(sf_device *dev)
{
   return !(sf_deviceStatus(dev) & 0x80);
}




/*** BeginHeader sf_pageToRAM */
int sf_pageToRAM(long page);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sf_pageToRAM                 <SFLASH.LIB>

SYNTAX: int sf_pageToRAM(long page);

DESCRIPTION:	Command the serial flash to copy the contents of one of
					it's flash pages into it's RAM buffer.

PARAMETER1:    page - the page to copy from

RETURN VALUE:  0 for success
					-1 for error

END DESCRIPTION **********************************************************/

_sflash_nodebug int sf_pageToRAM(long page)
{
   return sf_readPage(&sf_dev, 1, page);
}


/*** BeginHeader sf_readPage */
int sf_readPage(sf_device *dev, int bank, long page);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sf_readPage                 <SFLASH.LIB>

SYNTAX: int sf_readPage(sf_device *dev, int bank, long page);

DESCRIPTION:	Replaces sf_pageToRAM().
					Command the serial flash to copy from one it's flash pages
               to one of it's RAM buffers.

PARAMETER1:		dev - pointer to initialized sf_device structure for
						 the flash chip
PARAMETER2:		bank - which RAM bank to write the data to. For Atmel
						45DBxxx devices, this can be 1 or 2
PARAMETER3:    page - the page to read from

RETURN VALUE:  0 for success
					-1 for error

END DESCRIPTION **********************************************************/

_sflash_nodebug int sf_readPage(sf_device *dev, int bank, long page)
{
   auto unsigned char command[7];
   auto int i, rshift;

#ifdef SFLASH_VERBOSE
	printf("sf_readPage - read from page %ld to bank %d\n", page, bank);
#endif

   if(dev->addressbytes > 5)
   {
   	return -1; //too many address bytes
   }

   if(bank == 1)
   {
   	command[0] = '\x53';
   }
   else
   {
   	command[0] = '\x55';
   }
   for(i = 1;i < dev->addressbytes;i++)
   {
   	rshift = 8*(dev->addressbytes - i) - dev->pagebitshift;
   	if(rshift > 0)
      {
      	if(rshift > 8)
         {
         	command[i] = '\x00';
         }
         else
         {
         	command[i] = (unsigned char)(page>>rshift);
         }
      }
      else if(rshift < 0)
      {
      	if(rshift < -8)
         {
         	command[i] = '\x00';
         }
         else
         {
         	command[i] = (unsigned char)(page<<(-rshift));
         }
      }
      else
      {
      	//no shift
         command[i] = (unsigned char)page;

   	}
   }
   command[dev->addressbytes+1] = '\x00'; //extra zero byte

	sf_enableCS(dev);

   sfspi_bitrev(command, dev->addressbytes+2);
   sfspi_write(command, dev->addressbytes+2);

   sf_disableCS(dev);

	while((sf_deviceStatus(dev) & 0x80) == 0); //wait for RDY bit
	return 0;
}




/*** BeginHeader */
#endif
/*** EndHeader */


















