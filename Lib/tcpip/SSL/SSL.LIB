/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
SSL.LIB
	SSL Module, v. 1.04

DESCRIPTION: Primary Secure Sockets Layer (SSL) library for Dynamic C.
 This library contains the high-level API functions, as well as relevant
 data structure declarations.

 TASKS:
 	- Nagle-style algorithm for SSL?
   - Make non-reentrant functions reentrant (search for REENTRANT), these
     functions currently use static root buffers to avoid excessive stack
     usage
 	- Block cipher support
   - Certificate authentication (?)

 SSL relies on several libraries for functionalilty:
 	SSL:
	    SSL.LIB - This file, includes high-level API and data structures
	    SSL_ERROR.LIB - Error handling for SSL
       SSL_CERT.LIB - Certificate import and handling

	SSL versions:
	    SSL.LIB - Generic SSL function implementations
	    TLSV1.LIB - TLS Functionality and alerts
	    SSLv3.LIB - SSL version 3 support library

   Ciphers and Message digest:
	    HMAC.LIB - Secure message digest hashing routines for TLS
	    RSA.LIB - RSA public-key encryption routines (includes PKCS encoding)
	    ARITH.LIB - Multi-precision arithmetic for RSA
	    RC4.LIB - RC4 symmetric bulk cipher routines
       SHA.LIB - SHA-1 message digest implementation
       MD5.LIB - MD5 message digest implementation

   Testing, etc...:
   	 SSL_TEST.LIB - support functions for debugging SSL
       TLS_TEST.LIB - support for debugging TLS

 Relevant RFC: 2246

 Conventions:
 - Memory Management:
 		- Workspace buffer is in Xmem, and space is allocated from it
        via calls to _ssl_alloc
      - All variable-sized items are placed in the allocated xmem buffers
      - Fixed-size items (unless they are large) are placed in root
 - Error handling is as follows:
 		- Allocation functions return NULL on failure, address otherwise
      - Communications functions return the number of bytes read/written
        and return -1 otherwise
      - All other functions (which need error checking) return 0 on
        success, non-zero on failure
      - SSL_errno contains the error code when a failure occurs, its
        value is undefined otherwise
      - Errors propagate up the call stack by return value, intermediate
        functions should only pass the error along, and should not set
        SSL_errno

 NOTE: The initial Rabbit implementation of TLS does not meet the TLS
       specification in RFC 2246, since the TLS_RSA_WITH_3DES_EBE_CBC_SHA
       cipher suite is not supported, and there is no support for client-
       side SSL.

 Library revision history:
 Version 1.0
 	- Server TLS with RSA, RC4
   - No certificate authentication
   - primary target is HTTPS.
   - SSLv3
 Version 2.0 (planned)
  	- Client SSL
 Version 3.0 (planned)
 	- SSLv2 (3?) for extended compatibility (?)
	- 3DES (?)

 March 2003  - Created - TJS
 April 2003  - Initial Prototype (basic TLS, no cert or session mgmt) - TJS
 May 2003    - Prototype with session management -TJS
 June 2003   - Non-blocking handshake/reads/writes
 July 2003   - HTTPS integration with HTTP.LIB -TJS
 August 2003 - HTTPS/SSL Beta - TJS
 Sept 2003   - Added MAC checking  - TJS
 Oct 2003    - Began work on SSLv3 support - TJS
 Dec 2003    - Final revisions (including splitting this library into 3)

 The code in this library was tested using the OpenSSL (www.openssl.org)
 Open-Source SSL implementation.

END DESCRIPTION **********************************************************/

/*** BeginHeader */

#ifndef __SSL_LIB__
#define __SSL_LIB__

#if (_CPU_ID_ < R3000_R1)
#error "SSL is not supported on Rabbit processors before the R3000A " \
       "(R3000 rev. 1)"
#endif

// Standard module version macro
#define _SSL_VERS 0x0104

// Define macros for appropriate RAND.LIB usage
#define RAND_USE_MD5    // Rehash entropy buffer using MD5 if exhausted
#define NET_ADD_ENTROPY // Use packet timings as entropy source

// Libraries used by SSL
#use "SSL_CERT.LIB"
#use "RAND.LIB"

// Message Digest library
#use "HMAC.LIB"

// Cipher libraries
#use "RC4.LIB"
#use "RSA.LIB"
//#use AES.LIB // DEVIDEA: Block ciphers are not currently supported

// Debugging for SSL functions
#ifdef SSL_DEBUG
	#define __SSL_DEBUG__ debug
   #define _ssl_assert(exp) assert(exp)
#else
	#define __SSL_DEBUG__ nodebug
   #define _ssl_assert(exp)        // Define to nothing
#endif

// Print debugging information to STDOUT
#ifndef _SSL_PRINTF_DEBUG
#define _SSL_PRINTF_DEBUG 0
#endif

// Print debugging information for SSL memory management
#ifndef _SSL_ALLOC_DEBUG
#define _SSL_ALLOC_DEBUG 0
#endif

// Default for non-RabbitSys modes in older DC versions
#ifndef __RABBITSYS
#define __RABBITSYS 0
#endif

////////////////////////////////////////////////////////////////////////////////
// SSL User-Modifiable Macros
////////////////////////////////////////////////////////////////////////////////

// SSL_CERTIFICATE is the default certificate name, and it is assumed to be
// an ximported certificate
#ifdef SSL_CERTIFICATE
#define _SSL_CERTIFICATE_ SSL_CERTIFICATE
#endif

#ifndef SSL_MAX_CONNECTIONS
#define SSL_MAX_CONNECTIONS    1 // Currently, only 1 connection allowed
#endif									// Eventually this value will be variable
                                 // more connections == more memory usage

#define SSL_NO_SESSION_RENEGOTIATION 0 // Change this to 0 to allow session
                                       // resumption, change to 1 to prohibit
                                       // clients from renegotiating a
                                       // connection

#define SSL_MAX_SESS_RESUMES 10 // The maximum number of sessions to save
										  // for reconnects before old copies are
                                // removed from the session resume cache

#define SSL_WORKSPACE_SIZE 0x2000 // SSL workspace size. This defines the amount
											 // of xmem given to each SSL connection for
                                  // internal buffers. It is user-modifiable,
                                  // but only to allow easy correction for
                                  // ran-out-of-space errors

#define SSL_READ_BUF_SIZE 0x4000	// The maximum size of a SSL record is 16KB,
											// so allocate a 16KB xmem buffer for non-
                                 // blocking reads. This may be adjusted to
                                 // dcrease memory usage, at the risk of not
                                 // being able to read an entire reocrd (if
                                 // that record is too large).

#define SSL_TEMP_BUF_SIZE 0x100	// SSL root buffer size. This determines the
										   // size of root buffers (on the stack) used by
                                 // a few SSL functions to retrieve data from
                                 // the xmem buffers. Larger sizes should
                                 // increase performance, smaller will reduce
                                 // stack usage

#define SSL_WRITE_BUF_SIZE 0x800  // 2KB is max allowed internal record size
                                  // This is much smaller than the allowed
                                  // record size in the SSL spec, but since we
                                  // can control the size of records written,
                                  // we can make the write buffer much smaller

// SSL-specific macros
// These maximums are not according to the SSL spec. To conserve memory, these
// instead reflect "normal" message maximums. These can be increased to support
// larger messages, at the expense of memory. (Use in conjunction with the
// workspace size, below)

// Maximum size handshake message (not including certificate messages)
#define SSL_MAX_HANDSHAKE_SIZE		0x200

// Internal buffer maximum (1KB)
#define SSL_MAX_RECORD_DATA_LENGTH  0x400

// Ciphersuite priorities, 0 is lowest priority (setting a priority to 0
// means that selecting that suite results in a run-time error)
// Modify these to change selection order of ciphersuites
// !!WATCH OUT! HIT MACRO MAX LENGTH = 32 chars!!
#define TLS_NULL_NULL_NULL_PRI 			  0 // TLS_NULL is used as an error
#define TLS_RSA_RC4_128_MD5_PRI 			  1
#define TLS_RSA_RC4_128_SHA_PRI 			  2
#define TLS_RSA_DES_CBC_SHA_PRI 		     0 // These suites currently unsupported
#define TLS_RSA_3DES_EBE_CBC_SHA_PRI 	  0
#define TLS_DH_DSS_3DES_EDE_CBC_SHA_PRI  0
#define TLS_DH_anon_3DES_EDE_CBC_SHA_PRI 0
#define TLS_RSA_AES_128_CBC_SHA_PRI 	  0
#define TLS_DH_anon_AES_128_CBC_SHA_PRI  0


////////////////////////////////////////////////////////////////////////////////
// End User-modifiable macros
////////////////////////////////////////////////////////////////////////////////

#define SSL3_VER_MAJ 3 // SSLv3 version number is 3.0
#define SSL3_VER_MIN 0

// SSL uses a UNIX 32-bit time stamp (epoch 1970), but the DC RTC has
// an different epoch (1980). This value is the number of seconds in 10
// years, plus the 2 days for leap years in 1972 and 1976
// (60 * 60 * 24 * 365 * 10) + (60 * 60 * 24 * 2)
#define RTC_EPOCH_DIFF 0x12CEA600L

// ********************************************************
// *****                TLS Defaults                  *****
// ********************************************************

#define TLS1_VER_MAJ 3 // TLSv1 version number is 3.1
#define TLS1_VER_MIN 1

// Supported cipher suites
#define TLS_NULL_WITH_NULL_NULL 			   0x0000
#define TLS_RSA_WITH_RC4_128_MD5 			0x0004
#define TLS_RSA_WITH_RC4_128_SHA 			0x0005

// Currently unsupported cipher suites
#define TLS_RSA_WITH_DES_CBC_SHA 		   0x0009 // DES not supported
#define TLS_RSA_WITH_3DES_EBE_CBC_SHA 	   0x000A // 3DES not currently supported
#define TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA  0x000D // Diffie-Hellman not supported
#define TLS_DH_anon_WITH_3DES_EDE_CBC_SHA 0x001B
#define TLS_RSA_WITH_AES_128_CBC_SHA 	   0x002F // AES CBC not supported yet
#define TLS_DH_anon_WITH_AES_128_CBC_SHA  0x0034

// Bulk cipher algorithms
#define TLS_CIPHER_NONE 			0
// #define TLS_CIPHER_3DES_EBE_CBC 	1  // 3DES unsupported
// #define TLS_CIPHER_AES_128_CBC 	2  // AES CBC unsupported
#define TLS_CIPHER_RC4_128       3

// Key exchange methods
#define TLS_KX_NONE 	    	0
#define TLS_KX_RSA_512 		1
#define TLS_KX_RSA_1024    2
// #define TLS_KX_DH_anon 	3 // Diffie-Hellman not supported
// #define TLS_KX_DH 		4

// authentication algorithms
#define TLS_AUTH_NONE 	0
#define TLS_AUTH_RSA 	1
// #define TLS_AUTH_DSS 	2 // DSS not supported

// Message digest algorithms
#define TLS_DIGEST_NONE 0
#define TLS_DIGEST_SHA  1
#define TLS_DIGEST_MD5  2

// Reserve bytes in the circular buffer so we have room to build a record
// without running out of room. These are the constant default valued for
// the reserve sizes, they may be changed at runtime to meet conditions
// (such as adding the cipher block size to the footer)
// We need to reserve an extra few bytes at the footer so that we do not
// overrun the circular buffer if it fills up
#define SSL_WR_HEADER_RESERVE (sizeof(SSL_Record_Hdr))
#define SSL_WR_FOOTER_RESERVE (SSL_MAX_HASH_SIZE + 10)

#define SSL_HS_SERVER_REPLY 0x016F

// ********************************************************
// *****          SSL/TLS limits and types            *****
// ********************************************************

// Message digest sizes
#define SSL_MAX_HASH_SIZE	20

// These maximums are according to spec to check for errors
#define SSL_MAX_RECORD_SIZE 0x3FFF // Maximum length of a TLS record = 2**14-1

#define SSL_MAX_SESSION_ID       32 // The maximum size for the SSL session ID
#define SESS_ID_SEED_SIZE         6 // The size of the Session ID input seed
#define SSL_SEQ_NUM_SIZE          8 // 64 bits = 8 bytes for sequence number
#define SSL_MAX_CIPHER_BLOCK     20 // Maximum block cipher block size (bytes)
#define SSL_MAX_CIPHER_KEY	  	  128 // Maximum key size (bytes) for bulk ciphers

// Secret data sizes
#define SSL_PRE_MASTER_SEC_SIZE  46 // Size of pre master secret random data
#define SSL_MASTER_SEC_SIZE		48 // Size of master secret
#define SSL_KEY_BLOCK_SIZE      104 // Maximum size of the key material block
#define SSL_RANDOM_SIZE          28 // Number of random bytes
#define SSL_MAX_MACSECRET		  128 // Maximum size for MAC secrets

// This is used to define an internal buffer for key derivation
#define SSL_SEEDED_LABEL_MAX (16 + (sizeof(SSL_Random)*2))

// Session ID seed constants
#define SESSION_ID_SEED_1 "\xD9\xC1\xC2\xC2\xC9\xE3"
#define SESSION_ID_SEED_2 "\xC4\xD3\xD9\xD6\xE6\xE9"

// Primitive types
typedef unsigned char SSL_byte_t;	// 8 bits
typedef unsigned int  SSL_uint16_t; // 16 bits (unsigned)
typedef unsigned long SSL_uint32_t; // 32 bits (unsigned)
typedef int				 SSL_int16_t;  // 16 bits (signed)
typedef long			 SSL_int32_t;  // 32 bits (signed)

// State information for the ssl_Socket data structure and
// handshake state machine
typedef enum {
  SSL_STATE_INIT,             // SSL state is initialized, but unused
  SSL_STATE_HS_LISTEN,			// SSL is listening for a ClientHello
  SSL_STATE_HANDSHAKE,        // SSL is in handshake processing state
  SSL_STATE_CH_CIPHER_SPEC,   // Record layer processed a ChangeCipherSpec
  SSL_STATE_ENC_HANDSHAKE,    // SSL Encrypted handshake state
  SSL_STATE_SESSION_RESUME,   // SSL session resume request (handshake)
  SSL_STATE_SESS_RES_CH_SPEC, // Received ChangeCipherSpec during session resume
  SSL_STATE_ENC_SESS_RES,     // SSL session resume (encrypted handshake msg)
  SSL_STATE_SSL2_HANDSHAKE,   // SSLv2-compatible handshake
  SSL_STATE_APP_DATA,         // SSL is sending/receiving application data
  SSL_STATE_ENC_ALERT,        // Used to send encrypted alerts
  SSL_STATE_ERROR,            // Some error has occured, stop all processing
  SSL_STATE_SERVER_REPLY,     // SSL server reply message, similar to alert
  SSL_STATE_WAIT_CLOSE,       // Waiting for close_notify alert from the client
//  SSL_STATE_WC_SAVE_SESSION,  // Wait for close, but save the session
  SSL_STATE_DONE              // SSL connection is closed, should not be used
	                           // until reinitialized
} SSL_state_t;

// Read states for non-blocking reads
typedef enum {
	SSL_RDSTATE_HEADER,  // Currently reading a header
   SSL_RDSTATE_RECORD	// Currently reading a record
} _ssl_read_state_t;

// States for MAC generation
typedef enum {
	SSL_MAC_SEND,  		// Generate a MAC to send in a record
	SSL_MAC_RECEIVE   	// Generate a MAC to use to compare to a received MAC
} _ssl_MAC_mode_t;

// Sender state for finished MAC generation
typedef enum {
   SSL_FMAC_CLIENT,		// The sender is a client
   SSL_FMAC_SERVER  		// The sender is a server
} _ssl_MAC_sender_t;

// Enum to differentiate client and server
typedef enum {
	SSL_MODE_NONE,          // State is initialized, but unused
	SSL_MODE_ASCII,			// ASCII-mode socket
	SSL_MODE_BINARY,        // Binary-mode socket
	SSL_MODE_SERVER_BINARY, // State represents an SSL server in binary mode
	SSL_MODE_SERVER_ASCII,  // State represents an SSL server in ASCII mode
	SSL_MODE_CLIENT_BINARY, // State represents an SSL client in binary mode
	SSL_MODE_CLIENT_ASCII   // State represents an SSL client in ASCII mode
} SSL_mode_t;

// Record content type enum
typedef enum {
	SSL_REC_change_cipher_spec = 20,
   SSL_REC_alert              = 21,
   SSL_REC_handshake          = 22,
   SSL_REC_application_data   = 23
} SSL_ContentType;

// Handshake message type
typedef enum {
	hello_request 		  = 0,
   client_hello  		  = 1,
   server_hello		  = 2,
   certificate   		  = 11,
   server_key_exchange = 12,
   certificate_request = 13,
   server_hello_done   = 14,
   certificate_verify  = 15,
   client_key_exchange = 16,
   finished            = 20,
   server_request      = 90,
   // length = 255 = 1 byte
} TLS_HandshakeType;
typedef char SSL_Handshake_t;

// Compression method type, currently none exist
typedef enum {
	null = 0,
   // length = 255 = 1 byte
} SSL_CompressionMethod;

// ********************************************************
// *****    SSLv2 Record Layer Data structures        *****
// ********************************************************

// NOTE: SSL version 2 is not currently supported as a
//       protocol. However, in order to communicate with
//       many SSL/TLS implementations, we need to be able
//       to parse an SSLv2 record for the initial client
//       hello, so we provide the basic data structures for
//       the SSLv2 record and client hello only.

// Primitive types
typedef unsigned char SSLv2_byte_t;	  // 8 bits
typedef unsigned int  SSLv2_uint16_t; // 16 bits (unsigned)
typedef unsigned long SSLv2_uint32_t; // 32 bits (unsigned)
typedef int				 SSLv2_int16_t;  // 16 bits (signed)
typedef long			 SSLv2_int32_t;  // 32 bits (signed)

// Protocol version
typedef struct {
	SSLv2_byte_t major;
   SSLv2_byte_t minor;
} SSLv2_ProtocolVersion;

// SSLv2 record header, for initial handshake message from client
typedef struct {
 	SSLv2_uint16_t 		 length;    			 // SSLv2 has length first
	SSLv2_byte_t   		 rec_type;  			 // Record type
	SSLv2_ProtocolVersion version;				 // Protocol version
} SSLv2_Record_Hdr;

// SSLv2 client hello, for initial handshake messages
typedef struct {
//	SSLv2_Record_Hdr header;		  		 // SSLv2 record header
   SSLv2_uint16_t   ciphersuite_length; // Length(bytes) of ciphersuite offers
   SSLv2_uint16_t   session_id_length;	 // Session ID length
	SSLv2_uint16_t   challenge_length;   // Length(bytes) of SSLv2 challenge
   SSLv2_byte_t*	  session_id;    		 // Session ID pointer
   SSLv2_uint16_t*  cipher_suites; 		 // Ciphersuite offers
   SSLv2_byte_t*    challenge; 	  		 // SSLv2 challenge data
} SSLv2_ClientHello;

// ********************************************************
// *****      SSL Record Layer Data structures        *****
// ********************************************************

// Protocol version
typedef struct {
	SSL_byte_t major;
   SSL_byte_t minor;
} SSL_ProtocolVersion;

// SSL Record header structure
typedef struct {
	SSL_byte_t          rec_type;// Record type
	SSL_ProtocolVersion version; // Record protocol version
	SSL_uint16_t        length;  // The length of the record (2 bytes)
} SSL_Record_Hdr;

// ********************************************************
// *****        Cross-Version Data structures         *****
// ********************************************************

// Generic header union, used to eliminate copying when working
// with different header versions
typedef union {
   	// Note: The following elements MUST all be the same size,
      // or this will not work.
	   SSL_Record_Hdr v3;   // SSLv3/TLS header
		SSLv2_Record_Hdr v2; // SSLv2-compatible record header
} ssl_Header;  					// Header of current record being read

// ********************************************************
// *****   TLS Handshake Protocol Data structures     *****
// ********************************************************

// Random data structure for Hello messages
typedef struct {
	SSL_uint32_t gmt_unix_time;
   SSL_byte_t   random_bytes[SSL_RANDOM_SIZE];
} SSL_Random;

// PreMasterSecret data structure
typedef struct {
	SSL_ProtocolVersion client_version;		   			  // SSL (TLS) version
   SSL_byte_t          random[SSL_PRE_MASTER_SEC_SIZE]; // The secret
} SSL_PreMasterSecret;

// Master secret structure
typedef struct {
	SSL_uint16_t length;							 // Length of value in bytes
   SSL_byte_t   data[SSL_MASTER_SEC_SIZE]; // The secret data (should point to
                                           // an array of "length" bytes)
} SSL_Secret;

// Client Hello message structure
typedef struct {
  SSL_ProtocolVersion client_version; // SSL (TLS) version
  SSL_Random 	 random;				     // Random data for key
  SSL_byte_t  	 session_id_length;	  // Session ID length
  long			 session_id;  		     // Session ID pointer (xmem)
  SSL_uint16_t  ciphersuite_length;   // Length(bytes) of ciphersuite offers
  long			 cipher_suites; 		  // Ciphersuite offers (in xmem)
  SSL_byte_t	 compression_length;   // Length of compression method offers
  long   		 compression_methods;  // compression method offers (in xmem)
} SSL_ClientHello;

// Server hello message
typedef struct {
	SSL_ProtocolVersion 	 server_version;	   // Server SSL (TLS) version
   SSL_Random			    random;				   // Server random
   SSL_byte_t            session_id_length;  // session id length
   long				    	 session_id;         // pointer to session ID data
   SSL_uint16_t	    	 cipher_suite;       // ciphersuite choice
   SSL_byte_t			    comp_meth_length;	// Compression methods length
   SSL_CompressionMethod compression_method; // compression method choice
} SSL_ServerHello;

// Certificate handshake message
/*
typedef struct {
	SSL_byte_t*  cert;		// Pointer to certificate data
   SSL_byte_t   length[3]; // Length of certificate
} TLS_Certificate;
*/

// Client Key exchange handshake message
// NOTE: We do not support Diffie-Hellman, which simplifies
//       this data structure.
typedef struct {
	SSL_PreMasterSecret exchange_keys; // UNencrypted pre master secret
} SSL_ClientKeyExchange;

/* DEVIDEA: This structure is not ever used
typedef struct {
	SSL_byte_t verify_data[TLS_VERIFY_DATA_SIZE];
} SSL_Finished;
*/

// Handshake message header
typedef struct {
	SSL_Handshake_t msg_type;  // The handshake message type
   SSL_byte_t      length[3]; // Length is an unsigned 24-bit integer
} SSL_Handshake_Hdr_t;

// TLS finished hash structure
typedef struct {
   md5_state_t	md5_hash; // MD5 hash for finished calc
   sha_state	sha_hash; // SHA-1 hash for finished calc
} SSL_Finish_Hash_t;

// ********************************************************
// *****      TLS Configuration Data structures       *****
// ********************************************************

// CipherSuite configuration
typedef struct {
	SSL_uint16_t suite_number;  		// SSL standard ciphersuite number
	char* fulltext_name;      			// Text name of ciphersuite
	SSL_uint16_t key_exchange_alg;   // Key exchange algorithm (ie RSA)
	SSL_uint16_t authentication_alg; // Authentication algorithm (certificates)
	SSL_uint16_t bulk_cipher_alg;    // The bulk cipher used (DES, RC4)
	SSL_uint16_t digest_alg;         // The MAC digest (MD5, SHA-1)
} SSL_SuiteConfig;

typedef struct {
	SSL_uint16_t key_size;			// Size of the public key being used
	SSL_uint16_t (*encrypt)();    // Public key encrypt function
	SSL_uint16_t (*decrypt)();    // Public key decrypt function
} SSL_KeyExchangeConfig;

/* This implementation currently does not do certificate verification
   But keep this for when we do support verification
typedef struct {
	SSL_uint16_t key_size;
	SSL_uint16_t (*sign)();   //(private_key, message, message_length, signature)
	SSL_uint16_t (*verify)(); //(public_key, message, message_length, signature)
} SSL_AuthConfig;
*/

// Union of cipher states
typedef union {
     RC4_state_t rc4_state;  // RC4 stream cipher read state
} SSL_BulkCipherState;

// Bulk cipher configuration                       `
typedef struct {
   SSL_BulkCipherState read_state;  // Union of cipher states for reading
   SSL_BulkCipherState write_state; // Union of cipher states for writing
	SSL_uint16_t key_size; 			   // Symmetric cipher has constant key size
	SSL_uint16_t block_size;   		// 0 for stream ciphers
   SSL_byte_t   direction; 			// Cipher direction
	SSL_byte_t   server_iv[SSL_MAX_CIPHER_BLOCK]; // Initialization Vector
	SSL_byte_t   server_key[SSL_MAX_CIPHER_KEY];	 // The client bulk cipher key
	SSL_byte_t   client_iv[SSL_MAX_CIPHER_BLOCK]; // Initialization Vector
	SSL_byte_t   client_key[SSL_MAX_CIPHER_KEY];	 // The client bulk cipher key
	int (*init)(); 				// (cipher_state, direction, key, key_len, iv)
	int (*encrypt)();  			// (cipher_state, in, out, len)
	int (*decrypt)(); 			// (cipher_state, in, out, len)
} SSL_BulkCipherConfig;

// Digest algorithm configuration (TLS uses HMAC as its digest algorithm
typedef struct {
	SSL_uint16_t hash_size; // Size of the output hash
   HMAC_ctx_t   state;		// The HMAC context for this digest
	int (*init)();    		//(digest_state, secret, secret_len, in, in_len)
	int (*add)();				//(digest_state, in, in_length)
	int (*finish)();			//(digest_state, hash_value)
} SSL_DigestConfig;

// handles a read or write state, passed into record read/write functions
typedef struct {
   SSL_SuiteConfig*       suite;			 // The current ciphersuite
   SSL_KeyExchangeConfig* key_exch;     // Key exchange information
// DEVIDEA: Certificate authentication is not yet supported
//   SSL_AuthConfig*		  auth;			 // Certificate authentication
	SSL_BulkCipherConfig*  bulk_cipher;	 // The bulk cipher algorithm
	SSL_DigestConfig*      digest;		 // MAC digest algorithm
   SSL_byte_t      session_id_length;  				   // session id length
   SSL_byte_t		 session_id[SSL_MAX_SESSION_ID];    // session ID data
   SSL_Random      server_random;						   // Server random value
   SSL_Random      client_random;                     // Client random value
	SSL_byte_t      server_mac_sec[SSL_MAX_MACSECRET]; // server MAC secret
	SSL_uint16_t	 server_mac_sec_size;					// size of MAC secret
	SSL_byte_t      client_mac_sec[SSL_MAX_MACSECRET]; // The client MAC secret
	SSL_uint16_t	 client_mac_sec_size;					// size of MAC secret
	SSL_byte_t      seq_number[SSL_SEQ_NUM_SIZE];      // Sequence numeber
                                                      // (total = 64 bits)
	SSL_byte_t      rd_seq_number[SSL_SEQ_NUM_SIZE];   // Sequence numeber for
                                                      // reads (total = 64 bits)
} SSL_CipherState;

// SSL communication state (should match up with TCP API)
typedef struct {
	int (*init)(); 		 // Initialize communications
	int (*write)(); 		 // Send some data
	int (*read)();   		 // Read some data
	int (*xwrite)(); 		 // Send some data (using xmem buffer)
	int (*xread)();   	 // Read some data (using xmem buffer)
   int (*close)();    	 // Close the communications channel
   int (*s_abort)();		 // Abort the comm channel right now
   int (*tick)();    	 // Make sure the connection is responding
   int (*bytesready)();  // See if there is data ready
   int (*established)(); // See if the communications channel is open
} SSL_CommConfig;

#if !SSL_NO_SESSION_RENEGOTIATION
// Session resumption struct
// This structure is used to cache the necessary information
// for session resumption. The cache itself is an array of
// these structrues, in which old items are removed in a
// round-robin fashion.
typedef struct {
#if __RABBITSYS > 0
	tcp_Socket            sock;		     // TCP socket
#endif
   SSL_uint16_t suite_number;  	  // SSL standard ciphersuite number
   SSL_Secret   master_secret;     // The master secret used in finished calc
   SSL_byte_t   session_id_length; // session id length
   SSL_byte_t	 session_id[SSL_MAX_SESSION_ID]; // session ID data
} SSL_Session_Resume_t;

extern SSL_Session_Resume_t SSL_session_cache[SSL_MAX_SESS_RESUMES];
#endif

// Workspace data structure, used by _ssl_alloc and _ssl_free to
// provide workspace buffer memory for dynamic allocation
// SSL_WORKSPACE_SIZE is a user-modifiable macro
// The workspace buffer is in xmem to alleviate root data usage
// and is xalloced at initislization (ssl_init)
typedef struct {
	SSL_uint16_t cur_index; // Current index into buffer
	unsigned long cur_ptr;  // Current location in buf
  	unsigned long buf_ptr;  // Pointer to Xmem buffer
} SSL_Workspace;

// Current read state, holds pointers into the primary circular read
// buffer, as well as other state information
typedef struct {
	_ssl_read_state_t state; // Current read state
   char saw_cr;				 // Did we see a '\r' on the last call to ssl_gets?
	long read_buf;  			 // Pointer to start of buffer
	long end_read_buf;    	 // Pointer to end of buffer (for fast compares)
	long start_enc;       	 // Start of encrypted data (end of decrypted data)
	long end_enc;         	 // End of encrypted data
	long start_dec;       	 // Start of decrypted data
   SSL_uint32_t bytes_remaining; // Number of bytes left to read in read state
	long msg_mac; 		  		 // Temporary buffer for message MAC
	ssl_Header header;		 // Generic header type (may be TLS, SSLv3 or SSLv2)
} SSL_Read_State_t;

// Write state data structure, contains pointers into the circular
// write buffer
typedef struct {
	long write_buf;  		 // Pointer to start of buffer
	long end_write_buf;   // Pointer to end of buffer
	long start_data;      // Start of unencrypted raw data
	long end_data;        // End of raw data
	long start_enc;       // Start of encrypted data
   long footer_reserve;	 // The number of bytes to reserve when adding raw data
                         // (MAC size + block cipher padding)
	long header_reserve;	 // This is really a constant, but may change someday
   							 // (size of SSL_Record_Hdr)
} SSL_Write_State_t;

// Define a structure for the resource allocation pool
// Note that none of the members are pointers, since we
// actually want to allocate the space for these
// We want to zero-out most of the structure for security
// reasons, but we have some xalloc'ed resources we need to
// preserve, so the #define's define an area to be zero'ed out
// when _ssl_cleanup is called
typedef struct {
#define SSL_FIRST_FIELD_TO_ZERO	  	     used
	int used; 				  					  // In-use flag
	SSL_CipherState 		 cipher;		     // Cipher suite resources
	SSL_CommConfig  		 comm;           // Communication resources
   SSL_SuiteConfig       suite;		     // The current ciphersuite
   SSL_KeyExchangeConfig key_exch;       // Key exchange information
// DEVIDEA: Certificate authentication is not yet supported
//   TLS_AuthConfig		    auth;	     // Certificate authentication
	SSL_BulkCipherConfig  bulk_cipher;    // Bulk cipher resources
	SSL_DigestConfig      digest;         // message digest resources
   SSL_Secret            master_secret;  // The master secret
	SSL_Finish_Hash_t     fin_hash_read;  // The finish hash for handshake
	SSL_Finish_Hash_t     fin_hash_write; // The finish hash to send
   SSL_Cert_t 				 cert;			  // Certificate structure
#define SSL_FIRST_FIELD_NOT_TO_ZERO      workspace
   tcp_Socket            sock;		     // TCP socket
   SSL_Workspace			 workspace;	  	  // Memory management for SSL
   SSL_Read_State_t      read_state;     // Non-blocking read state
   SSL_Write_State_t		 write_state; 	  // Non-blocking write state
} ssl_ResourcePool_t;

// Resource pools for TLS
extern ssl_ResourcePool_t ssl_ResourcePool[SSL_MAX_CONNECTIONS];

// The "Master" TLS state struct. This should be defined by the user
// and set up by a call to TLS_listen
typedef struct {
	tcp_Socket*        sock;		  	// TCP socket
   SSL_state_t 	    cur_state; 	// Identifying value for current state
   char               is_ssl_v3;		// This flag is initially false, set to
                                    // true when using SSLv3
   SSL_mode_t 		    ssl_mode;		// Identifies this state as client or server
   SSL_Read_State_t*  read_state;	// Read state, for non-blocking reads
   SSL_Write_State_t* write_state;	// Write state for non-blocking writes
	SSL_CipherState*   cipher_state; // Current ciphersuite state
	SSL_CommConfig*    comm_state;	// Current communication state
   SSL_Cert_t*        cert;			// The local certificate (see TLS_CERT.LIB)
   SSL_Secret*        master_secret;  // The master secret used in finished calc
	SSL_Finish_Hash_t* fin_hash_read;  // The finish hash for handshake verify
	SSL_Finish_Hash_t* fin_hash_write; // The finish hash to send (the same hash)
   SSL_Workspace*     workspace;		  // Memory management
	int 				    resource_index; // The index into the resource pool
                                		  // (used for freeing resources in
                                		  //  ssl_close) -1 indicates uninitialized
} ssl_Socket;

// Include protocol version-specific libraries
#use "TLSV1.LIB"
#use "SSLV3.LIB"

// SSL Error handling
#use "SSL_ERROR.LIB"


// ********************************************************
// *****             SSL Utility Macros               *****
// ********************************************************

// See if a TLS session has terminated normally
#define ssl_is_done(state)      ((state)->cur_state == SSL_STATE_DONE)
#define ssl_error(state)        ((state)->cur_state == SSL_STATE_ERROR)
#define ssl_in_handshake(state) (((state)->cur_state >= SSL_STATE_HANDSHAKE) && \
                                 ((state)->cur_state <= SSL_STATE_SSL2_HANDSHAKE))

// Convert a long (src) into a 24-bit network integer (an array of 3 bytes)
#define ulton24(dst, src) \
   dst[0] = (char)(((src) & 0x00FF0000L) >> 16); \
   dst[1] = (char)(((src) & 0x0000FF00L) >> 8);  \
   dst[2] = (char) ((src) & 0x000000FFL);

// Convert a 24-bit network integer to long
#define n24toul(x) \
	(((unsigned long)x[0]) << 16) + \
   (((unsigned long)x[1]) << 8)  + \
     (unsigned long)x[2];

// ********************************************************
// *****                SSL Libraries                 *****
// ********************************************************

#use "SSL_COMM.LIB"
#use "SSL_HS.LIB"

/*** EndHeader */

////////////////////////////////////////////////////////////////////////////////
// SSL Run-time Processor Check
////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader _ssl_cpu_check */
void _ssl_cpu_check(void);
/*** EndHeader */

// This function checks for a Rabbit 3000A or better processor, and jumps
// into an error loop with a watchdog timer reset to error out if the
// processor is not compatible
void _ssl_cpu_check(void)
{
#if (CPU_ID_MASK(_CPU_ID_) >= R4000)
	// All Rabbit 4000 and better CPUs support SSL
	return;
#else
#asm
	;; error out if processor does not support SSL (specifically the UMA inst)
   ioi   ld a, (GCPU)    ; Get processor version
   and   0x1f            ; Mask out top bits
   cp    0x0				 ; Check for 3000
	jp    z, .SSL_xexit   ; Not a 3000 or better? Error out
   ioi   ld a, (GREV)    ; Get processor revision
   and   0x1f            ; Mask out top bits
   cp    0x0             ; Test for R3000 Rev A or better
   jp    z, .SSL_xexit   ; Not a 3000A? jump to auto-crash loop
	jp    .SSL_cpu_ret    ; No errors? Exit to program
.SSL_xexit:
   ipset 3               ; Suppress interrupts
   ld    a,0x00          ; Reset watchdog to timeout in loop below
   ioi   ld (WDTTR),a
.SSL_xexit_loop:         ; Error-out loop
   jr		.SSL_xexit_loop
.SSL_cpu_ret:            ; Exit to program
#endasm
#endif
}

////////////////////////////////////////////////////////////////////////////////
// SSL Memory Management
////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader _ssl_alloc, _ssl_free */
unsigned long _ssl_alloc(ssl_Socket*, SSL_uint16_t);
void _ssl_free(ssl_Socket*, SSL_uint16_t);
/*** EndHeader */

// *********************************************************
// SSL Resources (must be located in the _ssl_alloc module)
// *********************************************************

// Static pool for allocating resources. The type of this pool is
// a structure containing all the resources that need to be allocated
// internally by TLS
ssl_ResourcePool_t ssl_ResourcePool[SSL_MAX_CONNECTIONS];

// _ssl_alloc allocates a block of memory from the current state's workspace
// (state is passed in as parameter 1). Blocks are freed using _ssl_free
// Parameter 1: Pointer to SSL state structure
// Parameter 2: The size of the block to allocate
// Return value: xmem address of the beginning of the block (which consists
//               of free, consecutive bytes up to the return value + len)

// _ssl_free frees a block of data in a states workspace. Note that this
// function only frees a number of bytes from the current position, rather
// than keeping track of pointers like malloc. See the warning below for
// more information.
// Parameter 1: Pointer to SSL state structure
// Parameter 2: The number of bytes to free
// Return value: None

// WARNING! These functions are a little dangerous. They should
// be called in reverse order, for example:
// buf1 = _ssl_alloc(size1)
// buf2 = _ssl_alloc(size2)
// _ssl_free(size2)
// _ssl_free(size1)
// Doing this prevents the workspace->cur_ptr from
// ending up at strange locations within other buffers

// Allocate some buffer space
__SSL_DEBUG__
unsigned long _ssl_alloc(ssl_Socket* state, SSL_uint16_t len) {
	auto unsigned long ret_ptr;
	auto SSL_Workspace* workspace;

   workspace = state->workspace;
	if((workspace->cur_index + len) < SSL_WORKSPACE_SIZE) {
   	// Avoid using pointer arithmetic with integer index
    	ret_ptr = workspace->cur_ptr;
		workspace->cur_index += len;
      workspace->cur_ptr = workspace->buf_ptr + workspace->cur_index;
#if _SSL_ALLOC_DEBUG
      printf("----->Allocating %d, Current allocated: %d\n", len,
             workspace->cur_index);
#endif
      return ret_ptr;
   }

   // Could not allocate, exit
	SSL_error(state, SSL_ALLOC_FAIL);
   return 0; // No space allocated
}

// Return some space to the workspace pool
__SSL_DEBUG__
void _ssl_free(ssl_Socket* state, SSL_uint16_t len) {
	auto SSL_Workspace* workspace;

	// DEVIDEA: For security, we could zero-out
   // the used buffer space at this point

   workspace = state->workspace;

#if _SSL_ALLOC_DEBUG
   printf("----->Trying to free: %d\n", len);
#endif
   // Adjust our index
   if(len <= workspace->cur_index) {
		workspace->cur_index -= len;
   }
   else {
#if _SSL_ALLOC_DEBUG
   	printf("----->Deallocate error: Should not happen<-----\n");
#endif
		workspace->cur_index = 0;
   }

   // Reset our pointer
  	workspace->cur_ptr = workspace->buf_ptr + workspace->cur_index;
}

////////////////////////////////////////////////////////////////////////////////
// SSL Initialization
////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader ssl_init */
void ssl_init(ssl_Socket* state);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_init                               <SSL.LIB>

SYNTAX: void ssl_init(ssl_Socket* state);

DESCRIPTION: Initialize an SSL socket for use. This function should only
             be called once at the beginning of the program, to allocate
             resources and initialize the SSL socket.

PARAMETER 1: Pointer to SSL socket structure

RETURN VALUE: None

END DESCRIPTION **********************************************************/

// Set up one-time (per program) data structures (xalloc)
__SSL_DEBUG__
void ssl_init(ssl_Socket* state) {
	auto int i;
	#GLOBAL_INIT {
 		// At program startup, initialize the resources
		memset(&ssl_ResourcePool, 0, sizeof(ssl_ResourcePool));

      // At program startup, initialize the random number generator
      seed_init((char*)0);
   } // End #GLOBAL_INIT section

   // Do a run-time CPU check for SSL-compatible processors
   _ssl_cpu_check();

   // Rehash the random seed at initialization time
   seed_hash_secret((char*)0);

   // Clear out the state
   memset(state, 0, sizeof(ssl_Socket));

   // All ssl sockets start as nothing
   state->ssl_mode = SSL_MODE_NONE;

   // Allocate data space
	for(i = 0; i < SSL_MAX_CONNECTIONS; i++) {
	   // Allocate read buffer for non-blocking reads
	   ssl_ResourcePool[i].read_state.read_buf = xalloc(SSL_READ_BUF_SIZE);

	   // Allocate write buffer for non-blocking writes
	   ssl_ResourcePool[i].write_state.write_buf = xalloc(SSL_WRITE_BUF_SIZE);

      // Allocate workspaces
	   ssl_ResourcePool[i].workspace.buf_ptr = xalloc(SSL_WORKSPACE_SIZE);
	}
}

////////////////////////////////////////////////////////////////////////////////
// SSL Handshake API (set up an SSL connection)
////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader ssl_listen */
int ssl_listen(ssl_Socket*, word, longword, word, dataHandler_t, word);
/*** EndHeader */

__SSL_DEBUG__
int ssl_listen(ssl_Socket* state, word lport, longword ina, word port,
               dataHandler_t datahandler, word reserved)
{
	return (ssl_extlisten(state, IF_DEFAULT, lport, ina, port, datahandler,
	                      reserved, 0, 0, NULL));
}

/*** BeginHeader ssl_extlisten */
int ssl_extlisten(ssl_Socket*, int, word, longword, word, dataHandler_t,
                  word, long, int, SSL_Cert_t*);
/*** EndHeader */

__SSL_DEBUG__
int ssl_extlisten(ssl_Socket* state, int iface, word lport, longword ina,
                  word port, dataHandler_t datahandler, word reserved,
                  long buffer, int buflen, SSL_Cert_t *cert)
{
   // Pointers to data structures for pointer optimization
	auto SSL_CipherState* cipher;
   auto SSL_Read_State_t* rd_state;
   auto SSL_Write_State_t* wr_state;
	auto SSL_CommConfig* comm;
   auto int i;
   #if __RABBITSYS
   	auto tcp_Socket *sock;
   #endif

   if(state == NULL)
   {
    	SSL_error(state, SSL_INIT_FAIL);
      goto _ssl_listen_error;
	}

 	// *** Set up per-connection data structures ***
   // Reset errno first
   SSL_RESET_ERRNO;

   // Clear out the structure
   #if __RABBITSYS
   	sock = state->sock;
   #endif
   memset(state, 0, sizeof(ssl_Socket));
   #if __RABBITSYS
   	state->sock = sock;
   #endif

	// Our current state is initializing the communications channel
	state->cur_state = SSL_STATE_INIT;

   // Make sure we are not a client
   if(SSL_MODE_CLIENT_BINARY == state->ssl_mode ||
      SSL_MODE_CLIENT_ASCII == state->ssl_mode ) {
  		SSL_error(state, SSL_ACCEPT_NO_CLIENT);
		return 0;
   }
   state->ssl_mode = SSL_MODE_SERVER_BINARY;

   // Default socket starts with TLS
   state->is_ssl_v3 = 0;

 	// Get an index from the alloc pool
   // LOCK(ssl_ResourcePool);
   for(i = 0; i < SSL_MAX_CONNECTIONS; i++) {
		if(ssl_ResourcePool[i].used == 0) {
       	break;
      }
   }

   // See if we are trying to make too many SSL connections
   if(i == SSL_MAX_CONNECTIONS) {
    	SSL_error(state, SSL_INIT_ALLOC_FAIL); // Could not allocate
      goto _ssl_listen_error;
   } else {
   	// This index now used
		ssl_ResourcePool[i].used = 1;
   }
   // UNLOCK(ssl_ResourcePool);

   // Allocate resources to state structure
	state->resource_index = i;
	state->cipher_state = &ssl_ResourcePool[i].cipher;
	state->comm_state = &ssl_ResourcePool[i].comm;
   state->cipher_state->suite = &ssl_ResourcePool[i].suite;
   state->cipher_state->key_exch = &ssl_ResourcePool[i].key_exch;
// DEVIDEA: Certificate authentication is not yet supported
//   state->cipher_state->auth = &ssl_ResourcePool[i].auth;
   state->cipher_state->bulk_cipher = &ssl_ResourcePool[i].bulk_cipher;
   state->cipher_state->digest = &ssl_ResourcePool[i].digest;
	state->workspace = &ssl_ResourcePool[i].workspace;

   // Secret and message digest information
   state->master_secret = &ssl_ResourcePool[i].master_secret;
	state->fin_hash_read = &ssl_ResourcePool[i].fin_hash_read;
	state->fin_hash_write = &ssl_ResourcePool[i].fin_hash_write;

   // Read and write states
   state->read_state = &ssl_ResourcePool[i].read_state;
   state->write_state = &ssl_ResourcePool[i].write_state;

   // Init memory management
	state->workspace->cur_index = 0;
   state->workspace->cur_ptr = state->workspace->buf_ptr;

//---------------------------------------------------------------
   // Setup pointers to data members to avoid indirection
   rd_state = state->read_state;
   wr_state = state->write_state;
	comm = state->comm_state;
//---------------------------------------------------------------

	// Set initial read state
   rd_state->state = SSL_RDSTATE_HEADER;


	// read_buf was assigned in ssl_init, and should not be modified after
   // that point
   // End of buffer pointer
   rd_state->end_read_buf = rd_state->read_buf + SSL_READ_BUF_SIZE;

   // Clear the ssl_gets flag for '\r' checking
   rd_state->saw_cr = 0;

   // Assign all pointers to the start of the read buffer
   rd_state->start_enc = rd_state->read_buf;
   rd_state->end_enc = rd_state->read_buf;
   rd_state->start_dec = rd_state->read_buf;

	// Set bytes to read to 0 for init
   rd_state->bytes_remaining = 0;

   // Clear the header buffer
   memset(&rd_state->header, 0, sizeof(ssl_Header));

	// Write state initialization
	wr_state->end_write_buf = wr_state->write_buf + SSL_WRITE_BUF_SIZE;
	wr_state->start_data = wr_state->write_buf;
	wr_state->start_enc = wr_state->write_buf;
   wr_state->footer_reserve = SSL_WR_FOOTER_RESERVE;
	wr_state->header_reserve = SSL_WR_HEADER_RESERVE;

   // Adjust end data for header reserve
 	wr_state->end_data = wr_state->write_buf;

   // Set up communications (socket initialization)
#if __RABBITSYS==0
 	state->sock = &ssl_ResourcePool[i].sock;
#endif
   comm->init = sock_init;
	comm->read = sock_fastread;
	comm->write = sock_write;
	comm->xread = sock_xfastread;
	comm->xwrite = sock_xfastwrite;
   comm->close = sock_close;
   comm->s_abort = sock_abort;
   comm->tick = tcp_tick;
   comm->bytesready = sock_dataready;
   comm->established = sock_established;

   // Start off the TCP connection
	tcp_extlisten(state->sock, iface, lport, ina, port, NULL, 0, buffer,
                 buflen);

#ifdef SSL_CERTIFICATE
	// Use default certificate (ximported)
	state->cert = &ssl_ResourcePool[i].cert;
	SSL_new_cert(state->cert, (long)_SSL_CERTIFICATE_, SSL_CERT_XIM);
#else
	// Assign pointer to our certificate (SSL_CERTIFICATE is undefined,
   // so we need a certificate API call to create a new certificate
   if(cert == NULL)
   {
    	SSL_error(state, SSL_INIT_FAIL);
      goto _ssl_listen_error;
	}
	else
   {
	   state->cert = cert;
   }
#endif

   // Finished message data
   memset(state->master_secret, 0, sizeof(SSL_Secret));
   md5_init(&state->fin_hash_read->md5_hash);
   sha_init(&state->fin_hash_read->sha_hash);

   // Set up write hash as well
   md5_init(&state->fin_hash_write->md5_hash);
   sha_init(&state->fin_hash_write->sha_hash);

   return 0;

_ssl_listen_error:
	// Free all space used
	state->cur_state = SSL_STATE_ERROR;
	return 1;

}

/*** BeginHeader ssl_mode */
int ssl_mode(ssl_Socket*, int);
/*** EndHeader */

__SSL_DEBUG__
int ssl_mode(ssl_Socket* state, int mode) {
// DEVIDEA: rework the ssl_Socket type so that we can just OR a new bitmask in
   SSL_mode_t cur_mode;
   cur_mode = state->ssl_mode;

	if(mode == SSL_MODE_ASCII &&
      (cur_mode == SSL_MODE_SERVER_ASCII ||
       cur_mode == SSL_MODE_SERVER_BINARY))
   {
		state->ssl_mode = SSL_MODE_SERVER_ASCII;
   }

	if(mode == SSL_MODE_BINARY &&
      (cur_mode == SSL_MODE_SERVER_ASCII ||
       cur_mode == SSL_MODE_SERVER_BINARY))
   {
		state->ssl_mode = SSL_MODE_SERVER_BINARY;
   }
}

/*** BeginHeader ssl_established */
int ssl_established(ssl_Socket*);
/*** EndHeader */

// Is the ssl socket established?
// Return 0: still working
// Return 1: connection is established
__SSL_DEBUG__
int ssl_established(ssl_Socket* state) {
   	return SSL_STATE_APP_DATA == state->cur_state;
}

/*** BeginHeader ssl_tbleft */
long ssl_tbleft(ssl_Socket*);
/*** EndHeader */

// How much space is left in the transmit buffer?
// Returns number of bytes remaining
__SSL_DEBUG__
long ssl_tbleft(ssl_Socket* state) {
   auto long free_space;
   auto SSL_Write_State_t* wr_state;

   if(!_ssl_is_valid_io_state(state)) {
		return 0;
	}

	wr_state = state->write_state;

   free_space = 0; // Assume no free space to begin with

   // If there is no data, adjust the end_data pointer by header reserve bytes
	if(wr_state->end_data == wr_state->start_data) {
		wr_state->end_data += wr_state->header_reserve;
   }

   // See if the free space wraps, includes the case when start_enc
   // is equal to end_data (the space wraps the entire buffer)
   if(wr_state->start_enc < wr_state->end_data) {
   	// The free space we have will include the space at the
      // head of the buffer
      // NOTE: The amount of space we can write to is dictated
      //       by the functionality of ssl_fastwrite. That function
      //       is simplified by only writing up to the end of the
      //       transmit buffer, and the *following* call starts again
      //       at the beginning of the buffer. For this reason, we
      //       only want to return the space at the end of the buffer,
      //       and not the space at the beginning.
 //     free_space = wr_state->start_enc - wr_state->write_buf;

     	// Free space is space to end of buffer, plus free space
      // at head of buffer (calculated above)
     	free_space = wr_state->end_write_buf - wr_state->end_data;
	}
   // No wrap
   else {
		// Free space is simply the difference between the start of encrypted
      // data and the end of decrypted data
      free_space = wr_state->start_enc - wr_state->end_data;
   }

   // Subtract the space for 1 header and 1 footer
   free_space -= wr_state->header_reserve;
	free_space -= wr_state->footer_reserve;
   free_space--; // Subtract 1 to make sure we have space for an entire record

   // If we are at the end of the buffer, then the reserve space may
   // be larger than the available space, we need to return 0 instead
   // of a negative number since there is no space available
   if(free_space < 0) {
   	free_space = 0;
   }

   return free_space;
}

/*** BeginHeader ssl_close */
void ssl_close(ssl_Socket*);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_close										<SSL.LIB>

SYNTAX: void ssl_close(ssl_Socket* state);

DESCRIPTION: Close an active SSL connection. Note that this function does
             not immediately close the connection, but tells the connection
             to send any pending data, and to wait for the close_notify
             message from the client.

PARAMETER 1: Pointer to SSL state structure

RETURN VALUE: None

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
void ssl_close(ssl_Socket* state) {
	// Lock the resource pool until we have saved the session (if applicable)
   // so that none of the data is modified before we can save it

   if(state->resource_index >= SSL_MAX_CONNECTIONS ||
      state->resource_index < 0)
   {
      // The state is uninitialized, so just bail
    	return;
   }

   if(SSL_STATE_APP_DATA == state->cur_state) {
   	// We are closing the connection, so send a close_notify
	   _ssl_send_fatal_alert(state, TLS_ALRT_close_notify);
   }

  	// wait for the close notify from the other side
//   if(SSL_STATE_APP_DATA == state->cur_state) {
   	// Closing from APP_DATA mode, save the session
//  	state->cur_state = SSL_STATE_WC_SAVE_SESSION;
//   }
//   else {
   	// Closing from some other mode, just close
	   state->cur_state = SSL_STATE_WAIT_CLOSE;
//   }
}

/*** BeginHeader ssl_abort */
void ssl_abort(ssl_Socket*);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_abort										<SSL.LIB>

SYNTAX: void ssl_abort(ssl_Socket* state);

DESCRIPTION: Close an active SSL connection immediately, without waiting
             for anything. Closes the socket, and cleans up the ssl_Socket
             data structure.

PARAMETER 1: Pointer to SSL state structure

RETURN VALUE: None

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
void ssl_abort(ssl_Socket* state) {
	// Lock the resource pool until we have saved the session (if applicable)
   // so that none of the data is modified before we can save it

   if(state->resource_index >= SSL_MAX_CONNECTIONS ||
      state->resource_index < 0)
   {
      // The state is uninitialized, so just bail
    	return;
   }

	// Close the communications channel, if needed
   if(state->comm_state->tick(state->sock)) {
	      state->comm_state->s_abort(state->sock);
   }

   // Make sure we dont save this connection for a later session resume,
   // since we are aborting.
	state->cur_state = SSL_STATE_ERROR;
   _ssl_cleanup(state);

#if _SSL_PRINTF_DEBUG
   printf("\n!!!ABORTING SSL CONNECTION!!!\n");
#endif

	// We are done, leave it that way
   state->cur_state = SSL_STATE_DONE;
}

/*** BeginHeader _ssl_cleanup */
void _ssl_cleanup(ssl_Socket*);
/*** EndHeader */

// Clean up an SSL connection.
__SSL_DEBUG__
void _ssl_cleanup(ssl_Socket* state) {
	auto int i;
	auto SSL_CipherState* cipher;
   // LOCK(ssl_ResourcePool);
	// Allow the resources to go back to the pool

   if(state->resource_index < 0 ||
      state->resource_index >= SSL_MAX_CONNECTIONS) {
#if _SSL_PRINTF_DEBUG
      printf("_ssl_cleanup: state->resource_index: %d\n",
             state->resource_index);
#endif
    	return;
   }

	i = state->resource_index;

	ssl_ResourcePool[i].used = 0;

   // Clear the resources, now that we saved the session,
   // for security reasons (clears secret key data)
	memset((char *)&ssl_ResourcePool[i].SSL_FIRST_FIELD_TO_ZERO, 0,
     		 (char *)&ssl_ResourcePool[i].SSL_FIRST_FIELD_NOT_TO_ZERO -
			 (char *)&ssl_ResourcePool[i].SSL_FIRST_FIELD_TO_ZERO);

	// Clear out xalloc'ed resources
   xmemset(ssl_ResourcePool[i].read_state.read_buf, 0, SSL_READ_BUF_SIZE);
   xmemset(ssl_ResourcePool[i].write_state.write_buf, 0, SSL_WRITE_BUF_SIZE);
   xmemset(ssl_ResourcePool[i].workspace.buf_ptr, 0, SSL_WORKSPACE_SIZE);

   // UNLOCK(TLS_Resource_Pool);

   // Pointer to avoid unecessary indirection
   cipher = state->cipher_state;

   // Clear the state structure
	state->resource_index = -1; // -1 indicates uninitialized
  	cipher->key_exch = NULL;
// DEVIDEA: Certificate authentication is not yet supported
//	state->cipher_state->auth = NULL;
   cipher->bulk_cipher = NULL;
   cipher->digest = NULL;
	state->cipher_state = NULL;
	state->comm_state = NULL;
	state->workspace = NULL;
}

/*** BeginHeader ssl_tick */
int ssl_tick(ssl_Socket*);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_tick                               <SSL.LIB>

SYNTAX: ssl_tick(ssl_Socket* state);

DESCRIPTION: Main tick function for SSL. This function is responsible for
             keeping the read buffers filled, keeping the communications
             channel going, and performing writes, similar to tcp_tick.

PARAMETER 1: ssl_Socket state structure pointer

RETURN VALUE: 0 if connection is closed (reset, closed by peer),
              non-zero if the connection is fine

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_tick(ssl_Socket* state) {
	auto int ret_val;
	auto SSL_CommConfig* comm;
   auto int save_session;

   // We need a flag to see if the session actually needs to be saved
   save_session = 0;

   // Pointer to avoid indirection
   comm = state->comm_state;

   if(!state || !comm) {
   	// No connection yet, just return
    	return 0;
   }

   if(SSL_STATE_DONE == state->cur_state) {
   	// There is no connection anymore, just return
    	return 0;
   }

	if(SSL_STATE_ERROR == state->cur_state)
   {
    	// Abort imediately if an error occurred
#if _SSL_PRINTF_DEBUG
      printf("Got error, aborting SSL connection. SSL_errno= %d\n", SSL_errno);
#endif
      ssl_close(state);
      comm->s_abort(state->sock);
      _ssl_cleanup(state);
      state->cur_state = SSL_STATE_ERROR;
      return 0;
   }

	// Call the communications tick function first, so if the connection
   // is established, we can start right away
	ret_val = comm->tick(state->sock);

   // See if the socket is still open, and make sure we are not already
   // saving the session
   if(!ret_val) // && SSL_STATE_WC_SAVE_SESSION!= state->cur_state)
   {
//	   if(SSL_STATE_APP_DATA == state->cur_state) {
	      // Closing from APP_DATA mode, save the session
//	      state->cur_state = SSL_STATE_WC_SAVE_SESSION;
//	   }
//	   else {
	      // Closing from some other mode, just close
	      state->cur_state = SSL_STATE_WAIT_CLOSE;
//	   }
   }

   // Read tick comes before the close, since we may need to process
   // an alert
   if(ret_val && SSL_STATE_INIT != state->cur_state) {
      _ssl_read_tick(state);
      _ssl_write_tick(state);
   }

   // If we are in the WAIT_CLOSE state, and there are no bytes
   // left to read or write, then we can close the socket
   if(SSL_STATE_WAIT_CLOSE == state->cur_state && //||
//       SSL_STATE_WC_SAVE_SESSION == state->cur_state) &&
	   _ssl_bytesready(state->read_state) <= 0  &&
     	_ssl_bytes_to_write(state) <= 0)
   {
	      // This is THE ONLY PLACE the socket is closed
	      comm->close(state->sock);
   }

   // Check for init, if connection is established, then switch to
   // handshake state
	if(SSL_STATE_INIT == state->cur_state) {
   	// Check the socket connection
      if(comm->established(state->sock) || (comm->bytesready(state->sock) >= 0))
      {
      	// We are now listening for an SSL connection
			state->cur_state = SSL_STATE_HS_LISTEN;
      }
      // Else do nothing and return the value from the comm channel tick
      return ret_val;
   }
   // Do SSL stuff, the socket connection is established
   else {
	   // If in APP_DATA mode, just ignore, the handshake is done
	   if(SSL_STATE_APP_DATA        != state->cur_state &&
	      SSL_STATE_DONE            != state->cur_state &&
         SSL_STATE_WAIT_CLOSE      != state->cur_state &&
//         SSL_STATE_WC_SAVE_SESSION != state->cur_state &&
   	   SSL_STATE_ERROR           != state->cur_state &&
         SSL_STATE_SERVER_REPLY    != state->cur_state )
      {
	      _ssl_handshake_tick(state);
	   }

	   if(!ret_val) {
	      // Cannot write or read anymore, but there may be bytes ready
	      // to pass on to user (or a pending alert, such as a close_notify)
	      ret_val = (_ssl_bytesready(state->read_state) > 0);
	   }
	}

   // If ret_val == 0 at this point, then we can clean up the
   // connection, since everything is done
   if(!ret_val) { // || SSL_STATE_DONE == state->cur_state) {
   // DEVIDEA: Apparently, some browsers will not send a
   // close_notify alert, so this check causes session
   // renegotiation to fail.
   // if(SSL_STATE_WAIT_CLOSE == state->cur_state)  {
   //    SSL_error(state, SSL_NO_CLOSE_NOTIFY);
   //       state->cur_state = SSL_STATE_ERROR;
   //   }

      if(SSL_STATE_WAIT_CLOSE == state->cur_state) // ||
//		   SSL_STATE_WC_SAVE_SESSION == state->cur_state)
      {
         // Takes care of above case, when waiting for a close_notify,
         // Without modifying state machine, so we could someday add the
         // above check back in...
//			if(SSL_STATE_WC_SAVE_SESSION == state->cur_state)
//         {
         	save_session = 1;
//         }
         state->cur_state = SSL_STATE_DONE;

      }
#if _SSL_PRINTF_DEBUG
      printf("Cleaning up SSL connection\n");
#endif

#if !SSL_NO_SESSION_RENEGOTIATION
      // Save the state for possible resumption, but only if we are in the
      // DONE state. We can save now since the connection is correctly
      // terminated
      if(SSL_STATE_DONE == state->cur_state && save_session) {
         _ssl_session_save(state);
      }
#endif

      _ssl_cleanup(state);
   }

   return ret_val;
}

/*** BeginHeader _ssl_is_valid_io_state */
int _ssl_is_valid_io_state(ssl_Socket*);
/*** EndHeader */

// Returns true if the state is appropriate for
// reading/writing using SSL API functions.
// Returns false for states when such calls are
// inappropriate
// This should be called at the beginning of every
// SSL public I/O function to check for valid states.
__SSL_DEBUG__
int _ssl_is_valid_io_state(ssl_Socket* state) {

	switch(state->cur_state) {
	   // Valid IO states
      case SSL_STATE_HS_LISTEN:
	   case SSL_STATE_HANDSHAKE:
	   case SSL_STATE_CH_CIPHER_SPEC:
	   case SSL_STATE_ENC_HANDSHAKE:
	   case SSL_STATE_SESSION_RESUME:
	   case SSL_STATE_SESS_RES_CH_SPEC:
	   case SSL_STATE_ENC_SESS_RES:
		case SSL_STATE_SERVER_REPLY:
	   case SSL_STATE_SSL2_HANDSHAKE:
	   case SSL_STATE_APP_DATA:
	   case SSL_STATE_ENC_ALERT:
	      return 1;

	   // Invalid states for reading/writing
	   case SSL_STATE_INIT:
	   case SSL_STATE_ERROR:
      case SSL_STATE_WAIT_CLOSE:
//      case SSL_STATE_WC_SAVE_SESSION:
		case SSL_STATE_DONE:
	   default:
	      return 0;
 	}
}



/*** BeginHeader _ssl_big_rand */
void _ssl_big_rand(SSL_byte_t*, unsigned int);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
_ssl_big_rand                          <SSL.LIB>

SYNTAX: void _ssl_big_rand(SSL_byte_t* value, unsigned int length);

DESCRIPTION: Cryptographic pseudo-random number generator that returns
             large (>32bit) numbers for use with TLS/SSL

				 NOTE: this needs to be able to interface with an external
                   RNG if one ever exists, for now, use RAND.LIB

PARAMETER 1: Return value, a pointer to an array of "digits" (chars)
PARAMETER 2: The number of digits (bytes) in value

RETURN VALUE: None

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
void _ssl_big_rand(SSL_byte_t* value, unsigned int length) {
	auto unsigned int i;

   for (i=0; i < length; ++i) {
        *value++ = (char)seed_getbits(8);
   }
}

/*** BeginHeader _ssl_get_suite_str */
char* _ssl_get_suite_str(SSL_uint16_t);
/*** EndHeader */

__SSL_DEBUG__
char* _ssl_get_suite_str(SSL_uint16_t suite) {

	if(TLS_NULL_WITH_NULL_NULL == suite) {
   	return "TLS_NULL_WITH_NULL_NULL";
   }
	if(TLS_RSA_WITH_RC4_128_MD5 == suite) {
   	return "TLS_RSA_WITH_RC4_128_MD5";
   }
	if(TLS_RSA_WITH_RC4_128_SHA == suite) {
   	return "TLS_RSA_WITH_RC4_128_SHA";
   }
	if(TLS_RSA_WITH_3DES_EBE_CBC_SHA == suite) {
   	return "TLS_RSA_WITH_3DES_EBE_CBC_SHA";
   }
	if(TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA == suite) {
   	return "TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA";
   }
	if(TLS_DH_anon_WITH_3DES_EDE_CBC_SHA == suite) {
   	return "TLS_DH_anon_WITH_3DES_EDE_CBC_SHA";
   }
	if(TLS_RSA_WITH_AES_128_CBC_SHA == suite) {
   	return "TLS_RSA_WITH_AES_128_CBC_SHA";
   }
	if(TLS_DH_anon_WITH_AES_128_CBC_SHA == suite) {
   	return "TLS_DH_anon_WITH_AES_128_CBC_SHA";
   }
	if(TLS_RSA_WITH_DES_CBC_SHA == suite) {
   	return "TLS_RSA_WITH_DES_CBC_SHA";
   }

	return "Unknown ciphersuite";

}

/*** BeginHeader */
#endif
/*** EndHeader */

