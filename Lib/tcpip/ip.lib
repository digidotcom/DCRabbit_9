/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*
 *    ip.lib
 *    Portions used with permission of Erick Engelke.
 *
 * Internet Protocol.  This library handles the network layer (just above the
 * link layer and device driver), plus some of the link layer stuff.
 * DCRTCP actually handles some of the IP layer at the transport layer level,
 * so the organisation could not strictly be called "layered".
 */
/*** BeginHeader */
#ifndef IP_H
#define IP_H

#ifdef IP_DEBUG
	#define _ip_nodebug debug
#else
	#define _ip_nodebug nodebug
#endif

#ifndef NET_H
	#use "net.lib"
#endif

// Flags for return if information from custom packet handlers
#define CUSTOM_PKT_FLAG_PROCESS	0x0001

/* The Internet Header: */
typedef struct {
   byte     ver_hdrlen;
   byte     tos;
   word     length;
   word     identification;
   word     frags;
   byte     ttl;
   byte     proto;
   word     checksum;
   longword source;
   longword destination;
} in_Header;

typedef struct in_addr {
   longword    s_addr;
} in_addr_t;

// Following flags in network order (in the frags field)
#define IP_DF			0x0040	// Don't fragment
#define IP_MF			0x0020	// Not the last fragment
#define IP_OFFSET_N	0xFF1F	// Mask for the offset bits


#define in_GetVersion(ip) ((ip)->ver_hdrlen>>4)
#define in_GetHdrlen(ip)  ((ip)->ver_hdrlen&0x0f)  /* 32 bit word size */

#define in_GetHdrlenBytes(ip)  (in_GetHdrlen(ip) << 2) /* 8 bit byte size */
#define in_GetTos(ip)      ((ip)->tos)

#define in_GetTTL(ip)      ((ip)->ttl)
#define in_GetProtocol(ip) ((ip)->proto)

/*
 * Type-of-Service (TOS) definitions (see RFC1349).  You should set _one_ of
 * these values in any one packet (not OR them together).  The precedence field (3 MSBs)
 * and MBZ field (LSB) must be zero.
 */
#define IPTOS_DEFAULT	0x00
#define IPTOS_CHEAP		0x02	// Minimize monetary cost
#define IPTOS_RELIABLE	0x04	// Maximize reliability
#define IPTOS_CAPACIOUS	0x08	// Maximize throughput
#define IPTOS_FAST		0x10	// Minimize delay
#define IPTOS_SECURE		0x1E	// Maximize security

#ifndef ICMP_TOS
	#define ICMP_TOS IPTOS_DEFAULT
#endif


extern int ip_id;        /* packet number */
#if _SYSTEM
void (*_rk_IPEntropyFunc)();
#endif

typedef struct {
	byte iface;				// Destination interface
	union {
		struct {
   		byte dest[6];			// Destination ethernet address
   		byte src[6];			// Source ethernet address
   		word type;				// Network protocol number
   		byte data[MAX_MTU];	// Data payload
   	} ether;
		struct {
   		byte dest[6];			// Destination access concentrator address
   		byte src[6];			// Source ethernet address
   		word type;				// Network protocol number (0x8864 for PPPoE)
   		byte ver;				// Version field (set to 0x11)
   		byte code;				// Code (0x00)
   		word session_id;		// Session ID
   		word len;				// Length of data payload
   		word protocol;			// PPP protocol field (0x00C1 for IP)
   		byte data[MAX_MTU];	// Data payload
   	} pppoe;
   	struct {
   		word addctl;			// Address/control field (0xFF03)
   		word protocol;			// PPP protocol field (0x00C1)
   		byte data[MAX_MTU];	// Data payload
   	} pppserial;
   	byte data[MAX_MTU];		// Payload for non-ethernet
   } u;
} eth_Packet;


// This is THE outgoing packet.  Use is deprecated: using gather for transmit
// to avoid the need for this buffer.  No memory will be allocated for it
// unless the deprecated _eth_* functions are used.
extern eth_Packet outbuf;

#define ETH_MIN	60              /* Minimum Ethernet packet size */

// Link layer protocol numbers
#define PD_ETHER        1
#define PD_SLIP         6

/*
 * This is the global root packet receive buffer pool.
 * This is a linked pool, and is used to manage the ll_prefix structs.  This struct points
 * to one or more buffers in the xmem pool (which is not linked)
 */
extern Pool_t root_pbuf_pool;
extern Pool_t xmem_pbuf_pool;


// FRAGSUPPORT enables support for packet reassembly of fragmented packets
//#define FRAGSUPPORT

#define MAXFRAGS        (ETH_MAXBUFS-1)
#define FRAGHOLDTIME    15       /* 15 secs to hold before discarding */
#define FRAGLONGTIME    30000
#define IP_HEADER_SIZE  20

// Lengths of IP options
#define IP_OPT_ROUTERALERT_LEN	4

#define IP_MAX_LL_HDR	 23			// Largest supported link-layer header size, plus 1.
												// Currently, this is PPPoE which requires 14 bytes for ethernet, plus
												//   8 bytes for the PPPoE header.  See also MAX_OVERHEAD in NET.LIB,
												//   which defines an additional 4 bytes for receiving the CRC.
#define IP_MAX_PKT_HDR  (IP_MAX_LL_HDR + IP_HEADER_SIZE + 24)
#define IP_MAX_TCP_HDR  (IP_MAX_LL_HDR + IP_HEADER_SIZE + 24)	// 24 is TCP header plus MSS oftion for SYN
																					//  -- this is the largest we send currently.
#define IP_MAX_UDP_HDR  (IP_MAX_LL_HDR + IP_HEADER_SIZE + 8)	// UDP always has 8-byte header
#define IP_MAX_IP_HDR   (IP_MAX_LL_HDR + IP_HEADER_SIZE)

#define structure(S,m,p) ((S *)( (byte *)(p) - (byte *) &((S *)0)->m ))

typedef struct {
   longword    source;
   byte        proto;
   word        identification;
} fragkey;

typedef struct hd {
   struct hd   * next;
   int           start;
   int           end;
} hole_descr;

typedef struct {
   byte         used;           // this position in table in use
   fragkey      key;
   hole_descr  *hole_first;
   longword     timer;
   in_Header   *ip;
   byte        *data_offset;
} fraghdr;


#ifdef FRAGSUPPORT
#error "Fragmentation support defeatured"
extern fraghdr fraglist[MAXFRAGS];
extern int active_frags/* = 0*/;
#endif

/*** EndHeader */
#if _SYSTEM
	void (*_rk_IPEntropyFunc)();
#endif

/*** BeginHeader is_valid_source */
int is_valid_source(longword ipaddr, int iface, int local_only);
/*** EndHeader */
_ip_nodebug int is_valid_source(longword ipaddr, int iface, int local_only)
{
	// To be a valid source IP address (for our purposes), the address must not be a
	// network, broadcast, or multicast address on the specified interface (or any
	// interface if IF_ANY).  In addition, the address is not allowed to be the 127.
	// (loopback) address.  If local_only, then the address must also be on a local
	// subnet i.e. not accessible only via a router.
	if (local_only && IS_SUBNET_BCAST_ADDR(ipaddr, iface))
		return 0;
	if (local_only && IS_SUBNET_NET_ADDR(ipaddr, iface))
		return 0;
	if (IS_LOOPBACK_ADDR(ipaddr))
		return 0;	// Local loopback
	if (IS_MULTICAST_ADDR(ipaddr))
		return 0;
	if (local_only && (iface == IF_ANY ? IS_ALL_NONLOCAL_SUBNET(ipaddr)
												  : IS_NONLOCAL_SUBNET(ipaddr, iface)))
		return 0;
	return 1;
}

/*** BeginHeader is_nonlocal_subnet */
int is_nonlocal_subnet(longword ipaddr, byte iface);
/*** EndHeader */
_ip_nodebug int is_nonlocal_subnet(longword ipaddr, byte iface)
{
 // Return true if ipaddr is not an IP address on the local subnet of
 // interface iface.
 // Special case: if ipaddr is currently zero (i.e. unknown during DHCP etc.)
 // then everything is considered to be 'local' since nothing can come to us
 // via a router.  This forestalls some chicken-and-egg problems in ARP etc.
	auto longword x, iip, im;
 	auto word isp2p;

 	iip = _if_tab[iface].ipaddr;
 	if (!iip)
 		return 0;

   //omid 9-16-03 -- we have to do this because of a compiler bug
   isp2p = IF_P2P(iface);
   //for a P2P interface, the peer's address is local.
   if (isp2p && ipaddr == _if_tab[iface].u.ppp.peeraddr)
 		return 0;
	im = _if_tab[iface].mask;
	x = (ipaddr ^ iip) & im;

	return x != 0L;
}



/*** BeginHeader is_subnet_bcast_addr */
int is_subnet_bcast_addr(longword ipaddr, byte iface);
/*** EndHeader */
_ip_nodebug int is_subnet_bcast_addr(longword ipaddr, byte iface)
{
	// If the trailing bits of the address are all 1's (i.e. the bits NOT in the subnet mask),
	// then consider this a broadcast address.  In particular, 0xFFFFFFFF is always considered
	// a subnet broadcast by this function.  If the interface is IF_ANY, then the address is
	// considered broadcast if any of the interface would consider it so.
	// Exception: if mask for a particular interface is all 1's (e.g. p2p interface), then
	// never consider to be a broadcast address for that interface.
	auto word i;

   if(ipaddr == 0xFFFFFFFF)
   	return 1;

	if (iface == IF_ANY) {
		for (i = 0; i < IF_MAX+VIRTUAL_ETH; i++)
			if (is_subnet_bcast_addr(ipaddr, i))
				return 1;
		return 0;
	}
	return ~_if_tab[iface].mask && !(~_if_tab[iface].mask & ~ipaddr) &&
        			!is_nonlocal_subnet(ipaddr, iface);
}

/*** BeginHeader is_subnet_net_addr */
int is_subnet_net_addr(longword ipaddr, byte iface);
/*** EndHeader */
_ip_nodebug int is_subnet_net_addr(longword ipaddr, byte iface)
{
	// If the trailing bits of the address are all 0's (i.e. the bits NOT in the subnet mask),
	// then consider this a network address.  If the interface is IF_ANY, then the address is
	// considered 'network' if any of the interface would consider it so.
	// Exception: if mask for a particular interface is all 1's (e.g. p2p interface), then
	// never consider to be a network address for that interface.
	auto word i;
	if (iface == IF_ANY) {
		for (i = 0; i < IF_MAX+VIRTUAL_ETH; i++)
			if (is_subnet_net_addr(ipaddr, i))
				return 1;
		return 0;
	}
	return ~_if_tab[iface].mask && !(~_if_tab[iface].mask & ipaddr) && !is_nonlocal_subnet(ipaddr, iface);
}

/*** BeginHeader is_any_my_addr */
int is_any_my_addr(longword ipaddr);
/*** EndHeader */
_ip_nodebug int is_any_my_addr(longword ipaddr)
{
	auto word i;
	for (i = 0; i < IF_MAX+VIRTUAL_ETH; i++)
		if (_if_tab[i].ipaddr == ipaddr)
			return 1;
	return 0;
}

/*** BeginHeader is_all_nonlocal_subnet */
int is_all_nonlocal_subnet(longword ipaddr);
/*** EndHeader */
_ip_nodebug int is_all_nonlocal_subnet(longword ipaddr)
{
	auto word i;
	for (i = 0; i < IF_MAX+VIRTUAL_ETH; i++)
		if (_rs_ifstatus(i) && IS_LOCAL_SUBNET(ipaddr, i))
			return 0;
	return 1;
}

/*** BeginHeader fragment */
ll_prefix * fragment(in_Header * ip, ll_prefix * p);
/*** EndHeader */

fraghdr fraglist[MAXFRAGS];
int active_frags/* = 0*/;

/* Fragment is called if the frag section of the IP header is not zero and DF bit not set.
   ll_prefix points to the buffer prefix for the given IP header.
 */
_ip_nodebug ll_prefix * fragment(in_Header * ip, ll_prefix * p)
{
   auto fraghdr    *my_frag;
   auto hole_descr *hole/* = NULL*/;
   auto hole_descr *prev_hole/* = NULL*/;

   static fragkey     key;
   static int         found/* = 0*/;
   static int         got_hole/* = 0*/;
   static unsigned int data_start;
   static unsigned int data_end;
   static unsigned int data_length;
   static int         temp,i;
   static int         more_frags;   // Set to true if this is the last frag

/* ### intialize local variables ### */
   found=got_hole=0;
   hole=prev_hole=NULL;
/* ### */

// Assemble key
   key.proto = ip->proto;     // use proto now
   key.source=ip->source;
   key.identification = ip->identification;

// Check if we have a match

   for(i=0;i<MAXFRAGS && !found;i++)
      if(fraglist[i].used && !memcmp(&key,&fraglist[i].key,sizeof(fragkey))) {
         found = TRUE;
         my_frag = &fraglist[i];
      }

   if(!found && active_frags == MAXFRAGS) {
#ifdef IP_DEBUG_FRAGS
      printf( "NO_BUFS\n" );
#endif
      // Can't handle any new frags, biff packet so that we can continue
      pkt_buf_release((char*)ip);
      return(NULL);  // We can't handle any new frags!
   }
   // Should biff packet?

// Calc where data should go

	// Offset is expressed in units of 8 bytes
   data_start  = intel16(ip->frags) << 3;
   data_length = intel16(ip->length)-in_GetHdrlenBytes(ip);
   data_end    = data_start + data_length - 1;
   more_frags = ip->frags & IP_MF;
#ifdef IP_DEBUG_FRAGS
   printf( "Data=%d..%d", data_start, data_end );
#endif

	// immediately discard any fragments that
	// are larger than the MTU because we cannot
	// assemble them in place

	if(data_start>MAX_MTU-in_GetHdrlenBytes(ip) ||
		data_end>=MAX_MTU-in_GetHdrlenBytes(ip)) {
		return NULL;
	}

   if(!found) {
      // Mark as used
      p->ll_flags |= LL_FRAGMENT;
      // Find first empty slot
      for(i=0;i < MAXFRAGS && fraglist[i].used;i++);
      my_frag = &fraglist[i];
      // mark as used
      my_frag->used = 1;
      // inc active frags counter
      active_frags++;
      // Setup frag header data, first packet
      memcpy(&my_frag->key,&key,sizeof(key));
      my_frag->timer  = set_timeout(max(FRAGHOLDTIME,ip->ttl));
      my_frag->ip = ip;
      // Set pointers to begining of IP packet data
      my_frag->data_offset = (byte *)my_frag->ip + in_GetHdrlenBytes(ip);
      // Setup initial hole table
      if(data_start) { // i.e. not Zero
         memcpy(my_frag->data_offset + data_start,(byte *)ip+in_GetHdrlenBytes(ip),data_length);
         // Bracket beginning of data
         hole = my_frag->hole_first = (hole_descr *)my_frag->data_offset;
         hole->start = 0;
         hole->end = data_start-1;
         if(more_frags) {
            // data_start was missing in next line
            hole->next = (hole_descr *)(my_frag->data_offset + data_start + data_length + 1);
            hole = hole->next;
         } else {
            hole = my_frag->hole_first->next = NULL;
            // Adjust length
            ip->length = intel16(data_end + in_GetHdrlenBytes(ip));
         }
      } else {
         // Setup
         hole = my_frag->hole_first = (hole_descr*)(my_frag->data_offset + data_length + 1);
      }
      // Bracket end
      if(hole) {
         // data_start was missing in next line
         hole->start = data_start + data_length;// + 1;
         hole->end = FRAGLONGTIME;
         hole->next = NULL;
      }
#ifdef IP_DEBUG_FRAGS
      printf( " new\n" );
#endif
      return NULL; // Go back for more!
   } // End !found
// Adjust length
   if(!more_frags)
      my_frag->ip->length = intel16(data_end + 1 + in_GetHdrlenBytes(ip));

// Hole handling
   hole = structure( hole_descr, next, &my_frag->hole_first );

   for(;;) {
      prev_hole = hole;
      hole = hole->next;
      if(!hole) break;
#ifdef IP_DEBUG_FRAGS
      printf( " hole=%d..%d(%d)", hole->start, hole->end, hole->next );/*DEBUG STUFF*/
#endif
      if(!(data_start > hole->end) && !(data_end < hole->start)) {
         // We've found the spot
         // Mark as got.
         got_hole =1;
         // Find where to insert
         // Check is there a hole before the new frag
         temp = hole->end;   // Pick up old hole end for later;

         if(data_start > hole->start) {
            hole->end = data_start-1;
            prev_hole = hole;  // We have a new prev
#ifdef IP_DEBUG_FRAGS
            printf( "->%d..%d(%d)", hole->start, hole->end, hole->next );/*DEBUG STUFF*/
#endif
         } else {
            // No, delete current hole
#ifdef IP_DEBUG_FRAGS
            printf( " del" );/* DEBUG STUFF*/
#endif
            prev_hole->next = hole->next;
            hole = prev_hole;     // Leave hole valid
         }

         // Is there a hole after the current fragment
         // Only if we're not last and more to come
         if(data_end < temp && more_frags) {   // fragfix
            hole = (hole_descr *)(data_end + my_frag->data_offset + 1);
            hole->start = data_end+1;
            hole->end = temp;
            hole->next = prev_hole->next;
            prev_hole->next = hole;
#ifdef IP_DEBUG_FRAGS
            printf( ",%d..%d(%d)", hole->start, hole->end, hole->next );
#endif
         }
      }
   }
   // Thats all setup so copy in the data
   if(got_hole)
      memcpy(my_frag->data_offset + data_start,(byte *)ip+in_GetHdrlenBytes(ip),data_length);
   // And release the buffer;
   pkt_buf_release((char *)ip);
   // Now do we have all the parts?
   if(!my_frag->hole_first) {
#ifdef IP_DEBUG_FRAGS
      printf( " COMPLETE\n" );
#endif
      my_frag->used = 0;
      active_frags--;
      // Redo checksum as we've changed the length in the header
      my_frag->ip->checksum = 0; // Zero
      my_frag->ip->checksum = ~fchecksum( my_frag->ip, sizeof( in_Header ));
      return pkt_buf_prefix(my_frag->ip);
   }
#ifdef IP_DEBUG_FRAGS
   printf( " MORE_TO_COME\n" );
#endif
   return NULL;
}

/*** BeginHeader timeout_frags */
void timeout_frags( void );
/*** EndHeader */

_ip_nodebug void timeout_frags( void )
{
   auto int i;

   for(i=0;i<MAXFRAGS;i++)
      if(fraglist[i].used)
         if(chk_timeout(fraglist[i].timer)) {
#ifdef IP_DEBUG_FRAGS
            printf( "BUF timed out\n" );
#endif
            fraglist[i].used = 0;
            active_frags--;
            pkt_buf_release((char *)fraglist[i].ip);
         }
}



/*** BeginHeader inet_ntoa */

/* START FUNCTION DESCRIPTION ********************************************
inet_ntoa                              <IP.LIB>

SYNTAX: char* inet_ntoa(char* s, longword ip);

KEYWORDS:		tcpip, ip address

DESCRIPTION: 	Convert a binary ip address to its dotted decimal format.
               This is 4 decimal numbers, each with value ranging from
               0 to 255 inclusive, separated by '.'.

PARAMETER1: 	location to place the dotted decimal string.  This must
               be an array of at least 16 bytes.
PARAMETER2: 	ip address to convert.

RETURN VALUE:  returns 's' parameter.

SEE ALSO:      inet_addr, inet_ethtoa, aton2

END DESCRIPTION **********************************************************/

char *inet_ntoa( char *s, longword x );
/*** EndHeader */

_ip_nodebug char *inet_ntoa( char *s, longword x )
{
   itoa( (int) (x >> 24), s/*, 10*/ );
   strcat( s, ".");
   itoa( (int) (x >> 16) & 0xff, strchr( s, 0)/*, 10*/);
   strcat( s, ".");
   itoa( (int) (x >> 8) & 0xff, strchr( s, 0)/*, 10*/);
   strcat( s, ".");
   itoa( (int) (x) & 0xff, strchr( s, 0)/*, 10*/);
   return( s );
}

/*** BeginHeader inet_ethtoa */

/* START FUNCTION DESCRIPTION ********************************************
inet_ethtoa                              <IP.LIB>

SYNTAX: char * inet_ethtoa(char * s, byte * hwa);

KEYWORDS:		tcpip, ethernet address

DESCRIPTION: 	Convert a binary ethernet MAC address to printable format.
               The 6 bytes pointed to by hwa are converted to a sequence
               of 12 hexadecimal digits, with digit pairs separated
               by a colon.

PARAMETER1: 	location to place the formatted string.  This must point
               to an array of at least 18 characters.
PARAMETER2: 	pointer to 1st byte of ethernet address to convert.

RETURN VALUE:  returns 's' parameter.

SEE ALSO:      inet_ntoa

END DESCRIPTION **********************************************************/

char * inet_ethtoa(char * s, byte * hwa);
/*** EndHeader */

_ip_nodebug
char * inet_ethtoa(char * s, byte * hwa)
{
	auto int i;
	for (i = 0; i < 6; i++)
	{
      #if _SYSTEM
	  	_rk_sprintf(s+i*3, "%x%s", hwa[i], i < 5 ? ":" : "");
	  	#else
	  	sprintf(s+i*3, "%02.2X%s", hwa[i], i < 5 ? ":" : "");
	  	#endif
	}
	return s;
}

/*
 * aton()
 *	- converts [a.b.c.d] or a.b.c.d to 32 bit long
 *	- returns 0 on error (safer than -1)
 */

/*** BeginHeader aton2, isaddr */
#define aton inet_addr		// Macro alias for historical reasons
longword aton2(char **textp, int * bad, word * port);
int isaddr(char *text);

/* START FUNCTION DESCRIPTION ********************************************
aton2                              <IP.LIB>

SYNTAX: longword aton2(char **textp, int * bad, word * port)

KEYWORDS:		tcpip, ip address

DESCRIPTION: 	Convert an ip address string in dotted decimal format to
               its binary representation.

               The address of a pointer to the string is required, and
               the pointer is advanced to the end of the parsed string.
               If the string cannot be parsed as a dotted decimal IP
               address, then *bad is set to a non-zero error indicator.

               The acceptable syntax for the string (if port is NULL) is

                 <optional leading space> d.d.d.d <opt trailing space>

               where each 'd' represents a decimal number with a value
               between 0 and 255 inclusive.  In addition, the following
               special syntax is accepted:

                 /n

               where n is a number between 0 and 32 inclusive.  This is
               translatedinto a 32-bit number with 'n' leading 1's.  E.g.
               /24 becomes 0xFFFFFF00.  This is useful for specifying
               netmasks.

               Leading and trailing space is accepted, however there must
               not be any spaces within the address e.g.
               '  10.10.6.40  ' is OK, but not '10 . 10. 6 . 40'

               The delimiter between decimals may be either '.' or ','.
               For historical reasons, the dotted decimal may be
               surrounded by single '[' and ']' characters.

PARAMETER1: 	Pointer to a pointer to the string.  This is an input and
               output parameter.  On return, *textp is advanced to the
               end of the parsed string, plus any trailing whitespace.
               If there was an error, *textp points to the character which
               could not be parsed.
PARAMETER2:    This is an output parameter.  *bad is set to 0 if there
               was no error.  Otherwise, it is set to one of the following
               error codes:
                 NETERR_NOTDIGIT: decimal digit expected but not found
                 NETERR_TOOBIG: one of the decimals was out of range (>255)
                 NETERR_BADDELIM: invalid delimiter character
                 NETERR_BADPORT: port number was outside range (0..65535)
                 NETERR_UNBALANCED: '[' was not balanced by ']'.
PARAMETER3:    If not NULL, this parameter points to a word
               which will be set to a TCP or UDP port number if the IP
               address string is suffixed with a colon (:) followed by
               a decimal number between 0 and 65535 inclusive.  If
               port is not NULL, but the string did not contain a port
               number, then *port is set to zero.

RETURN VALUE:  Binary representation of dotted_ip_string.  Returns zero
               if it has problems parsing the string.

SEE ALSO:      inet_ntoa, inet_addr, isaddr

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
isaddr                              <IP.LIB>

SYNTAX: int isaddr(char *text)

KEYWORDS:		tcpip, ip address

DESCRIPTION: 	Test whether the given string is a valid dotted decimal
               IP address, as would be accepted by aton2().

               In addition to the aton2() test, the string is checked
               for any trailing characters.  If there are trailing chars
               which are not whitespace, then this function returns '0'
               i.e. NOT a valid address.  Use aton2() directly if the
               IP address string may contain more information after the
               IP address.

PARAMETER1: 	Pointer to the string.

RETURN VALUE:  Non-zero: the string is a valid IP address.
               Zero: the string is not an IP address.

SEE ALSO:      inet_ntoa, inet_addr, aton2

END DESCRIPTION **********************************************************/


/*** Endheader */

_ip_nodebug longword aton2(char **textp, int * bad, word * port)
{
   auto int i, wasbrkt;
   auto long cur;
   auto longword ip;

   ip = 0;
	*bad = 0;
   while (isspace(**textp)) ++*textp;
   wasbrkt = **textp == '[';
   if (wasbrkt)
      ++*textp;
   if (**textp == '/') {
   	++*textp;
      cur = strtol(*textp, textp, 10);
		ip = 0xFFFFFFFFuL << (32 - cur);
   }
   else for( i = 24; i >= 0; i -= 8 ) {
   	if (!isdigit(**textp)) {
      	*bad = NETERR_NOTDIGIT;
      	return 0;
      }
   	cur = strtol(*textp, textp, 10);
      if (cur < 0 || cur >= 256) {
      	*bad = NETERR_TOOBIG;
      	return 0;
      }
      ip |= cur << i;
      if (!i) break;

      if (**textp != '.' && **textp != ',') {
      	*bad = NETERR_BADDELIM;
         return 0;
      }
      ++*textp;
   }
   if (port) {
   	*port = 0;
      if (**textp == ':') {
      	++*textp;
         cur = strtol(*textp, textp, 10);
         if (cur < 0 || cur >= 65536) {
         	*bad = NETERR_BADPORT;
            return 0;
         }
         *port = (word)cur;
      }
   }
   if (wasbrkt)
   	if (**textp != ']') {
      	*bad = NETERR_UNBALANCED;
   		return 0;
      }
      else
      	++*textp;
   while (isspace(**textp)) ++*textp;
   return ip;
}

_ip_nodebug int isaddr(char *text)
{
	auto int bad;
   aton2(&text, &bad, NULL);
   return !bad && !*text;
}

/*** BeginHeader inet_addr */

/* START FUNCTION DESCRIPTION ********************************************
inet_addr                              <IP.LIB>

SYNTAX: longword inet_addr(char* dotted_ip_string);

KEYWORDS:		tcpip, ip address

DESCRIPTION: 	Convert an ip address string in dotted decimal format to
               its binary representation.

               Note that aton2() is recommended for new applications,
               since it allows the program to distinguish between an
               address of 0.0.0.0 and an invalid address, as well as
               allowing enhanced syntax.

               Note: aton is a macro which is aliased to inet_addr
               for historical reasons.

PARAMETER1: 	dotted decimal ip string e.g. "10.10.6.100".  See
               documentation for aton2() for acceptable syntax details.

RETURN VALUE:  binary representation of dotted_ip_string. returns zero
               if it has problems parsing the string.

SEE ALSO:      inet_ntoa, aton2, isaddr

END DESCRIPTION **********************************************************/

longword inet_addr(char *s);
/*** EndHeader */

_ip_nodebug longword inet_addr(char *s)
{
	// This doesn't distinguish between a valid address and '0.0.0.0'.
   auto int bad;
   return aton2(&s, &bad, NULL);
}

/*** BeginHeader _rs_gethostid, _rs_sethostid */
/* START FUNCTION DESCRIPTION ********************************************
gethostid                              <IP.LIB>

SYNTAX: longword gethostid();

KEYWORDS:		tcpip, host, ip address

DESCRIPTION: 	Get our ip address

RETURN VALUE:  Current ip address, or zero if not assigned.

SEE ALSO:      sethostid

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
sethostid                              <IP.LIB>

SYNTAX: longword sethostid(longword ip);

KEYWORDS:		tcpip, host, ip address

DESCRIPTION: 	This function changes the system’s current IP address.
					Changing this address will disrupt existing TCP or UDP
					sessions.  You should close all sockets before calling
					this function.

					Normally there is no need to call this function.  The macro
					MY_IP_ADDRESS defines an initial IP address for this
					host, or you can define USE_DHCP to obtain a dynamically
					assigned address.  In either case, it is not recommended
					to use this function to change the address.

PARAMETER1: 	new ip address

RETURN VALUE:  returns new ip address

SEE ALSO:      gethostid

END DESCRIPTION **********************************************************/

_system longword _rs_gethostid(void);
_system longword _rs_sethostid( longword ip );
/*** EndHeader */


_ip_nodebug _system longword _rs_gethostid(void)
{
	_SYS_CALL_VARS
   return( my_ip_addr );
}

_ip_nodebug _system longword _rs_sethostid( longword ip )
{
	_SYS_CALL_VARS
   return( my_ip_addr = ip );
}

/*** BeginHeader _rs_ip_iface */
/* START FUNCTION DESCRIPTION ********************************************
ip_iface                              <IP.LIB>

SYNTAX: word ip_iface(longword ipaddr, int local_only);

KEYWORDS:		tcpip, host, ip address

DESCRIPTION: 	Given an IP address, return the interface number for that
               address.  If ipaddr is an address on one of the local
               subnets, then the interface to that subnet is returned.
               Only interfaces which are currently up are considered,
               unless local_only == 2.

               If the address is not local, then the local_only parameter
               determines the result:

               If local_only is 1, then IF_ANY will be returned
               for a non-local address.  Only interface which are currently
               up are considered.

               If local_only is 2, then this is the same as above except
               that all interfaces (up and down) are considered.

               Otherwise, the router_for_iface() function is invoked to find
               the correct router -- the interface for the router is
               returned.

PARAMETER1:    IP address of an external host.
PARAMETER2:    0: allow non-local addresses (returns interface for router)
               1: return IF_ANY for non-local addresses.
               2: return IF_ANY for non-local addresses, but consider all
                  interface whether currently up or down.

RETURN VALUE:  Interface number (0..IF_MAX-1), of possibly IF_ANY (0xFF).

SEE ALSO:      router_for_iface

END DESCRIPTION **********************************************************/


_system word _rs_ip_iface(longword ipaddr, int local_only);
/*** EndHeader */


_ip_nodebug _system word _rs_ip_iface(longword ipaddr, int local_only)
{
	_SYS_CALL_VARS
	auto word i;

#if __RABBITSYS != 0
	//this check allows the serial "socket" to remain open
	//when other interfaces (i.e., IF_ETH0) are being closed.
	if ((ipaddr & 0xFF000000) == 0x7F000000)
   	return IF_ANY;
#endif
	for (i = 0; i < IF_MAX+VIRTUAL_ETH; i++)
		if (local_only == 2 || _rs_ifstatus(i)) {
      	if (IF_P2P(i)) {
         	if (ipaddr == _if_tab[i].u.ppp.peeraddr)
         		return i;
         }
      	else if (!((_if_tab[i].ipaddr ^ ipaddr) & _if_tab[i].mask))
				return i;
      }

	if (!local_only && _rs_router_for_iface(ipaddr, NULL, &i, IF_ANY) > 0)
		return i;
   return IF_ANY;
}

/*** BeginHeader ip_print_ifs */
void ip_print_ifs(void);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
ip_print_ifs									<IP.LIB>

SYNTAX: void ip_print_ifs(void)

KEYWORDS:      tcpip, interface

DESCRIPTION:   Print all interface table entries.  This is for debugging
               only, since the results are printed to the Dynamic C stdio
               window.

               There are 8 fields for each interface entry:
                 #:
                   the interface number
                 IP addr:
                   The local ("home") IP address of this interface.  May
                   be 0.0.0.0 if interface is not currently active.
                 Mask:
                   Local subnet mask.
                 Up:
                   Indicates status; one of
                     Yes: interface currently active
                     No:  currently inactive
                     NYU: Not Yet Up i.e. coming up
                     NYD: Not Yet Down i.e. coming down
                 Type:
                   Interface type; one of
                     eth: normal ethernet
                     ppp: PPP over serial port
                     pppoe: PPP over ethernet
                 MTU:
                   Maximum transmission unit.
                 Flags:
                   A list of the following characters:
                     * = this is the default interface (IF_DEFAULT)
                     D = Use DHCP
                     DD= Currently configured via DHCP
                     S = allow IP address configuration via directed
                         ping (ICMP echo).
                     SS= IP address currently set via directed ping
                     1 = IGMP version 1 router present on this interface
                     ->nn = Virtual interface on specified real i/f
                 Peer/router:
                   IP address of peer node (for PPP or PPPOE), or address
                   of default router on this interface (for ethernet
                   type).  May be blank or 0.0.0.0 if no peer or router
                   is available.

END DESCRIPTION **********************************************************/

_ip_nodebug void ip_print_ifs(void)
{
	auto char buffer[16], peer[16];
	auto byte i, ru;
	auto word f;
	auto ATHandle ath;
	auto longword router;

	printf("\nInterface table:\n\n");
	printf("#  IP addr.        Mask            Up  Type  MTU  Flags  Peer/router\n");
	printf("-- --------------- --------------- --- ----- ---- ------ ---------------\n");
	for (i = 0; i < IF_MAX+VIRTUAL_ETH; i++) {
		if (i < IF_MAX && !(1u<<i & IF_SET) ||
          i >= IF_MAX && !(_if_tab[i].u.eth.eflags & EFLAG_VIRT))
			continue;
		if (IF_P2P(i))
			inet_ntoa(peer, _if_tab[i].u.ppp.peeraddr);
		else if ((ath = router_for_iface(0, NULL, NULL, i)) > 0) {
			arpcache_ipaddr(ath, &router);
			inet_ntoa(peer, router);
		}
		else
			strcpy(peer, "");

		printf("%2d %-15.15s ",
				i,
				inet_ntoa(buffer, _if_tab[i].ipaddr));
		printf("%-15.15s %-3.3s ",
				inet_ntoa(buffer, _if_tab[i].mask),
				"no NYUyesNYD"+ifpending(i)*3);
		printf("%-5s %4u ",
				IF_P2P(i) ? (IF_PKT_ETH(i) ? "pppoe" : "ppp") : "eth",
				_if_tab[i].mtu);
		f = _if_tab[i].flags;
      if (i >= IF_MAX)
        printf("->%-2d   ", _if_tab[i].u.eth.riface);
      else
		  printf("%c%c%c%c%c%c "
				, i == IF_DEFAULT ? '*' : ' '
				, f & IFF_DHCP ? 'D' : ' '
				, f & IFF_DHCP_OK ? 'D' : ' '
				, f & IFF_ICMP_CONFIG ? 'S' : ' '
				, f & IFF_ICMP_CFG_OK ? 'S' : ' '
				, f & IFF_IGMP_V1_ROUTER ? '1' : ' '
				);
		printf("%-15.15s\n", peer);
	}
}


/*** BeginHeader pkt_init */
int pkt_init( void );
/*** EndHeader */

Pool_t root_pbuf_pool;
Pool_t xmem_pbuf_pool;
typedef struct {
	void * link_fields[2];	// Overhead for pool allocation linkage
	ll_prefix p;				// The data itself
} pbuf_datastruct;

pbuf_datastruct root_pbuf_data[ETH_MAXBUFS];

long xmem_pbuf_data;


_ip_nodebug int pkt_init( void )
{
	auto word i, nn;
   auto IFTEntry * ifte;

   #GLOBAL_INIT {
   	_done_pkt_init = 0;
   	xmem_pbuf_data = 0L;
	   #if _SYSTEM
	      _rk_IPEntropyFunc = NULL;
	   #endif
   }

   if (_done_pkt_init)
   	return 0;
   _done_pkt_init = 1;

   // Initialize the packet buffer pools
   pool_init(&root_pbuf_pool, root_pbuf_data, ETH_MAXBUFS, sizeof(root_pbuf_data[0]));
   pool_link(&root_pbuf_pool, 1);
   if (!xmem_pbuf_data)
   	xmem_pbuf_data = xalloc(ETH_MAXBUFS * (MAX_MTU+MAX_OVERHEAD));	// 512 byte xmem buffers
   pool_xinit(&xmem_pbuf_pool, xmem_pbuf_data, ETH_MAXBUFS, MAX_MTU+MAX_OVERHEAD);
	#ifdef IP_VERBOSE
	printf("IP: pkt_init reserved %u buffers at %04X/%08lX\n",
   	ETH_MAXBUFS, root_pbuf_data, xmem_pbuf_data);
	#endif

	#ifdef FRAGSUPPORT
		active_frags=0;
		memset(fraglist,0,sizeof(fraglist));
	#endif

	// Initialise the ethernet address mapping table
	for (i = 0; i < IF_MAX; i++) {
		if (!(1u<<i & IF_SET))
			continue;
   	ifte = _if_tab + i;
   	ifte->ncd->ioctl(ifte->state, PD_INITIALIZE, ifte->instance, i);	// Reset interface and tell it the i/f number
      my_eth_addr[i] = NULL;	// In case no hwa applicable...
   	ifte->ncd->ioctl(ifte->state, PD_GETHWA, my_eth_addr + i);	// Get HWA (if applicable)
	#ifdef IP_VERBOSE
   	if (my_eth_addr[i]) {
	      printf("IP: i/f %d using hwa ", i);
	      for (nn = 0; nn < 6; nn++)
	         printf(":%02X", my_eth_addr[i]->eaddr[nn]);
	      printf("\n");
      }
	#endif

	}//for

   return 0;
}



/*** BeginHeader pkt_gather */
int pkt_gather(ll_Gather * g);
/*** EndHeader */

_ip_nodebug int pkt_gather(ll_Gather * g)
{
	auto int send_status;
   auto IFTEntry * ifte;

   ifte = _if_tab + g->iface;
#ifdef IP_VERBOSE
	if (debug_on >= 5)
		printf("IP: pkt_gather on i/f %u\n", g->iface);
#endif

	send_status = ifte->ncd->sendpacket(ifte->state, g);

	if (!send_status)
			return 0;

#ifdef IP_VERBOSE
	// Note that it is quite normal for send to fail for PPP over serial,
	// since the previous buffer may still be transmitting.  TCP generally handles this
	// by retrying in a short time.  UDP applications should avoid sending too many
	// datagrams in too short an interval.
	if (debug_on >= 2)
		printf("IP: pkt_gather failed on i/f %u\n", g->iface);
#endif

   return 1;
}


/*** BeginHeader pkt_buf_prefix */
ll_prefix * pkt_buf_prefix(void * ptr);
/*** EndHeader */
#error "Don't use this function"
/*
 * Convert a pointer which points anywhere in a buffer to the first byte
 * of the buffer (prefix bytes).  Do this in assembler to avoid division/
 * multiplication operations.  Faster for reasonably small number of buffers.
 * ptr MUST point into one of the buffer entries (this is not checked).
 */
nodebug ll_prefix * pkt_buf_prefix(void * ptr)
{
}

/*** BeginHeader pkt_buf_release */
void pkt_buf_release(ll_prefix * LL);
/*** EndHeader */

/* return a buffer to the pool. */
_ip_nodebug void pkt_buf_release(ll_prefix * LL)
{
#ifdef IP_VERBOSE
	if (debug_on > 5)
   	printf("IP: freeing buf %04X\n", LL);
#endif
	#asm
   push	ix
   ld		iy,(sp+@sp+LL+2)
   lcall	_pb_free
   pop	ix
   #endasm
}

/*** BeginHeader mem_dump, xmem_dump */
void mem_dump(void* pblock, int len);
void xmem_dump(long pblock, int len);
/*** EndHeader */

nodebug void mem_dump(void* pblock, int len) {
	auto char buf[67];
   auto int i, j, k, l, m;
   auto char * block;

   block = (char *)pblock;
   i = 0;
   for (j = 0; j < len; j += 16) {
	   memset(buf, ' ', sizeof(buf)-1);
	   buf[sizeof(buf)-1] = 0;
		k = len - j;
      if (k > 16)
      	k = 16;
	   for(i = j, l = 0, m = 0; l < k; ++i, ++l, m += 3) {
	      sprintf(buf+m,"%02X", block[i]);
         buf[m+2] = ' ';
         if (block[i] >= ' ' && block[i] < 0x7F)
         	buf[50+l] = block[i];
	      if((i & 15) == 15) {
	         printf("%s\n", buf);
	      }
	   }
   }
   if (i & 15)
   	printf("%s\n", buf);
}

nodebug void xmem_dump(long pblock, int len) {
	auto char buf[256];
	auto word i;

   while (len) {
   	if (len < sizeof(buf))
      	i = len;
      else
      	i = sizeof(buf);
      xmem2root(buf, pblock, i);
      mem_dump(buf, i);
      len -= i;
      pblock += i;
   }
}
/*** BeginHeader _pkt_dump */
void _pkt_dump(ll_prefix * p);
/*** EndHeader */

nodebug void _pkt_dump(ll_prefix * p) {
   printf("--- pkt flags=x%02X i/f=%d tstamp=%u len=%u ---\n",
   	p->ll_flags, p->iface, p->seq, p->len);
   if (p->len1) {
   	printf("  sect 1, len=%u addr=x%08lX rlen=%u\n", p->len1, p->data1, p->rlen1);
      xmem_dump(p->data1, p->len1 < 1537 ? p->len1 : 1536);
   }
   else if (p->len) {
   	printf("  sect 0, len=%u addr=x%08lX rlen=%u\n", p->len, p->data1, p->rlen1);
      xmem_dump(p->data1, p->len < 1537 ? p->len : 1536);
   }
   if (p->len2) {
   	printf("  sect 2, len=%u addr=x%08lX rlen=%u\n", p->len2, p->data2, p->rlen2);
      xmem_dump(p->data2, p->len2 < 1537 ? p->len2 : 1536);
   }
   if (p->len3) {
   	printf("  sect 3, len=%u addr=x%08lX rlen=%u\n", p->len3, p->data3, p->rlen3);
      xmem_dump(p->data3, p->len3 < 1537 ? p->len3 : 1536);
   }
}

/*** BeginHeader pkt_received */
ll_prefix * pkt_received(void);
/*** EndHeader */

#define IP_MAX_SNAP	2		// Max number of packets to snapshot

_ip_nodebug int _pkt_snapshot(ll_prefix ** pset)
{
	// Disable interrupts and take snapshot of packet queue.  The addresses of ready packets
   // are stored in the parameter array, and the number stored therein is returned (max IP_MAX_SNAP).
   // Only packets which are not ready, fragments, or output buffers are ignored.

   #asm
   ld		iy,(sp+@sp+pset)
   push	ix
   ld		ix,root_pbuf_pool
   ld		b,IP_MAX_SNAP
   ld		de,0
   ipset	PKT_POOL_IPSET
.next:
   lcall	pnext_fast
   jr		c,.end
   ld		d,h
	ld		e,L
   ld		(iy),hl
   ld		a,(hl)		; Get flags
   or		a
   jr		z,.next
   and	LL_OUTBUF|LL_FRAGMENT
   jr		nz,.next
   inc	iy
   inc	iy
   djnz	.next
.end:
	ipres
	pop	ix
   ld		hl,(sp+@sp+pset)
   ex		de,hl
   ld		hl,iy
   or		a
   sbc	hl,de		; Will not be any carry
   rr		hl			; Compute number of elements stored (return value)
   #endasm
}

/*
   This is the base-level routine for checking for incoming packets, and processing them.
   The return value is the ll_prefix if a packet was processed, NULL if there were no new packets ready.
   The caller is responsible for returning the ll_prefix to the pool (via _pb_free()).
   On any call, only the oldest ready packet is processed, thus packets are processed in order of
   arrival completion.

   This is called from tcp_tick_internal().

   pkt_received() scans for the oldest completed packet - this is easy, since they are in this
   order in the root ll_prefix pool.  Only incomplete or outgoing packets need to be skipped.

   If found, the link-layer header is extracted to an auto buffer (which is big enough to contain
   _all_ the headers, but only the ll header is extracted in this routine).  The header is examined
   to determine the next layer protocol, and an upcall to that (net) protocol handler is made.  If the
   handler completes processing the packet, then it returns the same ll_prefix as it was passed.
   Otherwise, if the handler needs to hang on to the packet for longer, then it returns NULL (but it
   must remember to free the packet later otherwise it will starve the buffer).
 */
_ip_nodebug ll_prefix * pkt_received(void)
{
	// This buffer is used to contain a root copy of the headers, as they are parsed by higher layers.
   // It is sized to contain the maximum possible header length (120 is for 60 byte IP plus 60 byte TCP).
	auto byte	hdrbuf[IP_MAX_LL_HDR + 120];
   auto ll_prefix	  * pset[IP_MAX_SNAP];	// snapshot of ready packets
   auto int npset;								// Number of ready packets in the above table
   auto ll_prefix   * p;			// The packet we are looking at
   auto ll_prefix   * next;		// The packet after p
   auto eth_Header * temp_e;		// Header, mapped as ethernet

   auto int	receive_result;
   auto word iface;
   auto word is_ip;
   auto word i;
   auto word llh_size;
   auto byte * t_buf;
   auto word pflags;					// Flags for returning info from custom handlers

   auto IFTEntry * ifte;

   /*
    * Run all interface receive drivers to move any data to the receive buffer.
    * PPP over serial does not need this processing, since it is interrupt driven
    * by the serial port hardware.
    */

	do {
   	receive_result = 1;
	   for (i = 0; i < IF_MAX; ++i) {
	      ifte = _if_tab + i;
      	if (!(IF_SET & 1<<i) || !ifte->ncd)
         	continue;
	      if (ifte->ncd->flags & NCD_POLL) {
	         receive_result = ifte->ncd->receive(ifte->state);
         #ifdef IP_VERBOSE
				if (!receive_result && debug_on >= 5) printf("IP: incoming on i/f %d, t=%lu\n", i, MS_TIMER);
         #endif
         }
	   }
	} while (!receive_result);

#ifdef FRAGSUPPORT
   // Do fragment timeouts
   if (active_frags)
   	timeout_frags();
#endif // FRAGSUPPORT

	npset = _pkt_snapshot(pset);

   p = NULL;
   for (i = 0; i < npset; ++i) {
   	p = pset[i];
      // Verification of IP header performed here instead of in IP layer itself.

      iface = p->iface;

      // New packet.  Determine the offset in the packet of the IP (or ARP) header.  If the
      // interface is ethernet, we also check for PPPoE frames.  If so, then we call PPPoE
      // processing to unencapsulate the packet into an IP datagram.  The interface number
      // is incremented by 2 to signal that it has come from the PPPoE interface rather than
      // the normal ethernet.
#ifdef IP_VERBOSE
      if (debug_on > 4) printf("IP: New pkt i/f %d  ll_flags=%02X  stamp=%u  len=%u  net_offs=%u\n",
      								iface, p->ll_flags, p->seq, p->len, p->net_offs);
      if (debug_on > 5) _pkt_dump(p);
#endif

		// Process in-band data by passing directly to the ioctl handler.  This is data
      // which is received outside of the normal TCP/IP/link encapsulation e.g. ASCII data when a PPPLINK
      // interface is talking to the local modem.
      if (p->ll_flags & LL_INBAND) {
      	_if_tab[iface].ncd->ioctl(_if_tab[iface].state, PD_INBAND, p);
         goto _drop_it;
      }

		// Extract the link-layer header to root buffer
      _pkt_buf2root(p, hdrbuf, llh_size = p->net_offs, 0);

      // Tentatively assume it is an ethernet header
      temp_e = (eth_Header *)hdrbuf;

#ifndef MULTI_IF
		// Single interface: simplified processing.
	#if USING_ETHERNET
   	// Don't need to do anything
   #elif USING_PPPOE
   	if (!IS_PPPOE_TYPE(temp_e->type))
      	goto _drop_it;			// Not a PPPoE encapsulation
      if (PPPOE_process(p, hdrbuf))
         // Drop it, badly formed or wrong interface, or was PPPoE LCP, IPCP, etc.
         goto _drop_it;

   #elif USING_PPP_SERIAL
      if (PPP_process(p, hdrbuf))
         // Drop it, badly formed or wrong interface, or was PPP LCP, IPCP, etc.
         goto _drop_it;
   #endif

#else
		// Multiple interfaces supported.
	#if USING_PPPOE
      if (!IF_P2P(iface) && IS_PPPOE_TYPE(temp_e->type)) {
         iface += (IF_PPPOE0 - IF_ETH0);  // Change to PPPoE interface
         p->iface = iface;
         if (PPPOE_process(p, hdrbuf))
            // Drop it, badly formed or wrong interface, or was PPPoE LCP, IPCP, etc.
            goto _drop_it;

         // Otherwise, p->net_offs has been correctly set for this IP packet.  Read in the
         // extra header
         //_pkt_buf2root(p, hdrbuf+llh_size, p->net_offs-llh_size, llh_size);
      }
      else
	#endif
      {
	#ifdef USING_PPP
         if (IF_P2P(iface) && PPP_process(p, hdrbuf))
            // Drop it, badly formed or wrong interface, or was PPP LCP, IPCP, etc.
            goto _drop_it;
	#endif
      }
#endif

      if (_rs_ifpending(iface) == IF_DOWN) {
         // Drop this; interface is supposed to be down.
#ifdef IP_VERBOSE
         if (debug_on > 4) printf("IP: dropped, i/f is not pending\n");
#endif
         goto _drop_it;
      }

      if (!IF_P2P(iface)) {
         // Check for broadcast destination
         t_buf = (byte *)temp_e; // point to dest addr
         if (!memcmp(t_buf, "\xFF\xFF\xFF\xFF\xFF\xFF", 6))
            p->ll_flags |= LL_BROADCAST;
         else if (!memcmp(t_buf, "\x01\x00\x5E", 3) && !(t_buf[3] & 0x80))
            p->ll_flags |= LL_MULTICAST;
         // For non-point-to-point (i.e. ethernet), TYPE field is IP or ARP
         pflags = 0;
         switch (temp_e->type) {
         case IP_TYPE:
#ifdef CUSTOM_IP_HANDLER
				// Use custom IP handler, if it exists.  The custom handler will
            // return NULL if it wants to keep the packet for further processing.
            // Otherwise, it must return p unchanged.  It may set *pflags to zero if
            // it wants us to handle the IP packet as usual.
				p = CUSTOM_IP_HANDLER(p,hdrbuf,&pflags);
            if (p && pflags & CUSTOM_PKT_FLAG_PROCESS)
	            p = ip_handler(p, hdrbuf);

#else
            p = ip_handler(p, hdrbuf);
#endif
            break;
         case ARP_TYPE:
#ifdef CUSTOM_ARP_HANDLER
				// Use custom ARP handler, if it exists.  The custom handler will
            // return NULL if it wants to keep the packet for further processing.
            // Otherwise, it must return p unchanged.  It may set *pflags to zero if
            // it wants us to handle the ARP packet as usual.
				p = CUSTOM_ARP_HANDLER(p,hdrbuf,&pflags);
            if (p && pflags & CUSTOM_PKT_FLAG_PROCESS)
	            p = _arp_handler(p, hdrbuf);

#else
            p = _arp_handler(p, hdrbuf);
#endif
            break;
         default:
#ifdef CUSTOM_ETHERNET_HANDLER
				// Use custom IP handler, if it exists.  The custom handler will
            // return NULL if it wants to keep the packet for further processing.
            // Otherwise, it must return p unchanged.  It may set *pflags to zero if
            // it wants us to handle the IP packet as usual.
				p = CUSTOM_ETHERNET_HANDLER(p,hdrbuf,&pflags);
#endif
#ifdef IP_VERBOSE
            if (
	#ifdef CUSTOM_ETHERNET_HANDLER
            	p && pflags & CUSTOM_PKT_FLAG_PROCESS &&
	#endif
               debug_on > 4) {
            	printf("IP: dropped, not IP or ARP\n");
               #ifdef DMAETH_SUPERDEBUG
               dmaeth_prt_nicreg(NULL);
               #endif
            }
#endif
            break;
         }
      }
      else {
         // Assume IP encapsulation for pt-pt drivers
#ifdef CUSTOM_IP_HANDLER
         // Use custom IP handler, if it exists.  The custom handler will
         // return NULL if it wants to keep the packet for further processing.
         // Otherwise, it must return p unchanged.  It may set *pflags to zero if
         // it wants us to handle the IP packet as usual.
         p = CUSTOM_IP_HANDLER(p,hdrbuf,&pflags);
         if (p && pflags & CUSTOM_PKT_FLAG_PROCESS)
            p = ip_handler(p, hdrbuf);

#else
         p = ip_handler(p, hdrbuf);
#endif
      }
_drop_it:
		if (p)
      	pkt_buf_release(p);
   }
#if _SYSTEM
	if ( _rk_IPEntropyFunc )
		if (npset)
			_rk_IPEntropyFunc(0);
#else
	#ifdef NET_ADD_ENTROPY
   	if (npset)	seed_clock(0);
   #endif
#endif

   return NULL;
}

/*** BeginHeader ip_handler */
ll_prefix * ip_handler(ll_prefix * LL, byte * hdrbuf);
/*** EndHeader */
_ip_nodebug ll_prefix * ip_handler(ll_prefix * LL, byte * hdrbuf)
{
	// hdrbuf has the link-layer header already copied (LL->net_offs bytes)
   // The next data is an IP header.  Get the first 20 bytes, then any extra
   // if there are IP options.
   auto byte padbuf[20];
   auto in_Header * ip;
   auto word iface;
   auto longword myip;
   auto word iplen, pktlen, ck[2], trail, trail_offs;

   if (LL->len < LL->net_offs + sizeof(in_Header))
   	return LL;	// Discard it, too short to contain IP header

   _pkt_buf2root(LL, ip = (in_Header *)(hdrbuf+LL->net_offs), sizeof(in_Header), LL->net_offs);
   iplen = in_GetHdrlenBytes(ip);
   LL->tport_offs = LL->net_offs + iplen;
   if (iplen > sizeof(in_Header))
	   _pkt_buf2root(LL, (byte *)(ip + 1),
      		iplen-sizeof(in_Header), LL->net_offs + sizeof(in_Header));

	// Not yet verified IP header.  Check it and either discard or set verified indicator.
	// Must have correct IP checksum, version=4 and reasonable length.
   if (fchecksum(ip, iplen) != 0xffff) {


      // Invalid packet - discard it before it does any damage!
#ifdef IP_VERBOSE
      if (debug_on > 4) printf("IP: dropped, invalid IP checksum\n");
#endif
      return LL;
   }

   if (in_GetVersion(ip) != 4
       || (pktlen = (word)intel16(ip->length)) > LL->len - (word)LL->net_offs) {
      // Invalid packet - discard it before it does any damage!
#ifdef IP_VERBOSE
      if (debug_on > 4) printf("IP: dropped, not V4 or bad length\n");
#endif
      return LL;
   }

   // If packet driver provided checksum, correct it to compensate for extraneous data
   // like LL header, or stuff past the IP payload.
   if (LL->chksum_flags) {
	   if (LL->net_offs > 8) {
      	if (LL->chksum_flags == CHKSUM_FRAME) {
	         // Subtract out irrelevant LL header part
	         ck[0] = ~fchecksum(hdrbuf + 6, LL->net_offs - 6);
	         ck[1] = LL->chksum;
	         ck[1] = fchecksum((byte *)ck, sizeof(ck));
	      #ifdef IP_VERBOSE
	         if (debug_on > 4) {
	            printf("IP: frame checksum=%04X; hdr correction=%04X (len %u); result=%04X\n",
	               LL->chksum, ck[0], LL->net_offs - 6, ck[1]);
	         }
	      #endif
         } else	// must be CHKSUM_ETHPL, so don't need any header correction
      		ck[1] = LL->chksum;
         // Subtract stuff past IP payload.  If this is at odd offset, need to byteswap
         trail_offs = pktlen + LL->net_offs;
         trail = LL->len - trail_offs;	// Number of trailing bytes
         if (trail > 0) {
	         if (trail > sizeof(padbuf) || trail < 2)
	            // Forget about it.  Tport will recompute checksums.
               // This should never be required.
	            LL->chksum_flags = 0;
	         else {
	            _pkt_buf2root(LL, padbuf, trail, trail_offs);
	            ck[0] = ~fchecksum(padbuf, trail);
               if (trail_offs & 1) {
               #asm
               	ld hl,(sp+@sp+ck)
                  ld	a,h
                  ld h,L
                  ld l,a
                  ld (sp+@sp+ck),hl
               #endasm
               }
         		ck[1] = fchecksum((byte *)ck, sizeof(ck));
	         #ifdef IP_VERBOSE
	            if (debug_on > 4) {
	               printf("IP:   trailer correction=%04X (len %u); result=%04X\n",
	                  ck[0], trail, ck[1]);
	            }
	         #endif
            }
         }
         LL->chksum = ck[1];
         if (LL->chksum_flags) {
         	// Didn't get turned off.  Indicate corrected.
         	LL->chksum_flags = CHKSUM_TPORT;
         #ifdef IP_VERBOSE
            if (debug_on > 4) {
               printf("IP: checksum corrected to transport level\n",
                  ck[0], trail, ck[1]);
            }
         #endif
         }
      }
      else
         LL->chksum_flags = 0;
   }

#ifdef FRAGSUPPORT
   if (temp->frags & (IP_MF | IP_OFFSET_N)) {
      if (!(fragstart = fragment(temp, LL)))
         continue;
      else {
         *type = IP_TYPE;
         oldest = fragstart;
         break;
      }
   }
#endif // FRAGSUPPORT

  	LL->net_proto = NET_PROTO_IP;	// Got valid IP packet
   LL->tport_proto = ip->proto;	// Save the next higher layer protocol

#if VIRTUAL_ETH
   // If we support virtual ethernet interfaces i.e. multihoming, then
   // check the IP address and demux to the appropriate interface.
   if (LL->iface < USING_ETHERNET) {
      myip = intel(ip->destination);
      for (iface = IF_MAX; iface < IF_MAX+VIRTUAL_ETH; iface++)
         if (!(_if_tab[iface].u.eth.eflags & EFLAG_VIRT))
            break;   // end of virtual entries
         else if (myip == _if_tab[iface].ipaddr) {
            LL->iface = iface;
            break;
         }
   }
#endif

   switch( ip->proto ) {
#ifndef DISABLE_TCP
      case TCP_PROTO :
         LL = tcp_handler(LL, hdrbuf);
         break;
#endif
#ifndef DISABLE_UDP
      case UDP_PROTO :
         LL = udp_handler(LL, hdrbuf);
         break;
#endif
      case ICMP_PROTO :
         LL = icmp_handler(LL, hdrbuf);
         break;
#ifdef USE_IGMP
      case IGMP_PROTO :
         LL = _igmp_handler(LL, hdrbuf);
         break;
#endif
      default:
         // Send protocol unreachable
         icmp_Unreach(LL, hdrbuf, ICMP_UNREACH_PROTO);
         break;
   }

   return LL;

}

/*
 * Link-Layer Driver Routines.
 *
 */

/*** BeginHeader _pkt_buf2root, _pkt_buf2xmem */
// These are wrappers for the corresponding routines in pktdrv.lib
void _pkt_buf2root(ll_prefix * LL, void * dest, word len, word offset);
void _pkt_buf2xmem(ll_prefix * LL, long dest, word len, word offset);
/*** EndHeader */
_ip_nodebug void _pkt_buf2root(ll_prefix * LL, void * dest, word len, word offset)
{
#asm
	ld		iy,hl
   ld		hl,(sp+@sp+len)
   ld		b,h
   ld		c,L
   bool	hl
   jr		z,.bye
   ld		hl,(sp+@sp+dest)
   ex		de,hl
   ld		hl,(sp+@sp+offset)
	push	ix
   lcall	_pb_buf2root
   pop	ix
.bye:
#endasm
}

_ip_nodebug void _pkt_buf2xmem(ll_prefix * LL, long dest, word len, word offset)
{
#asm
	ld		iy,hl
   ld		hl,(sp+@sp+len)
   ld		b,h
   ld		c,L
   bool	hl
   jr		z,.bye
   ld		hl,(sp+@sp+dest)
   ex		de,hl
   ld		hl,(sp+@sp+dest+2)
   ld		a,L
   ld		hl,(sp+@sp+offset)
	push	ix
   lcall	_pb_buf2xmem
   pop	ix
.bye:
#endasm
}

/*** BeginHeader pkt_reply_ip */
in_Header * pkt_reply_ip(ll_prefix * LL, eth_Packet * base,
								 ll_Gather * g, eth_address * e);
/*** EndHeader */

/*
 * Construct a link-layer header at the specified base address, and return
 * a pointer to where to put the IP header (which will be an offset from base).
 * Note that base does not have to point to a complete eth_Packet struct; only
 * the first 15 bytes are accessed (interface and ethernet header) - the caller
 * will usually add space for the IP header (20 bytes) and a transport header
 * (currently max 24 bytes for TCP, 8 for UDP).  Rather than using these
 * constants, use the macro IP_MAX_PKT_HDR which includes enough space for
 * the biggest link-layer header, an IP header with no options, and a TCP
 * header with 4 bytes of options.
 *
 * This function constructs a reply (link-level only) to the packet in the
 * arrival buffer indicated by LL.  This function is used when there is no
 * ARP table entry for the destination address.
 *
 * If g is not null, *g is zeroed then the following fields are initialized:
 *  g->iface = interface number
 *  g->data1 = pointer to link-layer header start in returned area (typically
 *    14 bytes less than the return value for ethernet).
 *
 * If e is not null, it is used as an ethernet destination address (if applicable)
 * rather than using the LL pointer.  This can be used to force broadcast address,
 * or bypass ARP processing.  Note: e must not be NULL for ethernet interfaces!
 *
 * Note that the interface number is stored in the return area as well as
 * g->iface.  This redundancy allows either _eth_send() or pkt_gather() to be
 * used.  Eventually, _eth_send will be retired so this may go away.
 */

_ip_nodebug in_Header * pkt_reply_ip(ll_prefix * LL, eth_Packet * base,
												 ll_Gather * g, eth_address * e)
{
	auto word iface;
	auto in_Header * retval;

	iface = base->iface = LL->iface;
   if (IF_PKT_ETH(iface)) {
   	// Set up ethernet header for normal ethernet or PPPoE.
      memcpy(base->u.ether.dest, e, 6);
      memcpy(base->u.ether.src, my_eth_addr[iface], 6);
#if USING_PPPOE
      if (IF_P2P(iface)) {
      	// Leave the PPPoE header uninitialized.  It will be inserted by PPPOESend().
      	base->u.ether.type = PPPOE_TYPE;
      	retval = (in_Header *)base->u.pppoe.data;
      }
      else
#endif
      {
      	base->u.ether.type = IP_TYPE;
      	retval = (in_Header *)base->u.ether.data;
      }
   }
   else
      retval = (in_Header *)base->u.pppserial.data;
   if (g) {
   	memset(g, 0, sizeof(ll_Gather));
   	g->iface = (byte)iface;
   	g->data1 = base->u.data;	// Point to eth_packet
   }
   return retval;
}

/*** BeginHeader pkt_make_ip */
in_Header * pkt_make_ip(ATHandle ath, eth_Packet * base, ll_Gather * g);
/*** EndHeader */

/*
 * Similar to pkt_reply_ip, except that the ARP table handle is used
 * to derive the appropriate information.  This is used when an ATH is
 * available.
 */

_ip_nodebug in_Header * pkt_make_ip(ATHandle ath, eth_Packet * base, ll_Gather * g)
{
	auto in_Header * retval;
   auto word biface;

#ifdef MULTI_IF
	_rs_arpcache_iface(ath, &biface);
   base->iface = biface;
	if (biface >= IF_MAX+VIRTUAL_ETH)
		// This can arise for broadcast destinations.  This function does not
		// allow sending to more than one interface, so select the default.
		// If this is not satisfactory, the caller should call _eth_formatpacket()
		// instead, to make the interface explicit.
		base->iface = IF_DEFAULT;
#else
	base->iface = IF_DEFAULT;
#endif
   if (!ATH_IS_P2P(ath)) {
      _rs_arpcache_hwa(ath, base->u.ether.dest);
      memcpy(base->u.ether.src, my_eth_addr[base->iface], 6);
      base->u.ether.type = IP_TYPE;
      retval = (in_Header *)base->u.ether.data;
   }
   else {
#if USING_PPPOE
		if (IF_PKT_ETH(base->iface)) {
			PPPOEACAddress(base->iface, base->u.pppoe.dest);
      	memcpy(base->u.ether.src, my_eth_addr[base->iface], 6);
      	base->u.ether.type = PPPOE_TYPE;
      	retval = (in_Header *)base->u.pppoe.data;
		}
		else
#endif
      retval = (in_Header *)base->u.pppserial.data;
   }
   if (g) {
   	memset(g, 0, sizeof(ll_Gather));
   	g->iface = base->iface;
   	g->data1 = base->u.data;
   }
   return retval;
}



/*** BeginHeader fchecksum */
word fchecksum(void * data, word len);
/*** EndHeader */

/*
 * Fast checksum of >= 2 bytes.  Internet checksums are always calculated over
 * a minimum of 8 bytes, since headers are always included.  Thus the restriction
 * is not a problem in practice.
 */
nodebug word fchecksum(void * data, word len)
{
#asm
		push	ix
		ld		ix,hl
		ld		hl,(sp+@sp+len+2)
		or		a
		rr		hl					; number of words
		ex		af,af'			; remember whether odd in alt carry
		ld		b,l				; count (1..256 words (0=256))
		ld		c,h
		ld		de,0
		ld		a,b
		or		a					; also clears carry for initial add
		jr		z,fc_hloop
		inc	c
fc_hloop:
		ld		hl,(ix)
		inc	ix
		inc	ix
		adc	hl,de
		ex		de,hl
		djnz	fc_hloop
		dec	c
		jr		nz,fc_hloop
		ld		h,c
		ld		l,c				; HL = 0 without changing carry
		ex		af,af'
		jr		nc,fc_was_even
		ld		l,(ix)
fc_was_even:
		ex		af,af'
		adc	hl,de
		adc	hl,bc					; add in final carry (BC was zero)
		pop	ix
#endasm
}


/*** BeginHeader gchecksum, lchecksum */
word gchecksum(ll_Gather * g, word rxpc);
word lchecksum(ll_prefix * LL, word offs, word len);
/*** EndHeader */

#ifndef __R4KASM
#asm root
; Small root function to 1's complement checksum specified number of 16-bit words.
; Must be LCALL'ed, even though it is in root!  On entry
;  A/IX = segmented address of data source
;  B = count for 1st djnz (0 for 256)
;  C = 1 + additional iterations of the DJNZ inner loop (256 for each), or 0 for no iterations
;  DE = initial checksum
; On exit
;  DE = updated checksum
;  L = next char (used in case odd number of bytes being checksummed)
;  H = 0
;  A, IX, BC, flags trashed

xmem_chksum::
		ld		xpc,a
		ld		a,c
		or		a						; also init carry for first iter.
		jr		z,.xmchk_zlen
.xmchk_loop:
		ld		hl,(ix)
		inc	ix
		inc	ix
		adc	hl,de
		ex		de,hl
		djnz	.xmchk_loop
		dec	c
		jr		nz,.xmchk_loop
		jr		nc,.xmchk_zlen
		inc	de						; Add in final carry
.xmchk_zlen:
		bool	hl
		ld		l,(ix)
		lret
#endasm
#endif // !__R4KASM

#asm xmem
; This is a wrapper for xmem_chksum.
; On entry:
;  AHL is linear address of data area (or call update_chksumSeg if already segmented or root.
;    - Rabbit 4000 uses px in either case.
;  CB is length of area (note that this is byte-swapped from normal)
;    - Rabbit 4000 uses BC (not swapped).
;  DE is accumulated checksum (init to zero for first area)
;  Alt Cy flag set if the length of preceding sections is odd (init to 0)
; On return:
;  DE is updated checksum
;  Alt Cy flag set if total length is now odd
update_chksum::
#ifndef __R4KASM
	_LIN2SEG
update_chksumSeg::
   ld		ix,hl		; AIX now segmented address
#endif
   or		a
#ifdef __R4KASM
	rr		bc			; BC is now word count
#else
   rr		c
   rr		b			; CB is word count, Cy set if odd bytes
   jr		z,.noadj
   inc	c
.noadj:
	; Now CB is word count in inner-djnz form
#endif
	; If previous section(s) were odd length, byte swap initial checksum.  It is reversed again at the end
   ex		af,af'
   jr		nc,.noswap
   ld		a,d
   ld		d,e
   ld		e,a
.noswap:
	ex		af,af'
   push	af			; Save Cy flag (for current odd byte count)
#ifdef __R4KASM
	; Do it in-line on the R4k
   ld    a,c
   or    b                 ; also init carry for first iter.
   jr    z,.xmchk_zlen
.xmchk_loop:
   ld    hl,(px)
   ld		px,px+2
   adc   hl,de
   ex    de,hl
   dwjnz  .xmchk_loop
   jr    nc,.xmchk_zlen
   inc   de                ; Add in final carry
.xmchk_zlen:
   ld    hl,(px)
   ld		h,0
#else
   ;lcall   0,xmem_chksum     ; Lcall this root function to preserve XPC
   db    0xCF                 ; Assemble manually to avoid warning
   dw    xmem_chksum
   db    0
#endif
   pop	af
   jr		nc,.waseven				; Skip next if this section was even
   add   hl,de          ; HL contains trailing odd byte (H=0)
   ex    de,hl
   jr    nc,.noinc
   inc   de
.noinc:
	ex		af,af'
   jr		nc,.noswap2
   ld		a,d
   ld		d,e
   ld		e,a
.noswap2:
   ccf						; Keep track of odd or even total - this was odd, so complement oddness
	ex		af,af'
   lret
.waseven:
	ex		af,af'
   jr		nc,.noswap3
   ld		a,d
   ld		d,e
   ld		e,a
.noswap3:
	ex		af,af'
   lret

#endasm

_ip_nodebug word lchecksum(ll_prefix * LL, word offs, word len)
{
	// Compute internet checksum of packet in LL, starting at offset offs, and
   // going for len bytes.  The only simplifying assumption is that the initial
   // offset points to data in the first xmem buffer (out of 1, 2 or 3).
   auto word t;
   auto word x;
   auto ll_Gather g;
   auto long y;

	// Set up g to point to the appropriate data area(s)
   memset(&g, 0, sizeof(g));
   g.len1 = LL->len1 - offs;
#ifdef __R4KASM
	// Note that it is safe to add offs to only the LSBs, since there will not be a carry out
   y = LL->data1 + offs;
   x = (word)y;
	g.data1 = (char *)x;
   x = (word)(y >> 16) + 1;
#else
   #asm
   ld		iy,(sp+@sp+LL)
   ld		hl,(iy+[_llp_]+data1)
   ld		a,(iy+[_llp_]+data1+2)
   _LIN2SEG
   ld		(sp+@sp+t),hl
   bool	hl
   ld		l,a
   ld		(sp+@sp+x),hl
   #endasm
   g.data1 = (void *)(t+offs);
#endif
   if (len <= g.len1)
   	g.len1 = len;
   else {
   	len -= g.len1;
   	g.len2 = LL->len2;
      g.data2 = LL->data2;
		if (len <= g.len2)
      	g.len2 = len;
      else {
      	len -= g.len2;
         g.len3 = len;
			g.data3 = LL->data3;
      }
   }
	return gchecksum(&g, x);
}

/* Compute an internet checksum of the data area(s) defined by the ll_Gather struct, which
   consistes of a header (logical address), plus 0, 1 or 2 physical address areas.
   If the total length is odd, then a final '0' byte is logically appended.
   rxpc provides an XPC segment register value if data1 in the ll_Gather really points to
   an address in the xpc window.

   Rabbit 4000 note: since segmented addressing is not required (indeed, is discouraged)
   the rxpc parameter is used in the following manner:
     If it is zero: g->data1 is a normal logical address
     If it is non-zero: the rxpc value, minus 1, is used to provide the MSBs of the
       physical address.  The LSBs are provided in g->data1.
   */
nodebug word gchecksum(ll_Gather * g, word rxpc)
{
#ifdef __R4KASM
#asm
   ldl	py,hl			; point to ll_Gather
   ld		hl,(sp+@sp+rxpc)
   dec	hl				; Subtract 1.  If the parm was 0, then it is now 0xFFFF which, conveniently,
   						; is suitable for storing a logical address in the px reg.
   ex		jk,hl
   ld		hl,(py+[_llg_]+data1)
   ld		px,jkhl
   ld		de,0			; Initial checksum
   altd or	a				; Clear cy' flag (even starting length)
   ld		hl,(py+[_llg_]+len1)
   ld		bc,hl			; Byte count
   lcall	update_chksum
   ld		hl,(py+[_llg_]+len2)
   ld		bc,hl			; Byte count
   ld		px,(py+[_llg_]+data2)
   lcall	update_chksum
   ld		hl,(py+[_llg_]+len3)
   ld		bc,hl			; Byte count
   ld		px,(py+[_llg_]+data3)
   lcall	update_chksum
   ex		de,hl			; Set return value
#endasm
#else
#asm
	push	iy
   push	ix
   ld		iy,hl			; point to ll_Gather
   ld		hl,(sp+@sp+rxpc+4)
   ld		a,L			; Get initial "root" area xpc (this is a don't care if data1 really points to
   						; the data segment).
   ld		de,0			; Initial checksum
   altd or	a				; Clear cy' flag (even starting length)
   ld		hl,(iy+[_llg_]+len1)
   ld		c,h
   ld		b,L			; Byte count (swapped)
   ld		hl,(iy+[_llg_]+data1)
   lcall	update_chksumSeg
   ld		hl,(iy+[_llg_]+len2)
   ld		c,h
   ld		b,L			; Byte count (swapped)
   ld		hl,(iy+[_llg_]+data2)
   ld		a,(iy+[_llg_]+data2+2)
   lcall	update_chksum
   ld		hl,(iy+[_llg_]+len3)
   ld		c,h
   ld		b,L			; Byte count (swapped)
   ld		hl,(iy+[_llg_]+data3)
   ld		a,(iy+[_llg_]+data3+2)
   lcall	update_chksum
   ex		de,hl			; Set return value
   pop	ix
   pop	iy
#endasm
#endif
}



/*** BeginHeader */
#endif
/*** EndHeader */