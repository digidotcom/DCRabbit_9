/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*
 *    udp.lib
 *    Portions used with permission of Erick Engelke.
 *
 * User Datagram Protocol.
 */
/*** BeginHeader */
#ifndef UDP_H
#define UDP_H

#ifdef UDP_DEBUG
	#define _udp_nodebug debug
#else
	#define _udp_nodebug nodebug
#endif

#ifndef IP_H
	#use "ip.lib"
#endif
#ifndef ICMP_H
	#use "icmp.lib"
#endif

// Default time-to-live of UDP datagrams.  This value from Internet STD0002
#ifndef UDP_TTL
	#define UDP_TTL 64
#endif
// Default type-of-service
#ifndef UDP_TOS
	#define UDP_TOS IPTOS_DEFAULT
#endif

typedef struct {
   word     srcPort;
   word     dstPort;
   word     length;
   word     checksum;
} udp_Header;

#define UDP_LENGTH sizeof(udp_Header)

#if (MAX_UDP_SOCKET_BUFFERS > 0) || (__RABBITSYS)
	#if __RABBITSYS
		void **_udp_buffers;
	#else
		void* _udp_buffers[MAX_UDP_SOCKET_BUFFERS];
	#endif
#endif
long _udp_buf_area;

/*
 * UDP data handler event type codes
 */

#define UDP_DH_INDATA		3				// New inbound datagram received
#define UDP_DH_ICMPMSG		10				// Incoming ICMP message

/*
 * Data structure for a UDP datagram in the socket buffer.  See documentation
 * under udp_peek().
 */
typedef struct {
	longword remip;			// Peer's IP address
	word     remport;			// Peer's port
	int      len;				// Length of following datagram
	word		flags;			// Flags as follows:
#define UDI_ICMP_ERROR		0x0001	// This is an ICMP error entry: data
												//		following is a _udp_icmp_message.
#define UDI_TOS_MASK			0x001E	// Mask for received TOS bits
#define UDI_HWA_VALID		0x0020	// Hardware address field is valid
#define UDI_BROADCAST_LL	0x0040	// Received on broadcast link-layer address
												//		(0xFFFFFFFFFFFF)
#define UDI_BROADCAST_IP	0x0080	// Received on broadcast IP address (local
												///	or all subnets or 0xFFFFFFFF)
#define UDI_MULTICAST_LL	0x0100	// Received on multicast link-layer address
#define UDI_MULTICAST_IP	0x0200	// Received on multicast IP address
	byte		iface;			// Interface on which received
	byte		hwa[6];			// Peer's hardware (ethernet) address, if applicable
} _udp_datagram_info;

typedef struct {
	word myport;				// Local port from which issued
	byte icmp_type;			// One of the ICMPTYPE_* values (see ICMP.LIB)
	byte icmp_code;			// The corresponding ICMP code
} _udp_icmp_message;

/*** EndHeader */



/*** BeginHeader udp_sock_init */
void udp_sock_init(void);
/*** EndHeader */
_udp_nodebug void udp_sock_init(void)
{
#if (MAX_UDP_SOCKET_BUFFERS > 0) && (__RABBITSYS==0)
	memset(_udp_buffers, 0, sizeof(_udp_buffers));
#endif

	// Exit here if we've already run sock_init()
   if(_initialized) return;
#if (MAX_UDP_SOCKET_BUFFERS > 0) && (__RABBITSYS==0)
	_udp_buf_area = xalloc(MAX_UDP_SOCKET_BUFFERS * (long)UDP_BUF_SIZE);
#endif

}

/*** BeginHeader udp_alloc_buffer */
long udp_alloc_buffer(void* sockaddr);
/*** EndHeader */

_udp_nodebug long udp_alloc_buffer(void* sockaddr)
{
#if (MAX_UDP_SOCKET_BUFFERS == 0) && (__RABBITSYS==0)
	return -1;
#else
	auto int i,max,bsize;

#if __RABBITSYS
	max = _rk_max_udp_handles;
	bsize = _rk_udp_buffer_size;
#else
	max = MAX_UDP_SOCKET_BUFFERS;
	bsize = UDP_BUF_SIZE;
#endif

	i = 0;
	while ((i < max) &&
	       (_udp_buffers[i] != NULL) &&
	       (_udp_buffers[i] != sockaddr)) {
		i++;
	}
	if (i >= max) {
		return -1;
	} else if (_udp_buffers[i] == NULL) {
		_udp_buffers[i] = sockaddr;
	}
	return (_udp_buf_area + i * bsize);
#endif
}

/*** BeginHeader udp_open */
#define udp_open( s, lport, remip, port, datahandler ) \
	(udp_extopen(s, IF_DEFAULT, lport, remip, port, datahandler, 0, 0))
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
udp_open                               <UDP.LIB>

SYNTAX: int udp_open( udp_Socket *s, word lport, longword remip,
                      word port, dataHandler_t datahandler );

KEYWORDS:		udp

DESCRIPTION:   Implemented as a MACRO.

					This function opens a UDP socket on the given local port
					(lport).  If the remote IP address is specified (remip),
					then only UDP datagrams from that host will be accepted.
					If remip is 0, then the first datagram received on the
					local port will complete a connection, so that only the
					remote host and/or port can subsequently send datagrams to
					this socket.  Datagrams cannot be sent until the
					connection is completed.  If remip is -1, then all remote
					hosts can send datagrams to this socket.  Datagrams will
					be sent to the broadcast address.  The remote port
					parameter (port) specifies the remote port from which we
					will accept datagrams.  If remip is 0, then this parameter
					is filled in on the first datagram received on the socket.
					If remip is -1, then this parameter is ignored.  If port
					is 0, then it will be filled in on the first datagram
					received on the socket.

					Be sure that you have allocated enough UDP socket buffers
					with MAX_UDP_SOCKET_BUFFERS.  Note that this macro
					defaults to 0, so any usage of udp_open() requires a
					definition of MAX_UDP_SOCKET_BUFFERS in your program.

					This function also works with multicast addresses.  If
					remip is a multicast address, then packets sent with this
					function will go to the multicast address, and packets
					received will also be from that multicast address.  Also,
					if enabled, IGMP will be used to join the multicast groups.
					The group will be left when the socket is closed.  Note
					that if port is 0 and remip is a multicast address, the
					port will not be filled in on the first received datagram
					(that is, the socket is non-binding to the port).

PARAMETER1:    socket
PARAMETER2:    local port
PARAMETER3:    acceptable remote ip, 0 to connect on first datagram, -1
					for all
PARAMETER4:    acceptable remote port, 0 to connect on first datagram
PARAMETER5:    function to call when data is received, NULL for placing
               data in the socket's receive buffer.

RETURN VALUE:  !0  successfully opened socket
					 0  error opening socket (such as if a buffer could not
					    be allocated)

SEE ALSO:      udp_extopen

END DESCRIPTION **********************************************************/


/*** BeginHeader _rs_udp_extopen */
_system int _rs_udp_extopen( _rs_udp_Socket *s, int iface, word lport,
	longword remip, word port, dataHandler_t datahandler,
	long buffer,int buflen );
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
udp_extopen                            <UDP.LIB>

SYNTAX: int udp_extopen( udp_Socket *s, int iface, word lport,
                         longword remip, word port,
                         dataHandler_t datahandler,
                         long buffer, int buflen );

KEYWORDS:		udp

DESCRIPTION: 	This function is an extended version of udp_open.  It
					opens a socket on a given network interface (iface) on a
					given local port (lport).  If the remote IP address is
					specified (remip), then only UDP datagrams from that host
					will be accepted.  If remip is 0, then the first datagram
					received on the local port will complete a connection, so
					that only the remote host and/or port can subsequently
					send datagrams to this socket.  Datagrams can not be sent
					until the connection is completed.  If remip is -1, then
					all remote hosts can send datagrams to this socket.
					Datagrams will be sent to the	broadcast address, unless
					udp_sendto() specifies otherwise.  The remote port
					parameter (port) specifies the remote port from which we
					will accept datagrams.  If remip is 0, then this parameter
					is filled in on the first datagram received on the socket.
					If remip is	-1, then this parameter is ignored.  If port
					is 0, then it will be filled in on the first datagram
					received on the socket.

					The buffer and buflen parameters allow a user to supply
					a socket buffer, instead of using a socket buffer from the
					pool.

					If remip is non-zero, then the process of resolving the
					correct destination hardware address is started.  Datagrams
					cannot be sent until sock_resolved() returns TRUE.  If you
					attempt to send datagrams before this, then the datagrams
					may not get sent.  The exception to this is if remip is
					-1 (broadcast) in which case datagrams may be sent
					immediately after calling this function.

					This function also works with multicast addresses.  If
					remip is a multicast address, then packets sent with this
					function will go to the multicast address, and packets
					received will also be from that multicast address.  Also,
					if enabled, IGMP will be used to join the multicast groups.
					The group will be left when the socket is closed.  Note
					that if port is 0 and remip is a multicast address, the
					port will not be filled in on the first received datagram
					(that is, the socket is non-binding to the port).

PARAMETER1:    socket
PARAMETER2:		local interface on which to open the socket.  Use IF_ANY
               if the socket is to accept datagrams from any interface.
               Otherwise, datagrams will be accepted only from the
               specified interface.
PARAMETER3:    local port
PARAMETER4:    acceptable remote ip, or 0 for all
PARAMETER5:    acceptable remote port, or 0 for all
PARAMETER6:    function to call when data is received, NULL for placing
               data in the sockets receive buffer.
PARAMETER7:		address of user-supplied socket buffer in xmem, 0 to use a
					buffer from the socket buffer pool
PARAMETER8:		length of user-supplied socket buffer

RETURN VALUE:  !0  successfully opened socket
					 0  error opening socket (such as if a buffer could not
					    be allocated)

SEE ALSO:      udp_open, sock_resolved

END DESCRIPTION **********************************************************/

_udp_nodebug
_system int _rs_udp_extopen( _rs_udp_Socket *s, int iface, word lport,
	longword remip, word port, dataHandler_t datahandler,long buffer, int buflen)
{
	_SYS_CALL_VARS
#if __RABBITSYS
	auto byte userflag;
#endif
#ifdef MCOS_LOCKS
	static OS_EVENT *lock_backup;

   if(InitSocketLock((_rs_sock_type *)s))
   	return 0;
   lock_backup = s->lock;
#endif

#if __RABBITSYS
	userflag = s->userSocket;
	s->userSocket = 0;			//turn off flag so close doesn't free memory.
#endif
	_rs_udp_close( s );
   /* this does not blank the rdbuffer buffer - this should not be a problem,
   though */
   memset( s, 0, sizeof( _rs_udp_Socket ));

#if __RABBITSYS
	s->userSocket = userflag;
#endif
#ifdef MCOS_LOCKS
	s->lock = lock_backup;
	s->lock_count = 0;
#endif

#ifdef MCOS
	if(s>=((_rs_udp_Socket*)STACKORG)) {
		exception(-ERR_TCPSOCKETISAUTO);
	}
#endif

   s->ip_type = UDP_PROTO;
   s->iface = iface;

	if (buffer == 0) {
		// Use a buffer from the pool
   	if ((s->rd.buf = udp_alloc_buffer((void *)s)) == -1) {
#ifdef UDP_VERBOSE
			printf("UDP: could not allocate buffer from pool\n");
#endif
			_rs_sock_msg(s, NETERR_OUT_OF_MEMORY);
   		return 0;
   	}
		s->rd.maxlen =
#if __RABBITSYS
			_rk_udp_buffer_size - 1;
#else
   		UDP_BUF_SIZE - 1;
#endif
   } else {
   	// Use the user-supplied buffer
   	s->rd.buf = buffer;
   	s->rd.maxlen = buflen;
   }
   _tbuf_reset(&s->rd);

   s->ttl = UDP_TTL;
   s->tos = UDP_TOS;
   lport = _rs_findfreeport(lport, false);
   s->myport = lport;
  // if (iface == IF_ANY)
  // 	s->myaddr = 0;
  // else
  // 	s->myaddr = _if_tab[iface].ipaddr;
#ifdef USE_MULTICAST
	if (remip && ~remip && !IS_MULTICAST_ADDR(remip))
#else
   if (remip && ~remip)
#endif
		s->sath = _rs_arpresolve_start_iface(remip, iface);
#ifdef USE_MULTICAST
	if (IS_MULTICAST_ADDR(remip))
		_multicast_joingroup_userflag(iface, remip, 0);
#endif
   s->hisaddr = remip;
   s->hisport = port;
   s->dataHandler = datahandler;
   s->usr_yield = system_yield;
   LOCK_QUICK();
   s->next = udp_allsocs;
   udp_allsocs = s;
   UNLOCK_QUICK();
   return( 1 );
}

/*** BeginHeader udp_waitopen */
/* START FUNCTION DESCRIPTION ********************************************
udp_waitopen                            <UDP.LIB>

SYNTAX: int udp_waitopen( udp_Socket *s, int iface, word lport,
                         longword remip, word port,
                         dataHandler_t datahandler,
                         long buffer, int buflen, longword millisecs );

KEYWORDS:		udp

DESCRIPTION: 	This function is identical to udp_extopen(), except that
               it also waits a specified amount of time for the hardware
               address of the destination to be resolved.

               While waiting, this function calls tcp_tick().

PARAMETER1:    socket
PARAMETER2:		local interface on which to open the socket (not yet
					implemented--use IF_DEFAULT for now)
PARAMETER3:    local port
PARAMETER4:    acceptable remote ip, or 0 for all
PARAMETER5:    acceptable remote port, or 0 for all
PARAMETER6:    function to call when data is received, NULL for placing
               data in the sockets receive buffer.
PARAMETER7:		address of user-supplied socket buffer in xmem, 0 to use a
					buffer from the socket buffer pool
PARAMETER8:		length of user-supplied socket buffer
PARAMETER9:    Maximum milliseconds to wait for the hardware address to
               be resolved.

RETURN VALUE:  > 0  successfully opened socket
               0   timed out without resolving address
					-1  error opening socket (such as if a buffer could not
					    be allocated)

SEE ALSO:      udp_extopen, sock_resolved

END DESCRIPTION **********************************************************/
#if !(_SYSTEM)
int udp_waitopen( udp_Socket *s, int iface, word lport, longword remip,
                 word port, dataHandler_t datahandler, long buffer,
                 int buflen, longword millisecs );
#endif
/*** EndHeader */

_udp_nodebug int udp_waitopen( udp_Socket *s, int iface, word lport,
                         longword remip, word port, dataHandler_t datahandler,
                         long buffer, int buflen, longword millisecs )
{
	auto int rc;
	auto longword timer;

	rc = udp_extopen(s, iface, lport, remip, port, datahandler, buffer, buflen);
	if (!rc)
		return -1;
	timer = _SET_TIMEOUT(millisecs);
	while (!sock_resolved(s)) {
		tcp_tick(NULL);
		if (chk_timeout(timer))
			return 0;
	}
	return 1;
}
/*** BeginHeader _rs_udp_close */
_system int _rs_udp_close( _rs_udp_Socket *ds );
/*** EndHeader */

_udp_nodebug _system int _rs_udp_close( _rs_udp_Socket *ds )
{
	_SYS_CALL_VARS
   auto _rs_udp_Socket *s, **sp;

   LOCK_GLOBAL(TCPGlobalLock);
   LOCK_SOCK(ds);
   if (ds->sath) {
   	_rs_arpcache_flush(ds->sath);
   	ds->sath = 0;
   }
   sp = &udp_allsocs;
   for(;;) {
      s = *sp;
      if( s == ds )
      {
         *sp = s->next;
         break;
      }
      if( !s ) break;
      sp = &s->next;
   }
#ifdef USE_MULTICAST
	if (IS_MULTICAST_ADDR(ds->hisaddr)) {
		_multicast_leavegroup_userflag(ds->iface, ds->hisaddr, 0);
	}
#endif
   UNLOCK_SOCK(ds);
   UNLOCK_GLOBAL(TCPGlobalLock);
   return( 0 );
}

/*** BeginHeader udp_handler */
xmem ll_prefix * udp_handler(ll_prefix * LL, byte * hdrbuf);
/*** EndHeader */

/*
 * Handler for incoming packets.
 */
_udp_nodebug xmem ll_prefix * udp_handler(ll_prefix * LL, byte * hdrbuf)
{
	auto in_Header *ip;
   auto udp_Header *up;
   auto tcp_PseudoHeader ph;
   auto long blen;
   auto long bbuf;
   auto ll_Gather g;
   auto word iface;
   auto word len;
   auto word dp;
   auto ATHandle ath;
   auto _rs_udp_Socket *s;
   auto _udp_datagram_info udp_datagram_info;
   auto longword destination, source;
   auto word dstPort, srcPort;
   auto int bcastdest;
   auto int rc;

   ip = (in_Header *)(hdrbuf + LL->net_offs);
   iface = LL->iface;

   // Copy the UDP header to hdrbuf
   if (LL->len < LL->tport_offs + sizeof(udp_Header))
   	return LL;	// Discard it, too short to contain UDP header

   _pkt_buf2root(LL, up = (udp_Header *)(hdrbuf+LL->tport_offs),
   	sizeof(udp_Header), LL->tport_offs);
   LL->payload = LL->tport_offs + sizeof(udp_Header);

	destination = intel(ip->destination);
	source = intel(ip->source);
   len = intel16( up->length );

   dstPort = intel16(up->dstPort);
   srcPort = intel16(up->srcPort);

#ifdef UDP_VERBOSE
	if (debug_on > 4)
		printf("UDP: got pkt %08lX:%u -> %08lX:%u payload=%d i/f=%u\n",
					source, srcPort, destination, dstPort, len-UDP_LENGTH, iface);
#endif

	// Drop if source is claiming broadcast address.  That's a no-no.
	// Accept the packet, however, if it is from 0.0.0.0 (needed to be able to
	// implement a DHCP server on the Rabbit, for example).
	if (source && !IS_VALID_SOURCE(source, iface)) {
#ifdef UDP_VERBOSE
		printf("UDP: dropping because invalid source addr\n");
#endif
		return LL;
	}

#ifdef USE_MULTICAST
	if (IS_MULTICAST_ADDR(destination)) {
		// Check if we are accepting from this multicast address
		if (arpcache_search_iface(destination, 0, iface) > 0) {
			bcastdest = 1;
		}
	}
	else {
#endif
		bcastdest = IS_SUBNET_BCAST_ADDR(destination,iface);
#ifdef USE_MULTICAST
	}
#endif

   if( (!bcastdest									// not a broadcast packet
        && !IS_MY_ADDR(destination,iface)		// not my address
        && _if_tab[iface].ipaddr)) {			// and I know my address
#ifdef UDP_VERBOSE
		printf("UDP: dropping because dest addr (%08lX) is not mine (%08lX)\n",
			destination, _if_tab[iface].ipaddr);
#endif
      return LL;
   }

   if (up->checksum) {
	   ph.src = ip->source;    // still in network order
	   ph.dst = ip->destination;
	   ph.mbz = 0;
	   ph.protocol = UDP_PROTO;
	   ph.length = up->length;
		if ((LL->chksum_flags & CHKSUM_TPORT) && (USING_PPPOE == 0))
      	ph.checksum = LL->chksum;
      else
      	ph.checksum = lchecksum(LL, LL->tport_offs, len);
      if (fchecksum(&ph, sizeof(tcp_PseudoHeader)) != 0xffff) {
#ifdef UDP_VERBOSE
         printf("UDP: bad checksum\n");
#endif
         return LL;
      }
   }

  	udp_datagram_info.remip = source;
	udp_datagram_info.remport = srcPort;
	len -= UDP_LENGTH;
	udp_datagram_info.len = len;
	udp_datagram_info.flags = ip->tos & UDI_TOS_MASK;
	if (IS_SUBNET_BCAST_ADDR(destination,iface))
		udp_datagram_info.flags |= UDI_BROADCAST_IP;
#ifdef USE_MULTICAST
	else if (IS_MULTICAST_ADDR(destination))
		udp_datagram_info.flags |= UDI_MULTICAST_IP;
#endif
	udp_datagram_info.iface = iface;

	if (!IF_P2P(iface)) {
		udp_datagram_info.flags |= UDI_HWA_VALID;
		memcpy(udp_datagram_info.hwa, &((eth_Header *)hdrbuf)->source, 6);
	}

#ifdef USE_DHCP
   // Special processing for DHCP.
	if (dstPort == IPPORT_BOOTPC)
   	// Message directed to DHCP client port.  Invoke dhcp_handler.  It may
   	// return non-zero to tell tcp_tick() not to release the system packet
   	// buffer.
      // DEVIDEA: this will only provide the 1st 512 bytes to dhcp - really need
      //		576 MTU
   	if (dhcp_handler(&udp_datagram_info, LL, ip, up, LL->data1+LL->payload))
      	return NULL;
      else
      	return LL;
#endif

   /*
    * Logic changed to allow demux to UDP ports in all possible states:
    *  1. hisaddr=known, hisport=known
    *  2. hisaddr=0/-1, hisport=0
    *  3. hisaddr=known, hisport=0
    *  4. hisaddr=0/-1, hisport=known
    * Cases 1,2,4 were already handled.  New case 3 allows known host to
    * get back to us from an unknown port number, which is filled in
    * for future communication.  Done for TFTP.
    */

   LOCK_GLOBAL(TCPGlobalLock);
   /* demux to active sockets */
   for (s = udp_allsocs; s; s = s->next) {
		if (s->iface != IF_ANY && s->iface != iface)
			continue;
      if (s->hisport &&
          dstPort == s->myport) {
#ifdef USE_MULTICAST
      	if ((source == s->hisaddr && srcPort == s->hisport) ||
      	    (IS_MULTICAST_ADDR(s->hisaddr) && (destination == s->hisaddr)))
#else
			if (source == s->hisaddr && srcPort == s->hisport)
#endif
      		break;
      }
      else if (!s->hisport &&
               dstPort == s->myport) {
      	if (source == s->hisaddr &&
      	    s->hisaddr != 0 &&
      	    s->hisaddr != 0xffffffffuL) {
      		s->hisport = srcPort;
      		break;
      	}
#ifdef USE_MULTICAST
      	else if (IS_MULTICAST_ADDR(s->hisaddr) &&
      	         (destination == s->hisaddr)) {
      		// Do not set the remote port number for a multicast socket
      		break;
      	}
#endif
      }
   }

   if( !s ) {
      /* demux to passive sockets */
      for( s = udp_allsocs; s; s = s->next ) {
         if ((s->hisaddr == 0 || s->hisaddr == 0xffffffffuL) &&
             dstPort == s->myport) {
#ifdef MULTI_IF
            if (s->iface != IF_ANY && s->iface != iface)
            	continue;
#endif
#ifdef USE_MULTICAST
				if (IS_MULTICAST_ADDR(destination) &&
				    arpcache_search_iface(destination, 0, iface) <= 0)
					continue;
#endif
            LOCK_SOCK(s);
            if( s->hisaddr == 0 ) {
               s->hisaddr = source;
               s->hisport = srcPort;
               s->iface = (byte)iface;
            }
            UNLOCK_SOCK(s);
            break;
			}
		}
   }

   UNLOCK_GLOBAL(TCPGlobalLock);

   if( !s ) {
      // return ICMP port unreachable on non-broadcast
#ifdef UDP_VERBOSE
		if (debug_on) printf("UDP: no applicable socket\n");
#endif
      if(_if_tab[iface].ipaddr && !bcastdest) {
#ifdef UDP_VERBOSE
         if (debug_on) printf("UDP: sending ICMP unreach\n");
#endif
         icmp_Unreach(LL, hdrbuf, ICMP_UNREACH_PORT);
      }
      return LL;
   }

   LOCK_SOCK(s);

   // Cache the hardware address, since we probably want to respond
   //ath = arpcache_new(source, udp_datagram_info.hwa, iface);
   //Vantive 23956: now use ARP lookup instead of sending back to source's MAC address.
   ath = arpresolve_start_iface(source, iface);
   if (ath > 0 && (ath = arpresolve_check(ath, source)) > 0) {
		// Router/localhost resolved, use its MAC
#ifdef UDP_VERBOSE
		if (debug_on > 0) printf("UDP: ...using ARP table entry\n");
#endif
   }
   if (ath > 0)
   	s->sath = ath;

   /* process user data */
   dp = LL->payload;

   //
   if (s->dataHandler) {
   	g.iface = iface;
      // Provide the IP and UDP headers
   	g.len1 = dp - LL->net_offs;
   	g.data1 = hdrbuf + LL->net_offs;
      // Unfortunately, prior to xmem buffers, handlers expected at most two
      // xmem areas, although only one contiguous area was provided in practice.
      // Thus, we have to extract the entire packet if it's bigger than 2
      // buffers (1024 bytes incl headers).
      bbuf = 0;
      if (len + dp < 513) {
      	// Small enough to fit in one area without copy.
      	g.len2 = len;
         g.len3 = 0;
         g.data2 = LL->data1 + dp;
      }
      else if (s->sock_mode & UDP_MODE_NOCONTIG) {
      	// We can provide noncontiguous data
	      if (len + dp < 1025) {
	         g.len2 = 512 - dp;
	         g.len3 = len + dp - 512;
	         g.data2 = LL->data1 + dp;
	         g.data3 = LL->data2;
	      }
	      else {
	         // Is big - copy the last 2 areas to temp xmem
	         blen = dp + len - 512;
	         if (_rs_xavail(NULL, 1, XALLOC_MAYBBB) < blen)
	            goto _udph_finish;
	         g.len3 = (word)blen;
	         g.len2 = 512 - dp;
	         g.data2 = LL->data1 + dp;
	         g.data3 = bbuf = _rs_xalloc(&blen, 0, XALLOC_ANY);
	         _pkt_buf2xmem(LL, bbuf, g.len3, 512);
	      }
      }
      else {
      	// Dynamic C prior to 9.0 compatibility: must make all data contiguous
         blen = len;
         if (_rs_xavail(NULL, 1, XALLOC_MAYBBB) < blen)
            goto _udph_finish;
         g.len3 = 0;
         g.len2 = len;
         g.data2 = bbuf = _rs_xalloc(&blen, 0, XALLOC_ANY);
         _pkt_buf2xmem(LL, bbuf, g.len2, dp);
      }
   	rc = s->dataHandler(UDP_DH_INDATA, s, &g, &udp_datagram_info);
      if (bbuf)
      	_rs_xrelease(bbuf, blen);
      if (rc)
   		goto _udph_finish;
   }

  	// Is there enough space?  If not, then just drop it
  	if ((len + sizeof(_udp_datagram_info)) <= (s->rd.maxlen - s->rd.len)) {
		_tbuf_xwrite(&s->rd, s->rd.len, paddrSS((char *)&udp_datagram_info),
				                 sizeof(_udp_datagram_info));
		s->rd.len += sizeof(_udp_datagram_info);
		_tbuf_bxwrite(&s->rd, s->rd.len, LL, dp, len);
		s->rd.len += len;
  	}
#ifdef UDP_VERBOSE
	else
     	printf("UDP: insufficient rx buffer space for %d bytes\n", len);
#endif

_udph_finish:
   UNLOCK_SOCK(s);
   return LL;
}

/*** BeginHeader udp_send */

/* START FUNCTION DESCRIPTION ********************************************
udp_send                               <UDP.LIB>

SYNTAX: 			int udp_send(udp_Socket* s, char* buffer, int len)

KEYWORDS:		tcpip, socket

DESCRIPTION:   Implemented as a MACRO

					Send a single UDP datagram on a UDP socket.  It will not
					work for a socket for which the remip parameter to
					udp_open() was 0, unless a datagram has first been received
					on the socket.  If the remip parameter to udp_open() was
					-1, then the datagram will be send to the broadcast
					address.

PARAMETER1: 	UDP socket on which to send the datagram
PARAMETER2:		buffer that contains the UDP datagram
PARAMETER3:		length of the UDP datagram

RETURN VALUE:  >=0	number of bytes sent
					-1		failure

SEE ALSO:      udp_sendto, udp_recv, udp_recvfrom, udp_open

END DESCRIPTION **********************************************************/
#if _USER
	#define udp_send(s, buffer, len) \
	   udp_xsendto((s), paddr(buffer), (len), 0, 0)
#else
	#define udp_send(s, buffer, len) \
	   _rs_udp_xsendto((s), paddr(buffer), (len), 0, 0)
#endif
/*** EndHeader */

/*** BeginHeader udp_sendto */

/* START FUNCTION DESCRIPTION ********************************************
udp_sendto                             <UDP.LIB>

SYNTAX: 			int udp_sendto(udp_Socket* s, char* buffer, int len,
					               longword remip, word remport)

KEYWORDS:		tcpip, socket

DESCRIPTION:   Implemented as a MACRO

					Send a single UDP datagram on a UDP socket.  It will
					send the datagram to the IP address specified by remip,
					and the port specified by remport.  Note that this
					function can be used even on a socket that has been
					"connected" to a remote host and port.

PARAMETER1: 	UDP socket on which to send the datagram
PARAMETER2:		buffer that contains the UDP datagram
PARAMETER3:		length of the UDP datagram
PARAMETER4:		IP address of the remote host
PARAMETER5:		port number of the remote host

RETURN VALUE:  >=0	number of bytes sent
					-1		failure
					-2    failed because hardware address not resolved

SEE ALSO:      udp_send, udp_recv, udp_recvfrom, udp_open, udp_xsendto

END DESCRIPTION **********************************************************/

#if _USER
#define udp_sendto(s, buffer, len, remip, remport) \
	udp_xsendto(s, paddr(buffer), len, remip, remport)
#else
#define udp_sendto(s, buffer, len, remip, remport) \
	_rs_udp_xsendto(s, paddr(buffer), len, remip, remport)
#endif
/*** EndHeader */

/*** BeginHeader _rs_udp_xsendto */

/* START FUNCTION DESCRIPTION ********************************************
udp_xsendto                             <UDP.LIB>

SYNTAX: 			int udp_xsendto(udp_Socket* s, long buffer, int len,
					               longword remip, word remport)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Send a single UDP datagram on a UDP socket.  It will
					send the datagram to the IP address specified by remip,
					and the port specified by remport.  Note that this
					function can be used even on a socket that has been
					"connected" to a remote host and port.

					This function is identical to udp_sendto() except that
					the data address is specified as a physical address.

PARAMETER1: 	UDP socket on which to send the datagram
PARAMETER2:		buffer that contains the UDP datagram
PARAMETER3:		length of the UDP datagram
PARAMETER4:		IP address of the remote host
PARAMETER5:		port number of the remote host

RETURN VALUE:  >=0	number of bytes sent
					-1		failure
					-2    failed because hardware address not resolved

SEE ALSO:      udp_send, udp_recv, udp_recvfrom, udp_open, udp_sendto

END DESCRIPTION **********************************************************/
_system int _rs_udp_xsendto(_rs_udp_Socket* s, long buffer, int len, longword remip,
	word remport);
/*** EndHeader */

_udp_nodebug
_system int _rs_udp_xsendto(_rs_udp_Socket* s, long buffer, int len,
	longword remip,word remport)
{
	_SYS_CALL_VARS
	auto _udp_datagram_info udi;
	auto int offset, oldlen, oldmode;
	auto int temp;
   auto ATHandle ath;
   auto word uiface;

	oldlen = len;
	offset = 0;

	if (s->ip_type != UDP_PROTO) {
#ifdef UDP_VERBOSE
		printf("UDP: udp_sendto: invalid socket\n");
#endif
		return -1;
	}

	LOCK_GLOBAL(TCPGlobalLock);
	LOCK_SOCK(s);

	if (remip)
		udi.remip = remip;
	else
		udi.remip = s->hisaddr;
	if (remport)
		udi.remport = remport;
	else
		udi.remport = s->hisport;

   if (s->hisethaddr) {
   	// Bypass ARP in effect
   	udi.iface = s->iface;
   	memcpy(udi.hwa, s->hisethaddr, 6);
   }
   else if ((udi.remip == 0xffffffff) || (IS_MULTICAST_ADDR(udi.remip))) {
   	if (s->iface == IF_ANY) {
			// Cannot broadcast or multicast on IF_ANY
#ifdef UDP_VERBOSE
			printf("UDP: cannot broadcast to IF_ANY\n");
#endif
   		UNLOCK_SOCK(s);
   		UNLOCK_GLOBAL(TCPGlobalLock);
   		return -1;
   	}
   	else if (udi.remip == 0xffffffff) {
			udi.iface = s->iface;
			_rs_arpcache_hwa(ATH_BROADCAST, udi.hwa);
   	}
   	else if (IS_MULTICAST_ADDR(udi.remip)) {
			udi.iface = s->iface;
			multicast_iptohw(udi.hwa, udi.remip);
   	}
   }
   else {
   	if (s->sath)
   		ath = _rs_arpresolve_check(s->sath, udi.remip);
   	// restart if we're not continuing, or the _check returned an error
   	if (!s->sath || (ath < 0 && ath != ATH_AGAIN)) {
   		s->sath = _rs_arpresolve_start_iface(udi.remip, s->iface);
   		ath = _rs_arpresolve_check(s->sath, udi.remip);
   	}
   	if (ath < 0) {
   		if (ath != ATH_AGAIN) {
   			// resolve failed so reset handle to table entry
   			// calling udp_send again will re-start ARP resolution of IP
				s->sath = 0;
   		}
   		// Failed the resolve, or not yet resolved, so can't send.
#ifdef UDP_VERBOSE
			if (debug_on > 4) printf("UDP: cannot send, not resolved\n");
#endif
   		_rs_sock_msg(s, NETERR_NOHOST_ARP);
			UNLOCK_SOCK(s);
			UNLOCK_GLOBAL(TCPGlobalLock);
   		return -2;	// Not resolved indicator
   	}
		_rs_arpcache_iface(ath, &uiface);
      udi.iface = uiface;
      _rs_arpcache_hwa(ath, udi.hwa);
   }

	if (len == 0)
		udp_write(s, 0L, 0, 0, &udi);

	while (len > 0) {
		temp = udp_write(s, buffer + offset, len, offset, &udi);
		offset += temp;
		len = oldlen - offset;
		if (len > 0 && s->usr_yield)
         s->usr_yield();
	}
	UNLOCK_SOCK(s);
	UNLOCK_GLOBAL(TCPGlobalLock);
	return( oldlen );
}

/*** BeginHeader udp_waitsend */

/* START FUNCTION DESCRIPTION ********************************************
udp_waitsend                             <UDP.LIB>

SYNTAX: 			int udp_waitsend(udp_Socket* s, char* buffer, int len,
					       longword remip, word remport, word millisecs)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This is identical to udp_sendto(), except that it will
               block for up to the specified amount of time waiting
               for the hardware address to be resolved.  Normally,
               you should not have to specify more than 100ms for the
               timeout.  If it takes longer than this, the destination
               is probably unavailable.

PARAMETER1: 	UDP socket on which to send the datagram
PARAMETER2:		buffer that contains the UDP datagram
PARAMETER3:		length of the UDP datagram
PARAMETER4:		IP address of the remote host
PARAMETER5:		port number of the remote host
PARAMETER6:		Number of milliseconds to wait for hardware address
                 resolution.  Reasonable values are between 50 and 750
                 milliseconds.

RETURN VALUE:  >=0	number of bytes sent
               -1    failure (invalid UDP socket etc.)
					-2		failure (timed out, no datagram sent)

SEE ALSO:      udp_sendto, udp_recvfrom, udp_bypass_arp

END DESCRIPTION **********************************************************/
#if _USER
int udp_waitsend(udp_Socket* s, char* buffer, int len, longword remip,
               word remport, word millisecs);
#endif
/*** EndHeader */

_udp_nodebug int udp_waitsend(udp_Socket* s, char* buffer, int len,
	longword remip, word remport, word millisecs)
{
	auto longword timer;
	auto int rc;

	timer = _SET_TIMEOUT(millisecs);
	while ((rc = udp_sendto(s, buffer, len, remip, remport)) == -2) {
		tcp_tick(NULL);
		if (chk_timeout(timer))
			break;
	}
	return rc;
}

/*** BeginHeader udp_recv */

/* START FUNCTION DESCRIPTION ********************************************
udp_recv                               <UDP.LIB>

SYNTAX: 			int udp_recv(udp_Socket* s, char* buffer, int len)

KEYWORDS:		tcpip, socket

DESCRIPTION:	Receive a single UDP datagram on a UDP socket.  If the
					buffer is not large enough for the datagram, then the
					datagram will be truncated, with the remainder being
					discarded.

PARAMETER1: 	UDP socket on which to receive the datagram
PARAMETER2:		buffer where the UDP datagram will be stored
PARAMETER3:		maximum length of the buffer

RETURN VALUE:  >=0	number of bytes received
					-1		no datagram waiting
					< -1	error

SEE ALSO:      udp_recvfrom, udp_send, udp_sendto, udp_open

END DESCRIPTION **********************************************************/

#define udp_recv(s, buffer, len) \
	udp_recvfrom((s), (buffer), (len), NULL, NULL)
/*** EndHeader */

/*** BeginHeader _rs_udp_recvfrom */

/* START FUNCTION DESCRIPTION ********************************************
udp_recvfrom                           <UDP.LIB>

SYNTAX: 			int udp_recvfrom(udp_Socket* s, char* buffer, int len,
					                 longword* remip, word* remport)

KEYWORDS:		tcpip, socket

DESCRIPTION:	Receive a single UDP datagram on a UDP socket.  remip and
					remport should be pointers to the locations where the
					remote IP address and remote port from which the datagram
					originated are placed.  If the buffer is not large enough
					for the datagram, then the datagram will be truncated,
					with the remainder being discarded.

					If and only if the UDP_MODE_ICMP or UDP_MODE_DICMP modes
					are set for this socket, then a return code of -3 indicates
					that an ICMP error message is being returned in the
					buffer instead of a normal datagram.  In this case, buffer
					will contain fixed data in the form of a structure of
					type _udp_icmp_message.  The definition of this structure
					is

                 typedef struct {
                   word myport;     // Originating port on this host
                   byte icmp_type;  // One of the ICMPTYPE_* values
                   byte icmp_code;  // The corresponding ICMP code
                 } _udp_icmp_message;

PARAMETER1: 	UDP socket on which to receive the datagram
PARAMETER2:		buffer where the UDP datagram will be stored
PARAMETER3:		maximum length of the buffer
PARAMETER4:		IP address of the remote host of the received datagram
PARAMETER5:		port number of the remote host of the received datagram

RETURN VALUE:  >=0   number of bytes received (normal datagram)
					-1	   no datagram waiting
					-2    error - not a UDP socket
					-3    the returned buffer contains an ICMP error which
					      was queued previously.

SEE ALSO:      udp_recv, udp_send, udp_sendto, udp_open, udp_peek

END DESCRIPTION **********************************************************/
_system int _rs_udp_recvfrom(_rs_udp_Socket* s, void* buffer, int len,
	longword* remip, word* remport);
/*** EndHeader */

_udp_nodebug
_system int _rs_udp_recvfrom(_rs_udp_Socket* s, void* buffer, int len,
	longword* remip, word* remport)
{
	_SYS_CALL_VARS
	auto _udp_datagram_info udp_datagram_info;
	auto int length;

   if(remip)
   	_RK_CHK_POINTER(remip)
   if(remport)
   	_RK_CHK_POINTER(remport)

	if (buffer || len)
		_RK_CHK_POINTER_RANGE(buffer, len)
	if (s->ip_type != UDP_PROTO)
		return -2;

	LOCK_GLOBAL(TCPGlobalLock);
	LOCK_SOCK(s);

nextpkt:
	if (s->rd.len < sizeof(_udp_datagram_info)) {
		length = -1;
		goto finish;
	}
	_tbuf_xread(paddrSS((char *)&udp_datagram_info), &s->rd, 0,
	                sizeof(_udp_datagram_info));
	_tbuf_delete(&s->rd, sizeof(_udp_datagram_info));
	s->rd.len -= sizeof(_udp_datagram_info);

	if (remip)
		*remip = udp_datagram_info.remip;
	if (remport)
		*remport = udp_datagram_info.remport;
	length = udp_datagram_info.len;
	if (length > len)
		length = len;

	if (buffer)
		_tbuf_xread(paddr(buffer), &s->rd, 0, length);
	// Remove the entire datagram, even if it wasn't all read
	_tbuf_delete(&s->rd, udp_datagram_info.len);
	s->rd.len -= udp_datagram_info.len;

	// Was it an ICMP error?
	if (udp_datagram_info.flags & UDI_ICMP_ERROR) {
		if (!(s->sock_mode & (UDP_MODE_ICMP | UDP_MODE_DICMP)))
			// Not interested in these for this socket: get next
			goto nextpkt;
		length = -3;
	}

finish:
	// Return the number of characters written into the buffer
	UNLOCK_SOCK(s);
	UNLOCK_GLOBAL(TCPGlobalLock);
	return (length);
}

/*** BeginHeader _rs_udp_peek */

/* START FUNCTION DESCRIPTION ********************************************
udp_peek                           <UDP.LIB>

SYNTAX: 			int udp_peek(udp_Socket* s, _udp_datagram_info * udi)

KEYWORDS:		tcpip, socket

DESCRIPTION:	Look into the UDP socket receive buffer to see if there is
               a datagram ready to be read using udp_recvfrom().  This
               function does not remove the datagram from the buffer,
               but it allows the application to determine the full
               details about the next datagram, including whether the
               datagram was broadcast.

               The returned data is put in *udi.  udi must point to a
               valid data structure, or be NULL.  The data structure is
                 typedef struct {
	                longword remip;    // Remote host IP address
	                word     remport;  // Remote host port number
	                int      len;      // Length of datagram
	                byte     flags;    // Flags as follows:
	                	// This is an ICMP error entry
	                	#define UDI_ICMP_ERROR		0x01
	                	// Type-of-service bit mask
	                	#define UDI_TOS_MASK       0x1E
	                  // Received on broadcast link-layer address.
                     #define UDI_BROADCAST_LL	0x40
                     // Received on broadcast network (IP) address.
                     #define UDI_BROADCAST_IP	0x80
                   byte     iface;    // Interface number
                 } _udp_datagram_info;


PARAMETER1: 	UDP socket to check
PARAMETER2:		Where to store the returned information.

RETURN VALUE:  1	   a normal datagram is in the receive buffer
					0		no datagram waiting
					-3    an ICMP error message is in the receive buffer - this
							will only be returned if udi parameter is not NULL.

SEE ALSO:      udp_recvfrom

END DESCRIPTION **********************************************************/
_system int _rs_udp_peek(_rs_udp_Socket* s, _udp_datagram_info * udi);
/*** EndHeader */

_udp_nodebug
_system int _rs_udp_peek(_rs_udp_Socket* s, _udp_datagram_info * udi)
{
	_SYS_CALL_VARS
	auto int rc;

   if(udi)
   	_RK_CHK_POINTER(udi)

	LOCK_GLOBAL(TCPGlobalLock);
	LOCK_SOCK(s);

	if (s->rd.len < sizeof(_udp_datagram_info)) {
		UNLOCK_SOCK(s);
		UNLOCK_GLOBAL(TCPGlobalLock);
		return 0;
	}
	rc = 1;
	if (udi) {
		_tbuf_xread(paddr((char *)udi), &s->rd, 0, sizeof(_udp_datagram_info));
		if (udi->flags & UDI_ICMP_ERROR)
			rc = -3;
	}

	UNLOCK_SOCK(s);
	UNLOCK_GLOBAL(TCPGlobalLock);

	return rc;
}

/*
 * The following are to signal compatibility problems to any potential
 * users of the old (now removed) sock_recv_* interface to UDP.
 */

/*** BeginHeader sock_recv_init */
/*** EndHeader */

#error "The sock_recv_* interface to UDP is no longer supported."
#error "Please use the new UDP API."

/*** BeginHeader sock_recv */
/*** EndHeader */

#error "The sock_recv_* interface to UDP is no longer supported."
#error "Please use the new UDP API."

/*** BeginHeader sock_recv_from */
/*** EndHeader */

#error "The sock_recv_* interface to UDP is no longer supported."
#error "Please use the new UDP API."

/*** BeginHeader _rs_udp_bypass_arp */
/* START FUNCTION DESCRIPTION ********************************************
udp_bypass_arp                           <UDP.LIB>

SYNTAX: 			void udp_bypass_arp(udp_Socket *s, eth_address * eth)

KEYWORDS:		tcpip, socket

DESCRIPTION:	Override the normal Address Resolution Protocol for this
               UDP socket.  This is sometimes necessary for special
               purposes such as if the ethernet address is to remain
               fixed, or if the ethernet address is not obtainable using
               ARP.  The great majority of applications should not use
               this function.

               If ARP bypass is in effect for a UDP socket, then
               udp_sendto() will never return the -2 return code.

               The destination interface is also forced to be
               IF_DEFAULT.  If the supplied hardware address is accessible
               from a non-default interface only, then you will need
               to manually set the s->iface field.

PARAMETER1: 	UDP socket
PARAMETER2:		Pointer to override address.  If NULL, then resume normal
               operation i.e. use ARP to resolve ethernet addresses.
               Note that the specified ethernet address must be in static
               storage, since only the pointer is stored.

SEE ALSO:      udp_sendto, udp_waitsend, sock_resolved

END DESCRIPTION **********************************************************/
_system void _rs_udp_bypass_arp(_rs_udp_Socket *s, eth_address * eth);
/*** EndHeader */

_udp_nodebug
_system void _rs_udp_bypass_arp(_rs_udp_Socket *s, eth_address * eth)
{
	_SYS_CALL_VARS
	s->hisethaddr = eth;
	s->iface = IF_DEFAULT;
}

/*** BeginHeader udp_write */
int udp_write(_rs_udp_Socket *s, long datap, word len, word offset,
                  _udp_datagram_info * udi);
/*** EndHeader */

/*
 * udp_write() handles fragmented UDP by assuming it'll be called
 *    once for all fragments with no intervening calls.
 * Always returns length of data written, which may be less than 'len' parameter
 * 	if fragmentation required.
 * Caller must hold global and socket locks.
 * udi fields set as follows:
 *  udi->remip: remote IP
 *  udi->remport: remote port
 *  udi->iface: interface number
 *  udi->hwa: dest MAC address (required if ethernet)
 * If s is null, sending without a socket.  In this case, more of the udi
 * fields are used:
 *  udi->len abused to contain the local port number (len parameter is the
 *		actual length)
 *  udi->flags & UDI_TOS_MASK used for the TOS
 *  TTL set to overall UDP default (UDP_TTL define)
 *  Checksum unconditionally generated
 */

_udp_nodebug int udp_write(_rs_udp_Socket *s, long datap, word len, word offset,
	_udp_datagram_info * udi)
{
   tcp_PseudoHeader ph;
   auto struct udp_pkt {
      in_Header  in;
      udp_Header udp;
      int      data;
   } *pkt;
   auto byte pkt_hdr[IP_MAX_UDP_HDR];
   auto byte * lhdr;
	auto ll_Gather g;
	auto ll_prefix LL;
   auto byte *dp;
   auto in_Header *inp;
   auto udp_Header *udpp;
   auto word maxlen;
   auto int more_frags;
   auto word origlen;
   auto eth_address ethaddr;
   auto longword remip;
   auto word remport, myport;

   origlen = len;
  	remip = udi->remip;
  	remport = udi->remport;
  	LL.iface = udi->iface;
   myport = s ? s->myport : udi->len;
  	pkt = (struct udp_pkt *)pkt_reply_ip(&LL, (eth_Packet *)pkt_hdr, &g,
  		(eth_address *)udi->hwa);

   lhdr = g.data1;

   if (offset)							// this is not the first fragment
      dp = (byte *) &pkt->udp;	// data goes right after IP header
   else {
      dp = (byte *) &pkt->data;
      udpp = &pkt->udp;

      udpp->srcPort = intel16(myport);
      udpp->dstPort = intel16(remport);
      udpp->checksum = 0;
      udpp->length = intel16( UDP_LENGTH + len );
   }
   inp = &pkt->in;

   memset(inp, 0, sizeof(in_Header));

   maxlen = _if_tab[g.iface].mtu - (sizeof(in_Header) + sizeof(udp_Header));
   if (offset) {
      maxlen += sizeof(udp_Header);
      maxlen &= 0xFFF8;      // make a multiple of 8
   }

   if (len > maxlen) {
      maxlen &= 0xFFF8;    // multiple of 8
      len = maxlen;
      more_frags = 1;
   }
   else
   	more_frags = 0;

   inp->length = intel16(sizeof(in_Header) + (offset ? 0 : UDP_LENGTH) + len );

   /* internet header */
   inp->ver_hdrlen=0x45;
   /* if offset non-zero, then is part of a prev datagram so don't incr ID */
   inp->identification = intel16( offset ? ip_id : ++ip_id );
   inp->frags = (offset ? intel16((offset + UDP_LENGTH) >> 3) : 0);
   if (more_frags) inp->frags |= IP_MF;
   inp->ttl = s ? s->ttl : UDP_TTL;
   inp->tos = s ? s->tos : udi->flags & UDI_TOS_MASK;
   inp->proto = UDP_PROTO;
   inp->source = intel(_if_tab[g.iface].ipaddr);
   inp->destination = intel(remip);
   inp->checksum = ~fchecksum(inp, sizeof(in_Header));

   g.data2 = datap;

   /* compute udp checksum if desired */
   if(!offset) {  // only first of frags has UDP header for entire UDP dgram
      if (s && (s->sock_mode & UDP_MODE_NOCHK))
         udpp->checksum = 0;
      else {
         ph.src = inp->source;  /* already INTELled */
         ph.dst = inp->destination;
         ph.mbz = 0;
         ph.protocol = UDP_PROTO;  /* udp */
         ph.length = udpp->length; /* already INTELled */
         g.len1 = sizeof(ph);
         g.data1 = (byte *)&ph;
         g.len2 = origlen;
         ph.checksum = fchecksum(&pkt->udp, UDP_LENGTH);
         udpp->checksum = ~gchecksum(&g, 0);
         g.data1 = lhdr;

         if (!udpp->checksum)
         	// Equivalent in 1's complement.
         	udpp->checksum = 0xFFFF;
      }
   }

   g.len1 =  dp - lhdr;
   g.len2 = len;

#ifdef UDP_VERBOSE
	if (debug_on > 4)
		printf("UDP: sending pkt %08lX:%u -> %08lX:%u payload=%d\n",
					intel(inp->source), myport, remip, remport, len);
#endif
   pkt_gather(&g);

   return len;
}


/*** BeginHeader _udp_notify */
void _udp_notify(icmp_ip_t * icmp, byte msg, ll_prefix * LL);
/*** EndHeader */

_udp_nodebug void _udp_notify(icmp_ip_t * icmp, byte msg, ll_prefix * LL)
{
	/* This is upcalled from ICMP when we get a message relating to the UDP
		protocol. If the ICMP socket info can be demuxed to an active UDP socket,
		we record the ICMP error message in the socket (up to two of them).  It
		is really up to the application to deal with this situation, by regularly
		checking the socket status (using sock_error()).  In addition, socket may
		have UDP_MODE_ICMP/DICMP set in which case more details will be stored in
		the socket's receive queue.
	*/
	auto in_Header * ip;
	auto _udp_datagram_info udi;
	auto _udp_icmp_message uim;
	auto ll_Gather g;
   auto int len, dlen;
   auto udp_Header *up;
   auto _rs_udp_Socket *s;
   auto _rs_udp_Socket *rs;
   auto _rs_udp_Socket *ds;
   auto word myport, hisport;
   auto longword hisip;

   ip = &icmp->ip;		// Reflected IP header

   LOCK_GLOBAL(TCPGlobalLock);

   len = in_GetHdrlenBytes(ip);
   up = (udp_Header *)((byte *)ip + len);   // Reflected UDP header.
   myport = intel16(up->srcPort);
   hisport = intel16(up->dstPort);
   hisip = intel(ip->destination);

   // Find the socket with matching parameters.
   rs = NULL;
   ds = NULL;
   for( s = udp_allsocs; s; s = s->next ) {
      if (!rs &&
          hisport == s->hisport &&
          myport == s->myport &&
          hisip == s->hisaddr )
      	rs = s;
      if (s->sock_mode & UDP_MODE_DICMP)
      	ds = s;
   }

   if (!rs && ds)
   	rs = ds;
   else if (rs && ds && rs->sock_mode & UDP_MODE_ICMP)
   	ds = rs;

   if (rs) {
      _rs_sock_msg(rs, msg ? msg : NETERR_ICMP);
      if (ds) {
      	// This socket wants ICMP messages to be queued
      	// Is there enough space?  If not, then just drop it
      	dlen = sizeof(uim);
      	uim.myport = myport;
      	uim.icmp_type = icmp->type;
      	uim.icmp_code = icmp->code;
      	if (dlen + sizeof(udi) <= ds->rd.maxlen - ds->rd.len) {
	      	udi.remip = hisip;
   	   	udi.remport = hisport;
      		udi.len = dlen;
      		udi.flags = ip->tos & UDI_TOS_MASK | UDI_ICMP_ERROR;
      		udi.iface = LL->iface;
   			if (ds->dataHandler) {
   				g.iface = udi.iface;
			   	g.len1 = 0;
  				 	g.data1 = LL + 1;
			   	g.len2 = dlen;
			   	g.data2 = paddrSS(&uim);
			   	g.len3 = 0;
			   	if (ds->dataHandler(UDP_DH_ICMPMSG, ds, &g, &udi))
			   		goto _untf_finish;
			   }
				_tbuf_xwrite(&ds->rd, ds->rd.len, paddrSS((char *)&udi), sizeof(udi));
				ds->rd.len += sizeof(udi);
				_tbuf_xwrite(&ds->rd, ds->rd.len, paddrSS((char *)&uim), dlen);
				ds->rd.len += dlen;
      	}
#ifdef UDP_VERBOSE
			else
         	printf("UDP: insufficient rx buffer space for ICMP msg\n");
#endif

      }
   }
_untf_finish:
   UNLOCK_GLOBAL(TCPGlobalLock);
}

/*** BeginHeader _udp_check_multicast_sockets */
int _udp_check_multicast_sockets(byte iface, longword ipaddr);
/*** EndHeader */

_udp_nodebug int _udp_check_multicast_sockets(byte iface, longword ipaddr)
{
	auto _rs_udp_Socket* s;

   LOCK_GLOBAL(TCPGlobalLock);
   for (s = udp_allsocs; s; s = s->next) {
   	if (s->iface == iface && s->hisaddr == ipaddr) {
		   UNLOCK_GLOBAL(TCPGlobalLock);
   		return 1;
   	}
   }
   UNLOCK_GLOBAL(TCPGlobalLock);
   return 0;
}

/*** BeginHeader */
#endif
/*** EndHeader */